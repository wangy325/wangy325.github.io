<!doctype html><html lang=zh-CN dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://wangy325.github.io/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><meta property="og:site_name" content="xf&pl"><meta property="og:title" content="设计模式"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="website"><title>设计模式 | xf&amp;pl</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://wangy325.github.io/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/><link rel=stylesheet href=/book.min.21a480c3e6e72098579e2787d343e35263286cda9742462341e6aa278fbea46c.css integrity="sha256-IaSAw+bnIJhXnieH00PjUmMobNqXQkYjQeaqJ4++pGw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh-cn.search.min.c2df43b03e7a9ae96b82634fe3204a8b52c807150e1a240387fa9731a83ccbf5.js integrity="sha256-wt9DsD56mulrgmNP4yBKi1LIBxUOGiQDh/qXMag8y/U=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-HHNKR5H8KN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-HHNKR5H8KN")}</script><link rel=alternate type=application/rss+xml href=https://wangy325.github.io/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml title=xf&pl></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><div class=navi-bar id=navibar><div id=page-title><h2 class=book-brand><a class="flex align-center" href=/zh-cn/><span>xf&amp;pl</span></a></h2></div><div class=page-navi-col><nav><ul><li><a href=/zh-cn/docs/java/>Java</a></li><li><a href=/zh-cn/docs/design_pattern/>DP</a></li><li class=book-section-flat><a href=/zh-cn/docs/note/>Mooc</a></li><li class=book-section-flat><a href=/zh-cn/docs/snippets/>Snippets</a></li></ul><ul><li><a href=/zh-cn/posts/>Blog</a></li><li><a href=/zh-cn/archive/>Archive</a></li></ul></nav></div><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/ required pattern=\S+.*>
<span class=clear_search><img src=/svg/close.svg onclick=clearInput()></span><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><script>function clearInput(){document.getElementById("book-search-input").value="";for(var e=document.getElementById("book-search-results");e.firstChild;)e.removeChild(e.firstChild)}</script><ul class=book-languages><li><a class="flex align-center"><img src=/svg/language.svg class=book-icon alt=Languages>
简体中文</a></label><ul><li><a href=https://wangy325.github.io/en/>English</a></li></ul></li></ul></div><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>设计模式</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav><ul><li class=book-section-flat><strong>Categories</strong><ul><li class="flex justify-between"><a href=/zh-cn/categories/utility/>Utility</a>
<span>11</span></li><li class="flex justify-between"><a href=/zh-cn/categories/python/>Python</a>
<span>17</span></li><li class="flex justify-between"><a href=/zh-cn/categories/mysql/>Mysql</a>
<span>6</span></li><li class="flex justify-between"><a href=/zh-cn/categories/java/>Java</a>
<span>62</span></li><li class="flex justify-between"><a href=/zh-cn/categories/course/>Course</a>
<span>3</span></li><li class="flex justify-between"><a href=/zh-cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<span>2</span></li><li class="flex justify-between"><a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a>
<span>12</span></li><li class="flex justify-between"><a href=/zh-cn/categories/algo/>Algo</a>
<span>5</span></li><li class="flex justify-between"><a href=/zh-cn/categories/docker/>Docker</a>
<span>1</span></li><li class="flex justify-between"><a href=/zh-cn/categories/redis/>Redis</a>
<span>4</span></li><li class="flex justify-between"><a href=/zh-cn/categories/git/>Git</a>
<span>2</span></li></ul></li><li class=book-section-flat><strong>Tags</strong><ul><li class="flex justify-between"><a href=/zh-cn/tags/spring/>Spring</a>
<span>7</span></li><li class="flex justify-between"><a href=/zh-cn/tags/%E8%BD%AF%E4%BB%B6/>软件</a>
<span>7</span></li><li class="flex justify-between"><a href=/zh-cn/tags/Docker/>Docker</a>
<span>2</span></li><li class="flex justify-between"><a href=/zh-cn/tags/snippet/>Snippet</a>
<span>25</span></li><li class="flex justify-between"><a href=/zh-cn/tags/WSL/>WSL</a>
<span>1</span></li><li class="flex justify-between"><a href=/zh-cn/tags/hugo/>Hugo</a>
<span>2</span></li><li class="flex justify-between"><a href=/zh-cn/tags/undone/>Undone</a>
<span>3</span></li><li class="flex justify-between"><a href=/zh-cn/tags/Integration/>Integration</a>
<span>3</span></li><li class="flex justify-between"><a href=/zh-cn/tags/server/>Server</a>
<span>2</span></li><li class="flex justify-between"><a href=/zh-cn/tags/translation/>Translation</a>
<span>3</span></li><li class="flex justify-between"><a href=/zh-cn/tags/crontab/>Crontab</a>
<span>2</span></li><li class="flex justify-between"><a href=/zh-cn/tags/JVM/>JVM</a>
<span>3</span></li><li class="flex justify-between"><a href=/zh-cn/tags/%E5%B9%B6%E5%8F%91/>并发</a>
<span>24</span></li><li class="flex justify-between"><a href=/zh-cn/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/>集合框架</a>
<span>8</span></li></ul></li></ul></nav></aside></header><article class="markdown book-post"><h2><a href=/zh-cn/docs/design_pattern/behaviour/20240329_command/>命令模式</a></h2><div class="postmeta flex align-cneter"><div class="created flex align-cneter"><img src=/svg/calendar-event.svg class=book-icon alt>
<a title='创建者 wangy325'>2024-03-29</a></div><div class="cates flex align-center"><img src=/svg/cates.svg class=book-icon alt>
<a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div><div class="last-modified flex align center"><img src=/svg/edit.svg class=book-icon alt>
<a title='最后修改者 wangy | 2025-03-30'>2025-03-30</a></div></div><p><p>命令模式将"请求"封装成（命令）对象，<em>以便使用不同的请求、队列或者日志来参数化其他对象</em>。
命令模式也支持<strong>撤销</strong>的操作。</p><blockquote><p>命令模式是一种行为设计模式，它可将请求转换为一个包含与请求相关的所有信息的独立对象。该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。</p></blockquote><h3 id=设计原则>设计原则
<a class=anchor href=#%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99>#</a></h3><ol><li>解耦：命令模式使<em>发起者和接收者解耦</em>。发起者不关心具体的接收者，只需要根据已知的命令对象
执行<code>execute()</code>方法即可。</li></ol><h3 id=uml简图>UML简图
<a class=anchor href=#uml%e7%ae%80%e5%9b%be>#</a></h3><script src=/mermaid.min.js></script><script>mermaid.initialize({flowchart:{useMaxWidth:!0},theme:"light"})</script><pre class=mermaid>
classDiagram
direction LR
class Invoker {
    +Command command
    +invoke()
}
Invoker *..> Command
class Command {
    << interface >>
    +execute()
    +undo()
}
ConcreteCommand ..|> Command
class ConcreteCommand {
    Receiver receiver
    +execute()
    +undo()
}
Receiver <--* ConcreteCommand
class Receiver {
    +someOperation()
}
</pre><h3 id=要点>要点
<a class=anchor href=#%e8%a6%81%e7%82%b9>#</a></h3><ol><li>命令模式将发出请求的对象（调用者）和接收请求的对象（接收者）解耦。</li><li>被解耦的对象之间通过命令对象沟通，命令对象封装了接收者和一个或者一组动作。</li><li>调用者通过执行命令对象的<code>execute()</code>方法发出请求，这会使得接收者的动作被调用。</li><li>调用者接收命令作为参数。甚至可以在运行时动态地进行。</li><li>命令支持撤销。</li><li>宏命令是命令的简单延伸，允许一次调用多个命令。宏命令也支持撤销。</li><li>命令也可以用来实现日志和事务系统。<sup>How to?</sup></li></ol><h3 id=示例代码>示例代码
<a class=anchor href=#%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81>#</a></h3><p>在本次示例中，假如你有一个家庭影院，你想通过一个“开关”来一键开启家庭影院，按下这个开关后，系统会执行打开空调，调暗灯光，打开CD播放影片等等一系列操作，我们使用命令模式来完成对应的操作。</p><a href=/zh-cn/docs/design_pattern/behaviour/20240329_command/>...</a></p></article><article class="markdown book-post"><h2><a href=/zh-cn/docs/design_pattern/creation/20240328_singleton/>单例模式</a></h2><div class="postmeta flex align-cneter"><div class="created flex align-cneter"><img src=/svg/calendar-event.svg class=book-icon alt>
<a title='创建者 wangy325'>2024-03-28</a></div><div class="cates flex align-center"><img src=/svg/cates.svg class=book-icon alt>
<a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div><div class="last-modified flex align center"><img src=/svg/edit.svg class=book-icon alt>
<a title='最后修改者 wangy | 2025-03-30'>2025-03-30</a></div></div><p><ul><li><p>by Head First 设计模式</p><blockquote><p>单例模式确保一个类只有一个实例，并且提供一个全局访问点。</p></blockquote></li><li><p>by Dive into Design Patterns</p><blockquote><p><strong>Singleton</strong> is a <em>creation(al)</em> design pattern that lets you ensure
that a class has only one instance, while providing a global
access point to this instance.</p></blockquote></li></ul><a href=/zh-cn/docs/design_pattern/creation/20240328_singleton/>...</a></p></article><article class="markdown book-post"><h2><a href=/zh-cn/docs/design_pattern/creation/20240326_factory/>工厂方法模式</a></h2><div class="postmeta flex align-cneter"><div class="created flex align-cneter"><img src=/svg/calendar-event.svg class=book-icon alt>
<a title='创建者 wangy325'>2024-03-26</a></div><div class="cates flex align-center"><img src=/svg/cates.svg class=book-icon alt>
<a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div><div class="last-modified flex align center"><img src=/svg/edit.svg class=book-icon alt>
<a title='最后修改者 wangy | 2025-03-30'>2025-03-30</a></div></div><p><ul><li><p>by Head First 设计模式</p><blockquote><p>工厂方法模式定义了一个创建对象的接口，但是由子类决定要创建的对象是哪一个。工厂方法把类的实例化推迟到
子类。</p></blockquote></li><li><p>by Dive into Design Patterns</p><blockquote><p><strong>Factory Method</strong> is a <em>creation(al)</em> design pattern that provides an interface for creating
objects in a superclass, but allows subclasses to alter the type of objects that will be
created.</p></blockquote></li></ul><blockquote><p>工厂模式指定工厂仅仅能创建特定类型的产品。</p></blockquote><a href=/zh-cn/docs/design_pattern/creation/20240326_factory/>...</a></p></article><article class="markdown book-post"><h2><a href=/zh-cn/docs/design_pattern/structure/20240321_decorator/>装饰者模式</a></h2><div class="postmeta flex align-cneter"><div class="created flex align-cneter"><img src=/svg/calendar-event.svg class=book-icon alt>
<a title='创建者 wangy325'>2024-03-21</a></div><div class="cates flex align-center"><img src=/svg/cates.svg class=book-icon alt>
<a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div><div class="last-modified flex align center"><img src=/svg/edit.svg class=book-icon alt>
<a title='最后修改者 wangy | 2025-03-30'>2025-03-30</a></div></div><p><ul><li><p>by Head First 设计模式:</p><blockquote><p>动态地将责任附加到对象上。若要拓展功能，装饰者模式提供了比继承更有弹性的替代方案。</p></blockquote></li><li><p>by Dive into Design Patterns:</p><blockquote><p>Also known as <em>Wrapper</em></p><p>Decorator is a structural design pattern that lets you attach new behaviors
to objects by placing these objects inside special wrapper objects that
contain the behaviors.</p></blockquote></li></ul><a href=/zh-cn/docs/design_pattern/structure/20240321_decorator/>...</a></p></article><article class="markdown book-post"><h2><a href=/zh-cn/docs/design_pattern/behaviour/20240308_observer/>观察者模式</a></h2><div class="postmeta flex align-cneter"><div class="created flex align-cneter"><img src=/svg/calendar-event.svg class=book-icon alt>
<a title='创建者 wangy325'>2024-03-08</a></div><div class="cates flex align-center"><img src=/svg/cates.svg class=book-icon alt>
<a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div><div class="last-modified flex align center"><img src=/svg/edit.svg class=book-icon alt>
<a title='最后修改者 wangy | 2025-03-30'>2025-03-30</a></div></div><p><ul><li>by Head First 设计模式<blockquote><p>在对象之间建立一对多的依赖，这样一来，当一个对象的状态改变，依赖它的对象都会收到通知，并且自动更新。</p></blockquote></li><li>by Dive into Design Patterns:<blockquote><p><em>Also Known as: Event-Subscriber, Listener</em></p><p>Observer is a behavioral design pattern that lets you define a <em>subscription mechanism</em>
to notify multiple objects about any events that happen to the object they’re observing.</p></blockquote></li></ul><a href=/zh-cn/docs/design_pattern/behaviour/20240308_observer/>...</a></p></article><article class="markdown book-post"><h2><a href=/zh-cn/docs/design_pattern/behaviour/20240307_strategy/>策略模式</a></h2><div class="postmeta flex align-cneter"><div class="created flex align-cneter"><img src=/svg/calendar-event.svg class=book-icon alt>
<a title='创建者 wangy325'>2024-03-07</a></div><div class="cates flex align-center"><img src=/svg/cates.svg class=book-icon alt>
<a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div><div class="last-modified flex align center"><img src=/svg/edit.svg class=book-icon alt>
<a title='最后修改者 wangy | 2025-03-30'>2025-03-30</a></div></div><p><ul><li><p>by Head First 设计模式:</p><blockquote><p>策略模式定义了算法族，分别封装起来，让他们之间可以互相替换。此模式让算法的<strong>变化</strong>独立于使用算法的"客户"。</p></blockquote></li><li><p>by Dive into Design Patterns:</p><blockquote><p><strong>Strategy</strong> is a behavioral design pattern that lets you define a family of algorithms,
put each of them into a separate class, and make their objects interchangeable.</p></blockquote></li></ul><a href=/zh-cn/docs/design_pattern/behaviour/20240307_strategy/>...</a></p></article><article class="markdown book-post"><h2><a href=/zh-cn/docs/design_pattern/structure/20240401_adaptor/>适配器模式</a></h2><div class="postmeta flex align-cneter"><div class="created flex align-cneter"><img src=/svg/calendar-event.svg class=book-icon alt>
<a title='创建者 wangy325'>2024-04-01</a></div><div class="cates flex align-center"><img src=/svg/cates.svg class=book-icon alt>
<a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div><div class="last-modified flex align center"><img src=/svg/edit.svg class=book-icon alt>
<a title='最后修改者 wangy | 2025-03-30'>2025-03-30</a></div></div><p><p>适配器模式将一个类的接口，转换成客户期望的另一个接口。
适配器模式可以让原本接口不兼容的类可以合作无间。</p><h3 id=设计原则>设计原则
<a class=anchor href=#%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99>#</a></h3><ul><li>针对接口编程，而不是针对实现编程</li><li>多用组合，少用继承</li><li>为交互对象之间的松耦合而努力</li><li>类应该对拓展开放，而对修改关闭 （开放-关闭原则）</li><li>依赖抽象，而不依赖具体类 （依赖倒置原则）</li></ul><h3 id=uml简图>UML简图
<a class=anchor href=#uml%e7%ae%80%e5%9b%be>#</a></h3><script src=/mermaid.min.js></script><script>mermaid.initialize({flowchart:{useMaxWidth:!0},theme:"light"})</script><pre class=mermaid>
classDiagram
direction LR
class Client{
    +Adaptor adaptor
    +otherOperations()
}
class Target {
    << Interface >>
    operationA()
}
Client *--> Adaptor
Adaptor ..|> Target
Adaptor *..> Adaptee
class Adaptor {
    +Adaptee adaptee
    operationA()
}
class Adaptee {
    << Interface >>
    operationB()
}
</pre><h3 id=要点>要点
<a class=anchor href=#%e8%a6%81%e7%82%b9>#</a></h3><ol><li>适配器模式，通过创建"适配器"进行接口转换，可以让不兼容的接口变得兼容。</li><li>适配器模式让客户从接口的实现解耦。</li><li>注意适配器和装饰模式的区别，适配器改变接口以让其对不兼容的对象可用，
装饰模式是通过继承，赋予类新的行为和"职责"。</li><li>当需要使用一个现有的类而可用的接口并不适配时，考虑使用适配器模式。</li></ol><blockquote><p>对象适配器和类适配器</p><a href=/zh-cn/docs/design_pattern/structure/20240401_adaptor/>...</a></p></article><article class="markdown book-post"><h2><a href=/zh-cn/docs/design_pattern/creation/20240326_abstract_factory/>抽象工厂模式</a></h2><div class="postmeta flex align-cneter"><div class="created flex align-cneter"><img src=/svg/calendar-event.svg class=book-icon alt>
<a title='创建者 wangy325'>2024-03-26</a></div><div class="cates flex align-center"><img src=/svg/cates.svg class=book-icon alt>
<a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div><div class="last-modified flex align center"><img src=/svg/edit.svg class=book-icon alt>
<a title='最后修改者 wangy | 2025-03-30'>2025-03-30</a></div></div><p><ul><li><p>by Head First 设计模式</p><blockquote><p>抽象工厂模式提供了一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。
简而言之，抽象工厂可以创建<strong>一群对象</strong>，而不单单只创建一种对象。这是抽象工厂和工厂方法的区别。</p></blockquote></li><li><p>by Dive into Design Patterns</p><blockquote><p><strong>Abstract Factory</strong> is a <em>creation(al)</em> design pattern that lets you
produce families of related objects without specifying their
concrete classes.</p></blockquote></li></ul><a href=/zh-cn/docs/design_pattern/creation/20240326_abstract_factory/>...</a></p></article><article class="markdown book-post"><h2><a href=/zh-cn/docs/design_pattern/behaviour/20240402_template_method/>模板方法模式</a></h2><div class="postmeta flex align-cneter"><div class="created flex align-cneter"><img src=/svg/calendar-event.svg class=book-icon alt>
<a title='创建者 wangy325'>2024-04-02</a></div><div class="cates flex align-center"><img src=/svg/cates.svg class=book-icon alt>
<a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div><div class="last-modified flex align center"><img src=/svg/edit.svg class=book-icon alt>
<a title='最后修改者 wangy | 2025-03-30'>2025-03-30</a></div></div><p><p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤
延迟到子类中。模板方法可以使得子类在不改变算法结构的前提
下，重新 定义算法的某些步骤。</p><a href=/zh-cn/docs/design_pattern/behaviour/20240402_template_method/>...</a></p></article><article class="markdown book-post"><h2><a href=/zh-cn/docs/design_pattern/structure/20240401_facade/>外观模式</a></h2><div class="postmeta flex align-cneter"><div class="created flex align-cneter"><img src=/svg/calendar-event.svg class=book-icon alt>
<a title='创建者 wangy325'>2024-04-01</a></div><div class="cates flex align-center"><img src=/svg/cates.svg class=book-icon alt>
<a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a></div><div class="last-modified flex align center"><img src=/svg/edit.svg class=book-icon alt>
<a title='最后修改者 wangy | 2025-03-30'>2025-03-30</a></div></div><p><p>外观模式提供了一个统一的（简单）接口，用来访问子
系统中的一群接口。外观定义了一个高层接口，让系统更
容易使用。</p><h3 id=设计原则>设计原则
<a class=anchor href=#%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99>#</a></h3><ul><li>针对接口编程，而不是针对实现编程</li><li>多用组合，少用继承</li><li>为交互对象之间的松耦合而努力</li><li>类应该对拓展开放，而对修改关闭 （开放-关闭原则）</li><li>依赖抽象，而不依赖具体类 （依赖倒置原则）</li><li>"最少知识原则"——只和你的朋友交谈，不要让太多的类耦合在一起。</li></ul><h4 id=最少知识原则定义>最少知识原则：定义
<a class=anchor href=#%e6%9c%80%e5%b0%91%e7%9f%a5%e8%af%86%e5%8e%9f%e5%88%99%e5%ae%9a%e4%b9%89>#</a></h4><p>在设计系统中，不管是任何对象，都需要注意它所交互的类有哪些，并注意这些类是怎么交互的。</p><p>最少知识原则希望，在设计系统的过程中，不要让太多的类交杂在一起，免得修改系统中的一部分，
需要修改其他的部分。如果许多部分相互耦合，系统将会变得复杂、脆弱且不易于维护。</p><h4 id=最少知识原则如何遵循>最少知识原则：如何遵循？
<a class=anchor href=#%e6%9c%80%e5%b0%91%e7%9f%a5%e8%af%86%e5%8e%9f%e5%88%99%e5%a6%82%e4%bd%95%e9%81%b5%e5%be%aa>#</a></h4><p>设计系统的过程中，就任何对象而言，在对象的方法内，应该只调用属于一下范畴的方法：</p><ol><li>对象本身的方法</li><li>被当作方法参数而传递进来的对象的方法</li><li>方法内创建或实例化的对象的方法</li><li>对象的任何组件（域、field）的方法</li></ol><blockquote><p>不要调用从上述方法中返回的对象支持的方法。</p></blockquote><p>请看如下例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=ln>1</span><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=nf>getTemp</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=w>    </span><span class=n>Thermometer</span><span class=w> </span><span class=n>thermometer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>station</span><span class=p>.</span><span class=na>getThermometer</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=ln>3</span><span class=cl><span class=w>    </span><span class=k>return</span><span class=w> </span><span class=n>thermometer</span><span class=p>.</span><span class=na>getTemperature</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=ln>4</span><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>应该优化为：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=ln>1</span><span class=cl><span class=kd>public</span><span class=w> </span><span class=kt>float</span><span class=w> </span><span class=nf>getTemp</span><span class=p>(){</span><span class=w>
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=w>    </span><span class=k>return</span><span class=w>  </span><span class=n>station</span><span class=p>.</span><span class=na>getTemperature</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=ln>3</span><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></div><p>而<code>getTemperature</code>方法由<code>station</code>域提供。这样做的好处是，我们
不需要认识<code>Thermometer</code>对象了。让我们始终保持最小的朋友圈！</p><h4 id=最少知识原则缺点>最少知识原则：缺点
<a class=anchor href=#%e6%9c%80%e5%b0%91%e7%9f%a5%e8%af%86%e5%8e%9f%e5%88%99%e7%bc%ba%e7%82%b9>#</a></h4><p>是的，任何事情都是两面。最少知识原则使得系统耦合度降低，减轻了维护成本，
但同时禁止调用中间对象的方法，这不得不让我们制造更多的"包装"类来处理和
其他组件之间的沟通，这可能会导致开发难度增加。</p><p>让我们接着回到『外观模式』吧。</p><h3 id=uml简图>UML简图
<a class=anchor href=#uml%e7%ae%80%e5%9b%be>#</a></h3><img alt=外观模式 height=303 src=/img/dp/fecade.webp width=512><h3 id=要点>要点
<a class=anchor href=#%e8%a6%81%e7%82%b9>#</a></h3><ol><li>外观模式中的<code>Facade</code>就是那个"密友"，它封装了其他要用到的方法，满足了最少知识原则。</li><li>当要简化并统一一堆接口时，可以使用外观模式。</li><li>外观将客户从一个复杂的系统中解耦。</li><li>实现外观，需要将子系统组合进外观中，然后将具体的工作委托给子系统执行。</li><li>一个复杂的子系统，可以有多个外观。</li></ol><h3 id=示例代码>示例代码
<a class=anchor href=#%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81>#</a></h3><p>外观模式（Facade Pattern）是一种结构型设计模式，它提供了一个统一的接口来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。</p><a href=/zh-cn/docs/design_pattern/structure/20240401_facade/>...</a></p></article><ul class=pagination><li class="page_current page_navi">1</li><li class=page_navi><a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/page/2/>2</a></li><li class=page_navi><a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/page/2/>下一页</a></li><li class=page_navi><a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/page/2/>尾页</a></li></ul><div class=copyright><hr class=cline><p>Notes and Memos by wangy325
<a href=https://creativecommons.org/licenses/by/4.0/deed.en title="Creative Commons Attribution">&copy; CC BY 4.0</a></p><p>2019-2025. Powered by
<a href=https://github.com/alex-shpak/hugo-book>Hugo Book</a>
Presented by Github.</p></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav><ul><li class=book-section-flat><strong>Categories</strong><ul><li class="flex justify-between"><a href=/zh-cn/categories/utility/>Utility</a>
<span>11</span></li><li class="flex justify-between"><a href=/zh-cn/categories/python/>Python</a>
<span>17</span></li><li class="flex justify-between"><a href=/zh-cn/categories/mysql/>Mysql</a>
<span>6</span></li><li class="flex justify-between"><a href=/zh-cn/categories/java/>Java</a>
<span>62</span></li><li class="flex justify-between"><a href=/zh-cn/categories/course/>Course</a>
<span>3</span></li><li class="flex justify-between"><a href=/zh-cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<span>2</span></li><li class="flex justify-between"><a href=/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/>设计模式</a>
<span>12</span></li><li class="flex justify-between"><a href=/zh-cn/categories/algo/>Algo</a>
<span>5</span></li><li class="flex justify-between"><a href=/zh-cn/categories/docker/>Docker</a>
<span>1</span></li><li class="flex justify-between"><a href=/zh-cn/categories/redis/>Redis</a>
<span>4</span></li><li class="flex justify-between"><a href=/zh-cn/categories/git/>Git</a>
<span>2</span></li></ul></li><li class=book-section-flat><strong>Tags</strong><ul><li class="flex justify-between"><a href=/zh-cn/tags/spring/>Spring</a>
<span>7</span></li><li class="flex justify-between"><a href=/zh-cn/tags/%E8%BD%AF%E4%BB%B6/>软件</a>
<span>7</span></li><li class="flex justify-between"><a href=/zh-cn/tags/Docker/>Docker</a>
<span>2</span></li><li class="flex justify-between"><a href=/zh-cn/tags/snippet/>Snippet</a>
<span>25</span></li><li class="flex justify-between"><a href=/zh-cn/tags/WSL/>WSL</a>
<span>1</span></li><li class="flex justify-between"><a href=/zh-cn/tags/hugo/>Hugo</a>
<span>2</span></li><li class="flex justify-between"><a href=/zh-cn/tags/undone/>Undone</a>
<span>3</span></li><li class="flex justify-between"><a href=/zh-cn/tags/Integration/>Integration</a>
<span>3</span></li><li class="flex justify-between"><a href=/zh-cn/tags/server/>Server</a>
<span>2</span></li><li class="flex justify-between"><a href=/zh-cn/tags/translation/>Translation</a>
<span>3</span></li><li class="flex justify-between"><a href=/zh-cn/tags/crontab/>Crontab</a>
<span>2</span></li><li class="flex justify-between"><a href=/zh-cn/tags/JVM/>JVM</a>
<span>3</span></li><li class="flex justify-between"><a href=/zh-cn/tags/%E5%B9%B6%E5%8F%91/>并发</a>
<span>24</span></li><li class="flex justify-between"><a href=/zh-cn/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/>集合框架</a>
<span>8</span></li></ul></li></ul></nav></div></aside></main><div class=back-to-top><div id=back-to-top><img src=/svg/chevrons-up.svg srcset="/svg/chevrons-up.svg 500w" onclick=topFunction() class=black>
<img title=回到顶部 src=/svg/chevrons-up-blue.svg srcset="/svg/chevrons-up-blue.svg 500w" onclick=topFunction() class=blue></div><script>let mybutton=document.getElementById("back-to-top");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>500||document.documentElement.scrollTop>500?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){window.scrollTo({top:0,behavior:"smooth"})}</script></div><script src=/js/scroll-listening.js></script></body></html>