<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on xf&amp;pl</title><link>https://wangy325.github.io/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on xf&amp;pl</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Thu, 27 Mar 2025 00:39:02 +0800</lastBuildDate><atom:link href="https://wangy325.github.io/zh-cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>命令模式</title><link>https://wangy325.github.io/zh-cn/docs/design_pattern/behaviour/20240329_command/</link><pubDate>Fri, 29 Mar 2024 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/design_pattern/behaviour/20240329_command/</guid><description>&lt;h2 id="命令模式">
 命令模式
 &lt;a class="anchor" href="#%e5%91%bd%e4%bb%a4%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>命令模式将&amp;quot;请求&amp;quot;封装成（命令）对象，&lt;em>以便使用不同的请求、队列或者日志来参数化其他对象&lt;/em>。
命令模式也支持&lt;strong>撤销&lt;/strong>的操作。&lt;/p>
&lt;blockquote>
&lt;p>命令模式是一种行为设计模式，它可将请求转换为一个包含与请求相关的所有信息的独立对象。
该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。&lt;/p>&lt;/blockquote></description></item><item><title>单例模式</title><link>https://wangy325.github.io/zh-cn/docs/design_pattern/creation/20240328_singleton/</link><pubDate>Thu, 28 Mar 2024 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/design_pattern/creation/20240328_singleton/</guid><description>&lt;h2 id="单例模式">
 单例模式
 &lt;a class="anchor" href="#%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>by Head First 设计模式&lt;/p>
&lt;blockquote>
&lt;p>单例模式确保一个类只有一个实例，并且提供一个全局访问点。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>by Dive into Design Patterns&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Singleton&lt;/strong> is a &lt;em>creational design pattern&lt;/em> that lets you ensure
that a class has only one instance, while providing a global
access point to this instance.&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ul></description></item><item><title>工厂模式</title><link>https://wangy325.github.io/zh-cn/docs/design_pattern/creation/20240326_factory/</link><pubDate>Tue, 26 Mar 2024 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/design_pattern/creation/20240326_factory/</guid><description>&lt;h3 id="工厂模式">
 工厂模式
 &lt;a class="anchor" href="#%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>by Head First 设计模式&lt;/p>
&lt;blockquote>
&lt;p>工厂方法模式定义了一个创建对象的接口，但是由子类决定要创建的对象是哪一个。工厂方法把类的实例化推迟到
子类。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>by Dive into Design Patterns&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Factory Method&lt;/strong> is a creational design pattern that provides an interface for creating
objects in a superclass, but allows subclasses to alter the type of objects that will be
created.&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>工厂模式指定工厂仅仅能创建特定类型的产品。&lt;/p>&lt;/blockquote></description></item><item><title>装饰者模式</title><link>https://wangy325.github.io/zh-cn/docs/design_pattern/structure/20240321_decorator/</link><pubDate>Thu, 21 Mar 2024 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/design_pattern/structure/20240321_decorator/</guid><description>&lt;h2 id="装饰者模式">
 装饰者模式
 &lt;a class="anchor" href="#%e8%a3%85%e9%a5%b0%e8%80%85%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>by Head First 设计模式:&lt;/p>
&lt;blockquote>
&lt;p>动态地将责任附加到对象上。若要拓展功能，装饰者模式提供了比继承更有弹性的替代方案。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>by Dive into Design Patterns:&lt;/p>
&lt;blockquote>
&lt;p>Also known as &lt;em>Wrapper&lt;/em>&lt;/p>
&lt;p>Decorator is a structural design pattern that lets you attach new behaviors
to objects by placing these objects inside special wrapper objects that
contain the behaviors.&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ul></description></item><item><title>观察者模式</title><link>https://wangy325.github.io/zh-cn/docs/design_pattern/behaviour/20240308_observer/</link><pubDate>Fri, 08 Mar 2024 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/design_pattern/behaviour/20240308_observer/</guid><description>&lt;h2 id="观察者模式">
 观察者模式
 &lt;a class="anchor" href="#%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>by Head First 设计模式
&lt;blockquote>
&lt;p>在对象之间建立一对多的依赖，这样一来，当一个对象的状态改变，依赖它的对象都会收到通知，并且自动更新。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;li>by Dive into Design Patterns:
&lt;blockquote>
&lt;p>&lt;em>Also Known as: Event-Subscriber, Listener&lt;/em>&lt;/p>
&lt;p>Observer is a behavioral design pattern that lets you define a &lt;em>subscription mechanism&lt;/em>
to notify multiple objects about any events that happen to the object they’re observing.&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ul></description></item><item><title>策略模式</title><link>https://wangy325.github.io/zh-cn/docs/design_pattern/behaviour/20240307_strategy/</link><pubDate>Thu, 07 Mar 2024 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/design_pattern/behaviour/20240307_strategy/</guid><description>&lt;h2 id="策略模式">
 策略模式
 &lt;a class="anchor" href="#%e7%ad%96%e7%95%a5%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>by Head First 设计模式:&lt;/p>
&lt;blockquote>
&lt;p>策略模式定义了算法族，分别封装起来，让他们之间可以互相替换。此模式让算法的&lt;strong>变化&lt;/strong>独立于使用算法的&amp;quot;客户&amp;quot;。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>by Dive into Design Patterns:&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Strategy&lt;/strong> is a behavioral design pattern that lets you define a family of algorithms,
put each of them into a separate class, and make their objects interchangeable.&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ul></description></item><item><title>适配器模式</title><link>https://wangy325.github.io/zh-cn/docs/design_pattern/structure/20240401_adaptor/</link><pubDate>Mon, 01 Apr 2024 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/design_pattern/structure/20240401_adaptor/</guid><description>&lt;h2 id="适配器模式">
 适配器模式
 &lt;a class="anchor" href="#%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>适配器模式将一个类的接口，转换成客户期望的另一个接口。
适配器模式可以让原本接口不兼容的类可以合作无间。&lt;/p></description></item><item><title>抽象工厂模式</title><link>https://wangy325.github.io/zh-cn/docs/design_pattern/creation/20240326_abstract_factory/</link><pubDate>Tue, 26 Mar 2024 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/design_pattern/creation/20240326_abstract_factory/</guid><description>&lt;h2 id="抽象工厂模式">
 抽象工厂模式
 &lt;a class="anchor" href="#%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>by Head First 设计模式&lt;/p>
&lt;blockquote>
&lt;p>抽象工厂模式提供了一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。
简而言之，抽象工厂可以创建一群对象，而不单单只创建一种对象。&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>by Dive into Design Patterns&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Abstract Factory&lt;/strong> is a creational design pattern that lets you
produce families of related objects without specifying their
concrete classes.&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ul></description></item><item><title>模板方法模式</title><link>https://wangy325.github.io/zh-cn/docs/design_pattern/behaviour/20240402_template_method/</link><pubDate>Tue, 02 Apr 2024 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/design_pattern/behaviour/20240402_template_method/</guid><description>&lt;h2 id="模板方法模式">
 模板方法模式
 &lt;a class="anchor" href="#%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤
延迟到子类中。模板方法可以使得子类在不改变算法结构的前提
下，重新 定义算法的某些步骤。&lt;/p></description></item><item><title>外观模式</title><link>https://wangy325.github.io/zh-cn/docs/design_pattern/structure/20240401_facade/</link><pubDate>Mon, 01 Apr 2024 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/design_pattern/structure/20240401_facade/</guid><description>&lt;h2 id="外观模式facade">
 外观模式（Facade）
 &lt;a class="anchor" href="#%e5%a4%96%e8%a7%82%e6%a8%a1%e5%bc%8ffacade">#&lt;/a>
&lt;/h2>
&lt;p>外观模式提供了一个统一的（简单）接口，用来访问子
系统中的一群接口。外观定义了一个高层接口，让系统更
容易使用。&lt;/p></description></item><item><title>建造者模式</title><link>https://wangy325.github.io/zh-cn/docs/design_pattern/creation/20240313_builder/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/design_pattern/creation/20240313_builder/</guid><description>&lt;blockquote>
&lt;p>本文由Gemini AI生成。&lt;/p>&lt;/blockquote>
&lt;h2 id="建造模式">
 建造模式
 &lt;a class="anchor" href="#%e5%bb%ba%e9%80%a0%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>建造模式是一种创建型设计模式，它将一个复杂对象的构建与其表示分离。它允许你通过一步一步地构建对象来创建不同的表示。&lt;/p></description></item><item><title>代理模式</title><link>https://wangy325.github.io/zh-cn/docs/design_pattern/structure/20181205_proxy/</link><pubDate>Wed, 05 Dec 2018 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/design_pattern/structure/20181205_proxy/</guid><description>&lt;p>代理可以简单理解为，B类托管A类的功能，并根据需求，对A类的访问作&lt;font color=red>&lt;strong>控制&lt;/strong>&lt;/font>，这里的&lt;font color=red>&lt;strong>控制&lt;/strong>&lt;/font>可以理解为对A类方法执行的流程的影响，包括但不限于：&lt;/p></description></item></channel></rss>