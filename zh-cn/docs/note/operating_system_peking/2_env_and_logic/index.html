<!doctype html><html lang=zh-CN dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
    
    “
    📖 回顾：操作系统的主要工作

程序的执行
启动程序、执行程序以及程序结束的工作
完成与体系结构相关的工作
完成应用程序所需的共性服务（提供各种基本服务，读盘、申请内存等等）
性能、安全、健壮等问题

应用程序
————————  虚拟机器界面  ---> 操作系统运行机制（系统调用）
操作系统
———————— 物理机器界面  ---> 操作系统运行环境（CPU状态、中断/异常机制）


"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://wangy325.github.io/zh-cn/docs/note/operating_system_peking/2_env_and_logic/"><meta property="og:site_name" content="xf&pl"><meta property="og:title" content="操作系统运行环境与机制"><meta property="og:description" content="“ 📖 回顾：操作系统的主要工作
程序的执行 启动程序、执行程序以及程序结束的工作 完成与体系结构相关的工作 完成应用程序所需的共性服务（提供各种基本服务，读盘、申请内存等等） 性能、安全、健壮等问题 应用程序
———————— 虚拟机器界面 ---> 操作系统运行机制（系统调用）
操作系统
———————— 物理机器界面 ---> 操作系统运行环境（CPU状态、中断/异常机制）"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2024-07-03T00:00:00+08:00"><meta property="article:modified_time" content="2025-02-25T18:38:02+08:00"><title>操作系统运行环境与机制 | xf&amp;pl</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://wangy325.github.io/zh-cn/docs/note/operating_system_peking/2_env_and_logic/><link rel=stylesheet href=/book.min.0f80ff7d475f0d642b14b3cfd9147a630f8d17898fd71ae55a0a20d17e7de84f.css integrity="sha256-D4D/fUdfDWQrFLPP2RR6Yw+NF4mP1xrlWgog0X596E8=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh-cn.search.min.35afb7f35065f55ee942d35be41ca9ff320b36018e9ea65f13d9ea1028d25d01.js integrity="sha256-Na+381Bl9V7pQtNb5Byp/zILNgGOnqZfE9nqECjSXQE=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-HHNKR5H8KN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-HHNKR5H8KN")}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><div class=navi-bar id=navibar><div id=page-title><h2 class=book-brand><a class="flex align-center" href=/zh-cn/><span>xf&amp;pl</span></a></h2></div><div class=page-navi-col><nav><ul><li class=book-section-flat><a href=/zh-cn/docs/java/>Java</a><ul><li><a role=button>面向对象</a><ul><li><a href=/zh-cn/docs/java/basic/1_%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/>访问权限修饰符</a></li><li><a href=/zh-cn/docs/java/basic/2_static%E5%85%B3%E9%94%AE%E5%AD%97/>static关键字</a></li><li><a href=/zh-cn/docs/java/basic/3_%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/>传值还是传引用</a></li><li><a href=/zh-cn/docs/java/basic/4_final%E5%85%B3%E9%94%AE%E5%AD%97/>final关键字</a></li><li><a href=/zh-cn/docs/java/basic/5_Object%E8%B6%85%E7%B1%BB/>Object超类</a></li><li><a href=/zh-cn/docs/java/basic/5_%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A/>动态绑定与静态绑定</a></li><li><a href=/zh-cn/docs/java/basic/6_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/>抽象类与接口</a></li><li><a href=/zh-cn/docs/java/basic/7_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/>Lambda与函数式接口</a></li><li><a href=/zh-cn/docs/java/basic/8_%E5%86%85%E9%83%A8%E7%B1%BB/>内部类</a></li></ul></li><li><a href=/zh-cn/docs/java/collections/>集合框架</a><ul><li><a href=/zh-cn/docs/java/collections/1_List_arraylist/>ArrayList</a></li><li><a href=/zh-cn/docs/java/collections/1_List_linkedlist/>LinkedList</a></li><li><a href=/zh-cn/docs/java/collections/2_Queue/>Queue</a></li><li><a href=/zh-cn/docs/java/collections/3_Set/>Set</a></li><li><a href=/zh-cn/docs/java/collections/4_Map_hash_tree_map/>HashMap和TreeMap</a></li><li><a href=/zh-cn/docs/java/collections/4_Map_linkedhashmap/>LinkedHashMap</a></li><li><a href=/zh-cn/docs/java/collections/5_HashMap%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>HashMap的源码分析</a></li><li><a href=/zh-cn/docs/java/collections/6_Collections/>Collections工具类</a></li></ul></li><li><a href=/zh-cn/docs/java/concurrency/>并发</a><ul><li><a role=button>锁与同步</a><ul><li><a href=/zh-cn/docs/java/concurrency/conecptes/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_1/>线程与任务(一)</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/>线程与任务(二)</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_1/>资源访问受限--引论</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_2_%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6/>资源访问受限-锁和条件</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_3_synchronized/>synchronized关键字</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_4_%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB/>原子性和可见性</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_5_%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/>线程本地存储</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/3%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/>获取任务的返回值</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/4%E6%AD%BB%E9%94%81/>死锁问题2例</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/5%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1/>终结任务</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/6%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/>生产者-消费者与阻塞队列</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A82%E4%BE%8B/>阻塞队列的使用2例</a></li></ul></li><li><a role=button>线程池</a><ul><li><a href=/zh-cn/docs/java/concurrency/pools/7_1_Executors_and_ExecutorService/>Executors与Executor框架</a></li><li><a href=/zh-cn/docs/java/concurrency/pools/7_2_ThreadPoolExecutor1/>ThreadPoolExecutor(一)</a></li><li><a href=/zh-cn/docs/java/concurrency/pools/7_3_ThreadPoolExecutor2/>ThreadPoolExecutor(二)</a></li><li><a href=/zh-cn/docs/java/concurrency/pools/7_4_CompletionService/>CompletionService</a></li><li><a href=/zh-cn/docs/java/concurrency/pools/8_1_ScheduledExecutorService1/>ScheduledExecutorService(一)</a></li><li><a href=/zh-cn/docs/java/concurrency/pools/8_2_ScheduledExecutorService2/>ScheduledExecutorService(二)</a></li></ul></li><li><a role=button>并发组件</a><ul><li><a href=/zh-cn/docs/java/concurrency/components/9_1_countdownlatch/>CountDownLatch</a></li><li><a href=/zh-cn/docs/java/concurrency/components/9_2_cyclicbarrier/>CyclicBarrier</a></li><li><a href=/zh-cn/docs/java/concurrency/components/9_3_semaphore/>Semaphore</a></li><li><a href=/zh-cn/docs/java/concurrency/components/9_4_exchanger/>Exchanger</a></li><li><a href=/zh-cn/docs/java/concurrency/components/9_5_priorityblockqueue_delayqueue/>PriorityBlockingQueue and DelayQueue</a></li></ul></li></ul></li><li><a role=button>JVM</a><ul><li><a href=/zh-cn/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/>Java内存区域详解(转)</a></li><li><a href=/zh-cn/docs/java/jvm/java-gc/>JVM垃圾回收概要(转)</a></li><li><a href=/zh-cn/docs/java/jvm/10_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/>JMM与volatile关键字(转)</a></li></ul></li></ul></li><li class=book-section-flat><span>Design Pattern</span><ul><li><a role=button>Creation</a><ul><li><a href=/zh-cn/docs/design_pattern/creation/20240328_singleton/>单例模式</a></li><li><a href=/zh-cn/docs/design_pattern/creation/20240326_factory/>工厂模式</a></li><li><a href=/zh-cn/docs/design_pattern/creation/20240326_abstract_factory/>抽象工厂模式</a></li><li><a href=/zh-cn/docs/design_pattern/creation/20240313_builder/>建造者模式</a></li></ul></li><li><a role=button>Behaviour</a><ul><li><a href=/zh-cn/docs/design_pattern/behaviour/20240329_command/>命令模式</a></li><li><a href=/zh-cn/docs/design_pattern/behaviour/20240308_observer/>观察者模式</a></li><li><a href=/zh-cn/docs/design_pattern/behaviour/20240307_strategy/>策略模式</a></li><li><a href=/zh-cn/docs/design_pattern/behaviour/20240402_template_method/>模板方法模式</a></li></ul></li><li><a role=button>Structural</a><ul><li><a href=/zh-cn/docs/design_pattern/structure/20240321_decorator/>装饰者模式</a></li><li><a href=/zh-cn/docs/design_pattern/structure/20240401_adaptor/>适配器模式</a></li><li><a href=/zh-cn/docs/design_pattern/structure/20240401_%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/>外观模式</a></li><li><a href=/zh-cn/docs/design_pattern/structure/20181205_proxy/>代理模式</a></li></ul></li></ul></li><li class=book-section-flat><span>Note</span><ul><li><a href=/zh-cn/docs/note/operating_system_peking/>操作系统原理</a><ul><li><a href=/zh-cn/docs/note/operating_system_peking/1_intro/>引论</a></li><li><a href=/zh-cn/docs/note/operating_system_peking/2_env_and_logic/ class=active>操作系统运行环境与机制</a></li><li><a href=/zh-cn/docs/note/operating_system_peking/3_processes_and_threads/>进程和线程模型</a></li></ul></li><li><a href=/zh-cn/docs/note/algorithms_part1/>算法-第一部分</a><ul></ul></li></ul></li><li class=book-section-flat><span>Snippets</span><ul><li><a role=button>Java</a><ul><li><a href=/zh-cn/docs/snippets/java/Gfunction/>Java接口作为方法入参</a></li><li><a href=/zh-cn/docs/snippets/java/Goto/>Java中使用goto语句？</a></li><li><a href=/zh-cn/docs/snippets/java/ImmutableStr/>Java字符串的不可变</a></li><li><a href=/zh-cn/docs/snippets/java/MainClass/>子类不能调用父类中定义的构造器来实例化</a></li><li><a href=/zh-cn/docs/snippets/java/StaticBlock/>静态代码块的行为</a></li><li><a href=/zh-cn/docs/snippets/java/Threading/>线程竞争</a></li><li><a href=/zh-cn/docs/snippets/java/TryF/>不要在finally块中返回值</a></li></ul></li><li><a role=button>Python</a><ul><li><a role=button>基本概念</a><ul><li><a href=/zh-cn/docs/snippets/pys/intro/1_flow_control/>流程控制语句</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/2_data_list/>列表（list）</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/3_data_str/>字符串，元组和字典</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/4_func/>函数式编程</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/4_important_funcs/>4个重要的内置函数</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/5_file_io/>格式化输出与文件I/O</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/6_try_excep/>异常处理</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/7_scope/>命名空间与作用域</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/8_class_type/>类与对象</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/9_decoration/>闭包与装饰器</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/10_decoration_2/>装饰器2</a></li></ul></li><li><a role=button>线程模型</a><ul><li><a href=/zh-cn/docs/snippets/pys/threading/11_threading/>初窥Python线程</a></li><li><a href=/zh-cn/docs/snippets/pys/threading/12_threading_lock/>线程-锁</a></li><li><a href=/zh-cn/docs/snippets/pys/threading/13_threading_condition/>线程-条件</a></li><li><a href=/zh-cn/docs/snippets/pys/threading/14_threading_semaphore/>线程-信号量</a></li><li><a href=/zh-cn/docs/snippets/pys/threading/15_threading_event/>线程-事件</a></li></ul></li></ul></li><li><a role=button>Gist</a><ul><li><a href=/zh-cn/docs/snippets/gist/clash_pro/>clash_pro代理手动配置示例</a></li></ul></li></ul></li></ul><ul><li><a href=/zh-cn/posts/>Blog</a></li><li><a href=/zh-cn/archive/>Archive</a></li></ul></nav></div><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/ required pattern=\S+.*>
<span class=clear_search><img src=/svg/close.svg onclick=clearInput()></span><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><script>function clearInput(){document.getElementById("book-search-input").value="";for(var e=document.getElementById("book-search-results");e.firstChild;)e.removeChild(e.firstChild)}</script><ul class=book-languages><li><a class="flex align-center"><img src=/svg/language.svg class=book-icon alt=Languages>
简体中文</a></label><ul><li><a href=https://wangy325.github.io/en/>English</a></li></ul></li></ul></div><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh-cn/><span>xf&amp;pl</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/svg/translate.svg class=book-icon alt=Languages>
简体中文</a></label><ul><li><a href=/en/>English</a></li></ul></li></ul><ul><li class=book-section-flat><a href=/zh-cn/docs/java/>Java</a><ul><li><input type=checkbox id=section-ca8cbfedb8cd9b17a23843dec39fe16d class=toggle>
<label for=section-ca8cbfedb8cd9b17a23843dec39fe16d class="flex justify-between"><a role=button>面向对象</a></label><ul><li><a href=/zh-cn/docs/java/basic/1_%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/>访问权限修饰符</a></li><li><a href=/zh-cn/docs/java/basic/2_static%E5%85%B3%E9%94%AE%E5%AD%97/>static关键字</a></li><li><a href=/zh-cn/docs/java/basic/3_%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/>传值还是传引用</a></li><li><a href=/zh-cn/docs/java/basic/4_final%E5%85%B3%E9%94%AE%E5%AD%97/>final关键字</a></li><li><a href=/zh-cn/docs/java/basic/5_Object%E8%B6%85%E7%B1%BB/>Object超类</a></li><li><a href=/zh-cn/docs/java/basic/5_%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A/>动态绑定与静态绑定</a></li><li><a href=/zh-cn/docs/java/basic/6_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/>抽象类与接口</a></li><li><a href=/zh-cn/docs/java/basic/7_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/>Lambda与函数式接口</a></li><li><a href=/zh-cn/docs/java/basic/8_%E5%86%85%E9%83%A8%E7%B1%BB/>内部类</a></li></ul></li><li><input type=checkbox id=section-cc8f9a4be9c1f6095448be9e59bad591 class=toggle>
<label for=section-cc8f9a4be9c1f6095448be9e59bad591 class="flex justify-between"><a href=/zh-cn/docs/java/collections/>集合框架</a></label><ul><li><a href=/zh-cn/docs/java/collections/1_List_arraylist/>ArrayList</a></li><li><a href=/zh-cn/docs/java/collections/1_List_linkedlist/>LinkedList</a></li><li><a href=/zh-cn/docs/java/collections/2_Queue/>Queue</a></li><li><a href=/zh-cn/docs/java/collections/3_Set/>Set</a></li><li><a href=/zh-cn/docs/java/collections/4_Map_hash_tree_map/>HashMap和TreeMap</a></li><li><a href=/zh-cn/docs/java/collections/4_Map_linkedhashmap/>LinkedHashMap</a></li><li><a href=/zh-cn/docs/java/collections/5_HashMap%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>HashMap的源码分析</a></li><li><a href=/zh-cn/docs/java/collections/6_Collections/>Collections工具类</a></li></ul></li><li><input type=checkbox id=section-3609ad9ce28a9e0e69f1d931292b83b8 class=toggle>
<label for=section-3609ad9ce28a9e0e69f1d931292b83b8 class="flex justify-between"><a href=/zh-cn/docs/java/concurrency/>并发</a></label><ul><li><input type=checkbox id=section-c4053730d867c308382c587fe6215972 class=toggle>
<label for=section-c4053730d867c308382c587fe6215972 class="flex justify-between"><a role=button>锁与同步</a></label><ul><li><a href=/zh-cn/docs/java/concurrency/conecptes/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_1/>线程与任务(一)</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/>线程与任务(二)</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_1/>资源访问受限--引论</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_2_%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6/>资源访问受限-锁和条件</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_3_synchronized/>synchronized关键字</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_4_%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB/>原子性和可见性</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_5_%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/>线程本地存储</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/3%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/>获取任务的返回值</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/4%E6%AD%BB%E9%94%81/>死锁问题2例</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/5%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1/>终结任务</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/6%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/>生产者-消费者与阻塞队列</a></li><li><a href=/zh-cn/docs/java/concurrency/conecptes/6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A82%E4%BE%8B/>阻塞队列的使用2例</a></li></ul></li><li><input type=checkbox id=section-566ef64757d36b98fe67804b5c360ae8 class=toggle>
<label for=section-566ef64757d36b98fe67804b5c360ae8 class="flex justify-between"><a role=button>线程池</a></label><ul><li><a href=/zh-cn/docs/java/concurrency/pools/7_1_Executors_and_ExecutorService/>Executors与Executor框架</a></li><li><a href=/zh-cn/docs/java/concurrency/pools/7_2_ThreadPoolExecutor1/>ThreadPoolExecutor(一)</a></li><li><a href=/zh-cn/docs/java/concurrency/pools/7_3_ThreadPoolExecutor2/>ThreadPoolExecutor(二)</a></li><li><a href=/zh-cn/docs/java/concurrency/pools/7_4_CompletionService/>CompletionService</a></li><li><a href=/zh-cn/docs/java/concurrency/pools/8_1_ScheduledExecutorService1/>ScheduledExecutorService(一)</a></li><li><a href=/zh-cn/docs/java/concurrency/pools/8_2_ScheduledExecutorService2/>ScheduledExecutorService(二)</a></li></ul></li><li><input type=checkbox id=section-3e279b5e02791c6f975beaf42ab8da60 class=toggle>
<label for=section-3e279b5e02791c6f975beaf42ab8da60 class="flex justify-between"><a role=button>并发组件</a></label><ul><li><a href=/zh-cn/docs/java/concurrency/components/9_1_countdownlatch/>CountDownLatch</a></li><li><a href=/zh-cn/docs/java/concurrency/components/9_2_cyclicbarrier/>CyclicBarrier</a></li><li><a href=/zh-cn/docs/java/concurrency/components/9_3_semaphore/>Semaphore</a></li><li><a href=/zh-cn/docs/java/concurrency/components/9_4_exchanger/>Exchanger</a></li><li><a href=/zh-cn/docs/java/concurrency/components/9_5_priorityblockqueue_delayqueue/>PriorityBlockingQueue and DelayQueue</a></li></ul></li></ul></li><li><input type=checkbox id=section-3bd094917595c7b08e12213b93b8f0f5 class=toggle>
<label for=section-3bd094917595c7b08e12213b93b8f0f5 class="flex justify-between"><a role=button>JVM</a></label><ul><li><a href=/zh-cn/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/>Java内存区域详解(转)</a></li><li><a href=/zh-cn/docs/java/jvm/java-gc/>JVM垃圾回收概要(转)</a></li><li><a href=/zh-cn/docs/java/jvm/10_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/>JMM与volatile关键字(转)</a></li></ul></li></ul></li><li class=book-section-flat><span>Design Pattern</span><ul><li><input type=checkbox id=section-38f2a4dc1224a3f63cb15f52b157f80c class=toggle>
<label for=section-38f2a4dc1224a3f63cb15f52b157f80c class="flex justify-between"><a role=button>Creation</a></label><ul><li><a href=/zh-cn/docs/design_pattern/creation/20240328_singleton/>单例模式</a></li><li><a href=/zh-cn/docs/design_pattern/creation/20240326_factory/>工厂模式</a></li><li><a href=/zh-cn/docs/design_pattern/creation/20240326_abstract_factory/>抽象工厂模式</a></li><li><a href=/zh-cn/docs/design_pattern/creation/20240313_builder/>建造者模式</a></li></ul></li><li><input type=checkbox id=section-2916cf7825614f6c5714a12668976218 class=toggle>
<label for=section-2916cf7825614f6c5714a12668976218 class="flex justify-between"><a role=button>Behaviour</a></label><ul><li><a href=/zh-cn/docs/design_pattern/behaviour/20240329_command/>命令模式</a></li><li><a href=/zh-cn/docs/design_pattern/behaviour/20240308_observer/>观察者模式</a></li><li><a href=/zh-cn/docs/design_pattern/behaviour/20240307_strategy/>策略模式</a></li><li><a href=/zh-cn/docs/design_pattern/behaviour/20240402_template_method/>模板方法模式</a></li></ul></li><li><input type=checkbox id=section-b9c02f715df93d0c0f9aac2c7959042e class=toggle>
<label for=section-b9c02f715df93d0c0f9aac2c7959042e class="flex justify-between"><a role=button>Structural</a></label><ul><li><a href=/zh-cn/docs/design_pattern/structure/20240321_decorator/>装饰者模式</a></li><li><a href=/zh-cn/docs/design_pattern/structure/20240401_adaptor/>适配器模式</a></li><li><a href=/zh-cn/docs/design_pattern/structure/20240401_%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/>外观模式</a></li><li><a href=/zh-cn/docs/design_pattern/structure/20181205_proxy/>代理模式</a></li></ul></li></ul></li><li class=book-section-flat><span>Note</span><ul><li><input type=checkbox id=section-e244588c8ce424aa1cf15d199f1ef0e3 class=toggle checked>
<label for=section-e244588c8ce424aa1cf15d199f1ef0e3 class="flex justify-between"><a href=/zh-cn/docs/note/operating_system_peking/>操作系统原理</a></label><ul><li><a href=/zh-cn/docs/note/operating_system_peking/1_intro/>引论</a></li><li><a href=/zh-cn/docs/note/operating_system_peking/2_env_and_logic/ class=active>操作系统运行环境与机制</a></li><li><a href=/zh-cn/docs/note/operating_system_peking/3_processes_and_threads/>进程和线程模型</a></li></ul></li><li><input type=checkbox id=section-a89519ae3821a3361de4402069b7400c class=toggle>
<label for=section-a89519ae3821a3361de4402069b7400c class="flex justify-between"><a href=/zh-cn/docs/note/algorithms_part1/>算法-第一部分</a></label><ul></ul></li></ul></li><li class=book-section-flat><span>Snippets</span><ul><li><input type=checkbox id=section-dd52bdbe9ac4751ef3dcf3461e80649d class=toggle>
<label for=section-dd52bdbe9ac4751ef3dcf3461e80649d class="flex justify-between"><a role=button>Java</a></label><ul><li><a href=/zh-cn/docs/snippets/java/Gfunction/>Java接口作为方法入参</a></li><li><a href=/zh-cn/docs/snippets/java/Goto/>Java中使用goto语句？</a></li><li><a href=/zh-cn/docs/snippets/java/ImmutableStr/>Java字符串的不可变</a></li><li><a href=/zh-cn/docs/snippets/java/MainClass/>子类不能调用父类中定义的构造器来实例化</a></li><li><a href=/zh-cn/docs/snippets/java/StaticBlock/>静态代码块的行为</a></li><li><a href=/zh-cn/docs/snippets/java/Threading/>线程竞争</a></li><li><a href=/zh-cn/docs/snippets/java/TryF/>不要在finally块中返回值</a></li></ul></li><li><input type=checkbox id=section-8e86454c83f21433a52f142ad9bf5b57 class=toggle>
<label for=section-8e86454c83f21433a52f142ad9bf5b57 class="flex justify-between"><a role=button>Python</a></label><ul><li><input type=checkbox id=section-5a39b63c2f73603c10d31897dff8e759 class=toggle>
<label for=section-5a39b63c2f73603c10d31897dff8e759 class="flex justify-between"><a role=button>基本概念</a></label><ul><li><a href=/zh-cn/docs/snippets/pys/intro/1_flow_control/>流程控制语句</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/2_data_list/>列表（list）</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/3_data_str/>字符串，元组和字典</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/4_func/>函数式编程</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/4_important_funcs/>4个重要的内置函数</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/5_file_io/>格式化输出与文件I/O</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/6_try_excep/>异常处理</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/7_scope/>命名空间与作用域</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/8_class_type/>类与对象</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/9_decoration/>闭包与装饰器</a></li><li><a href=/zh-cn/docs/snippets/pys/intro/10_decoration_2/>装饰器2</a></li></ul></li><li><input type=checkbox id=section-8a2ade9bb18f622d5ede552ec13316cb class=toggle>
<label for=section-8a2ade9bb18f622d5ede552ec13316cb class="flex justify-between"><a role=button>线程模型</a></label><ul><li><a href=/zh-cn/docs/snippets/pys/threading/11_threading/>初窥Python线程</a></li><li><a href=/zh-cn/docs/snippets/pys/threading/12_threading_lock/>线程-锁</a></li><li><a href=/zh-cn/docs/snippets/pys/threading/13_threading_condition/>线程-条件</a></li><li><a href=/zh-cn/docs/snippets/pys/threading/14_threading_semaphore/>线程-信号量</a></li><li><a href=/zh-cn/docs/snippets/pys/threading/15_threading_event/>线程-事件</a></li></ul></li></ul></li><li><input type=checkbox id=section-6c0052d68c843d8c1b215d5a7052aac5 class=toggle>
<label for=section-6c0052d68c843d8c1b215d5a7052aac5 class="flex justify-between"><a role=button>Gist</a></label><ul><li><a href=/zh-cn/docs/snippets/gist/clash_pro/>clash_pro代理手动配置示例</a></li></ul></li></ul></li></ul><ul><li><a href=/zh-cn/posts/>Blog</a></li><li><a href=/zh-cn/archive/>Archive</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>操作系统运行环境与机制</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><div id=toc-new><ul class=nav><li class=nav-item><a id=t1处理器状态模式 href=javascript:void(0) onclick='return scrolly("1-处理器状态模式"),!1'>1 处理器状态(模式)</a><ul class=nav><li class=nav-item><a id=t11中央处理器CPU href=javascript:void(0) onclick='return scrolly("11-中央处理器cpu"),!1'>1.1 中央处理器(CPU)</a></li><li class=nav-item><a id=t12控制和状态寄存器 href=javascript:void(0) onclick='return scrolly("12-控制和状态寄存器"),!1'>1.2 控制和状态寄存器</a></li><li class=nav-item><a id=t13操作系统的需求——保护 href=javascript:void(0) onclick='return scrolly("13-操作系统的需求保护"),!1'>1.3 操作系统的需求——保护</a></li><li class=nav-item><a id=t14处理器模式状态MODE href=javascript:void(0) onclick='return scrolly("14-处理器模式状态mode"),!1'>1.4 处理器模式/状态(MODE)</a></li><li class=nav-item><a id=t15特权指令和非特权指令 href=javascript:void(0) onclick='return scrolly("15-特权指令和非特权指令"),!1'>1.5 特权指令和非特权指令</a></li><li class=nav-item><a id=t16实例：x86系列处理器 href=javascript:void(0) onclick='return scrolly("16-实例：x86系列处理器"),!1'>1.6 实例：x86系列处理器</a></li><li class=nav-item><a id=t17CPU状态之间的转换 href=javascript:void(0) onclick='return scrolly("17-cpu状态之间的转换"),!1'>1.7 CPU状态之间的转换</a></li></ul></li><li class=nav-item><a id=t2中断与异常机制 href=javascript:void(0) onclick='return scrolly("2-中断与异常机制"),!1'>2 中断与异常机制</a><ul class=nav><li class=nav-item><a id=t21为什么引入中断与异常 href=javascript:void(0) onclick='return scrolly("21-为什么引入中断与异常"),!1'>2.1 为什么引入中断与异常</a></li><li class=nav-item><a id=t22原理 href=javascript:void(0) onclick='return scrolly("22-原理"),!1'>2.2 原理</a><ul class=nav><li class=nav-item><a id=t221中断响应 href=javascript:void(0) onclick='return scrolly("221-中断响应"),!1'>2.2.1 中断响应</a></li><li class=nav-item><a id=t222中断向量表 href=javascript:void(0) onclick='return scrolly("222-中断向量表"),!1'>2.2.2 中断向量表</a></li><li class=nav-item><a id=t223中断处理程序 href=javascript:void(0) onclick='return scrolly("223-中断处理程序"),!1'>2.2.3 中断处理程序</a></li><li class=nav-item><a id=t224中断异常处理流程 href=javascript:void(0) onclick='return scrolly("224-中断异常处理流程"),!1'>2.2.4 中断/异常处理流程</a></li></ul></li><li class=nav-item><a id=t23x86中的中断与异常机制 href=javascript:void(0) onclick='return scrolly("23-x86中的中断与异常机制"),!1'>2.3 x86中的中断与异常机制</a><ul class=nav><li class=nav-item><a id=t231中断门描述符表 href=javascript:void(0) onclick='return scrolly("231-中断门描述符表"),!1'>2.3.1 中断门描述符表</a></li><li class=nav-item><a id=t232中断异常的硬件处理过程 href=javascript:void(0) onclick='return scrolly("232-中断异常的硬件处理过程"),!1'>2.3.2 中断/异常的硬件处理过程</a></li></ul></li></ul></li><li class=nav-item><a id=t3系统调用机制 href=javascript:void(0) onclick='return scrolly("3-系统调用机制"),!1'>3 系统调用机制</a><ul class=nav><li class=nav-item><a id=t31系统调用的概念 href=javascript:void(0) onclick='return scrolly("31-系统调用的概念"),!1'>3.1 系统调用的概念</a></li><li class=nav-item><a id=t32系统调用的设计 href=javascript:void(0) onclick='return scrolly("32-系统调用的设计"),!1'>3.2 系统调用的设计</a><ul class=nav><li class=nav-item><a id=t321系统调用的要素 href=javascript:void(0) onclick='return scrolly("321-系统调用的要素"),!1'>3.2.1 系统调用的要素</a></li><li class=nav-item><a id=t322参数的传递 href=javascript:void(0) onclick='return scrolly("322-参数的传递"),!1'>3.2.2 参数的传递</a></li><li class=nav-item><a id=t323系统调用示例分析 href=javascript:void(0) onclick='return scrolly("323-系统调用示例分析"),!1'>3.2.3 系统调用示例分析</a></li></ul></li><li class=nav-item><a id=t33系统调用的执行过程 href=javascript:void(0) onclick='return scrolly("33-系统调用的执行过程"),!1'>3.3 系统调用的执行过程</a></li></ul></li><li class=nav-item><a id=t4基于x86的Linux系统调用机制简介 href=javascript:void(0) onclick='return scrolly("4-基于x86的linux系统调用机制简介"),!1'>4 基于x86的Linux系统调用机制简介</a></li><li class=nav-item><a id=t5本章重点 href=javascript:void(0) onclick='return scrolly("5-本章重点"),!1'>5 本章重点</a></li></ul></div><script>function scrolly(e){const t=40;var n=document.getElementById(e).offsetTop;window.scrollTo({top:n+t,behaviour:"smooth"})}</script></aside></header><article class="markdown book-article"><h1>操作系统运行环境与机制</h1><div class="postmeta flex align-cneter" style=justify-content:center><div class="created flex align-cneter"><img src=/svg/calendar-event.svg class=book-icon alt>
<a title='创建者 wangy325'>2024-07-03</a></div><div class="cates flex align-center"><img src=/svg/cates.svg class=book-icon alt>
<a href=/zh-cn/categories/course/>Course
</a><a href=/zh-cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></div><div class="last-modified flex align center"><img src=/svg/edit.svg class=book-icon alt>
<a title='最后修改者 wangy325-win | 2025-02-25'>2025-02-25</a></div></div><blockquote class="book-hint info"><a class=hint-start>“</a><p>📖 回顾：操作系统的主要工作</p><ul><li>程序的执行
启动程序、执行程序以及程序结束的工作</li><li>完成与体系结构相关的工作</li><li>完成应用程序所需的共性服务（提供各种基本服务，读盘、申请内存等等）</li><li>性能、安全、健壮等问题</li></ul><p>应用程序</p><p>———————— 虚拟机器界面 ---> 操作系统运行机制（系统调用）</p><p>操作系统</p><p>———————— 物理机器界面 ---> 操作系统运行环境（CPU状态、中断/异常机制）</p></blockquote><hr><h2 id=1-处理器状态模式>1 处理器状态(模式)
<a class=anchor href=#1-%e5%a4%84%e7%90%86%e5%99%a8%e7%8a%b6%e6%80%81%e6%a8%a1%e5%bc%8f>#</a></h2><h3 id=11-中央处理器cpu>1.1 中央处理器(CPU)
<a class=anchor href=#11-%e4%b8%ad%e5%a4%ae%e5%a4%84%e7%90%86%e5%99%a8cpu>#</a></h3><ul><li>处理器由<strong>运算器</strong>、<strong>控制器</strong>、一系列的<strong>寄存器</strong>以及<strong>高速缓存</strong>构成</li><li>两类寄存器:<ul><li><strong>用户可见寄存器</strong>：高级语言编译器通过优化算法分配并使用之，以减少程序访问内存次数</li><li><strong>控制和状态寄存器</strong>：用于控制处理器的操作，通常由操作系统代码使用</li></ul></li></ul><h3 id=12-控制和状态寄存器>1.2 控制和状态寄存器
<a class=anchor href=#12-%e6%8e%a7%e5%88%b6%e5%92%8c%e7%8a%b6%e6%80%81%e5%af%84%e5%ad%98%e5%99%a8>#</a></h3><blockquote><ol><li><em><strong>程序计数器(PC: Program Counter)</strong></em>：记录将要取出的指令的地址</li><li><em><strong>指令寄存器(IR: Instruction Register)</strong></em>：记录最近取出的指令</li><li><em><strong>程序状态字寄存器(PSW: Program Status Word)</strong></em>：记录处理器的运行状态如条件码、
<a href=/zh-cn/docs/note/operating_system_peking/2_env_and_logic/#14-%e5%a4%84%e7%90%86%e5%99%a8%e6%a8%a1%e5%bc%8f%e7%8a%b6%e6%80%81mode>模式</a>、控制位等信息。PSW一般包含以下内容：<ul><li><p>程序基本状态：</p><ul><li>等待/计算：当前处理器状态；</li><li>目态/管态：当前处理器状态；</li><li>条件码：体现当前指令执行结果的各种状态信息（如算术运算产生的正、负、零或溢出等）；</li><li>指令地址：下一条指令的存放地址</li></ul></li><li><p>中断码：保存程序执行时当前发生的中断事件；</p></li><li><p>中断屏蔽位：指出程序执行中，是否要响应出现的中断事件。</p></li></ul></li></ol><p><em>Reference</em>:
<a href=https://www.cnblogs.com/JustBeZero/p/9632781.html>程序状态字</a></p></blockquote><p>控制和状态寄存器的作用：</p><ol><li>用于控制处理器的操作</li><li>在某种<em>特权级别</em>下可以〔被〕访问、修改</li></ol><h3 id=13-操作系统的需求保护>1.3 操作系统的需求——保护
<a class=anchor href=#13-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e9%9c%80%e6%b1%82%e4%bf%9d%e6%8a%a4>#</a></h3><ul><li>从操作系统的特征考虑<ul><li>并发、共享的数据安全</li></ul></li><li>对操作系统提出要求 ——> 实现保护与控制</li><li>需要硬件提供基本运行机制:<ul><li>处理器具有特权级别，能在不同的特权级运行的不同指令集合</li><li>硬件机制可将OS与用户程序隔离</li></ul></li></ul><h3 id=14-处理器模式状态mode>1.4 处理器模式/状态(MODE)
<a class=anchor href=#14-%e5%a4%84%e7%90%86%e5%99%a8%e6%a8%a1%e5%bc%8f%e7%8a%b6%e6%80%81mode>#</a></h3><ul><li>现代处理器通常将CPU状态设计划分为两种、三种或四种<ul><li>操作系统〔至少〕需要两种CPU状态<ul><li><strong>内核态（Kernel Mode）</strong>：运行操作系统程序</li><li><strong>用户态（User Mode）</strong>：运行用户程序</li></ul></li></ul></li><li>在
<a href=/zh-cn/docs/note/operating_system_peking/2_env_and_logic/#12-%e6%8e%a7%e5%88%b6%e5%92%8c%e7%8a%b6%e6%80%81%e5%af%84%e5%ad%98%e5%99%a8>程序状态字寄存器PSW</a>中专门设置一位，根据运行程序对资源和指令的使用权限而设置不同的CPU状态</li></ul><blockquote><p><a href=https://wiki.osdev.org/Program_Status_Word>Program Status Word - OSDev Wiki</a></p><p>例：x86架构中的EFLAGS寄存器中使用2位来保存IO的权限级别（IOPL）</p><p><a href=https://blog.csdn.net/jn1158359135/article/details/7761011>x86—EFLAGS寄存器详解_随心随意随缘的博客-CSDN博客</a></p></blockquote><h3 id=15-特权指令和非特权指令>1.5 特权指令和非特权指令
<a class=anchor href=#15-%e7%89%b9%e6%9d%83%e6%8c%87%e4%bb%a4%e5%92%8c%e9%9d%9e%e7%89%b9%e6%9d%83%e6%8c%87%e4%bb%a4>#</a></h3><ul><li>特权(<em>privilege</em>)指令：只能由操作系统使用、用户程序不能使用的指令</li><li>非特权指令：用户程序可以使用的指令</li></ul><blockquote><p>📖 下列哪些是特权指令? 哪些是非特权指令?</p><p>特权指令：启动I/0 内存清零 修改程序状态字 设置时钟 允许/禁止中断 停机</p><p>非特权指令：控制转移 算术运算 取数指令 访管指令（可以使用户程序从用户态陷入操作系统内核态。）</p></blockquote><h3 id=16-实例x86系列处理器>1.6 实例：x86系列处理器
<a class=anchor href=#16-%e5%ae%9e%e4%be%8bx86%e7%b3%bb%e5%88%97%e5%a4%84%e7%90%86%e5%99%a8>#</a></h3><ul><li><p>x86支持4个处理器特权级别</p><p><strong>特权环</strong>：R0、R1、R2和R3</p><blockquote><p>R0 是希望能运行操作系统的一些关键代码 所以 R0 相当于内核态。
R1是运行设备驱动程序和一些 I/O 处理的历程。
R2是运行一些受保护共享的代码，比如说一些语言编译环境。
R3是给用户程序使用。</p></blockquote><ul><li>从R0到R3，特权能力由高到低</li><li><em>R0相当于内核态；R3相当于用户态</em>；R1和R2则介于两者之间</li><li>不同级别能够运行的指令集合不同</li></ul></li><li><p>目前(?2015?)大多数基于x86处理器的操作系统只使用了R0和R3两个特权级别</p></li></ul><h3 id=17-cpu状态之间的转换>1.7 CPU状态之间的转换
<a class=anchor href=#17-cpu%e7%8a%b6%e6%80%81%e4%b9%8b%e9%97%b4%e7%9a%84%e8%bd%ac%e6%8d%a2>#</a></h3><ul><li>用户态 —> 内核态 ：唯一途径：中断/异常/陷入机制</li><li>内核态 —> 用户态：设置程序状态字
<a href=/zh-cn/docs/note/operating_system_peking/2_env_and_logic/#12-%e6%8e%a7%e5%88%b6%e5%92%8c%e7%8a%b6%e6%80%81%e5%af%84%e5%ad%98%e5%99%a8>PSW</a></li></ul><blockquote><p>📖 访管指令（陷入指令）：</p><p>提供给用户程序的接口，用于调用操作系统的功能（服务）。
如：<code>int</code>， <code>trap</code>，<code>syscall</code>，<code>sysenter</code>/<code>sysexit</code></p></blockquote><h2 id=2-中断与异常机制>2 中断与异常机制
<a class=anchor href=#2-%e4%b8%ad%e6%96%ad%e4%b8%8e%e5%bc%82%e5%b8%b8%e6%9c%ba%e5%88%b6>#</a></h2><p>中断/异常对于操作系统的重要性就好比：汽车的发动机、飞机的引擎。操作系统是由“中断驱动”或者“事件驱动”的。中断与异常机制主要用来：1）及时处理设备发来的中断请求，2）可使OS捕获用户程序提出的服务请求防止用户程序执行过程中的破坏性活动。3）...</p><p>中断与异常可以概括为：1）CPU对系统发生的某个事件作出的一种反应，2）CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序，处理完成后返回断点继续执行被打断的程序。</p><p>中断与异常的特点：</p><ul><li>随机发生</li><li>自动处理— 硬件自动完成这一过程</li><li>可恢复</li></ul><blockquote><p><strong>中断（外中断）</strong>：外部事件，正在运行的程序所不期望发生的</p><ul><li>I/O中断：等待输入、扫描、接收到网络包等等</li><li>时钟中断：CPU时间片结束、定时器到时等等</li><li>硬件故障：电池即将耗尽等等</li></ul><p><strong>异常（内中断）</strong>：由正在运行的指令引发</p><ul><li>系统调用</li><li>页故障/页错误 （缺页异常—文件未读入内存）</li><li>保护性异常（磁盘不可写等等）</li><li>断点指令（程序调试等等）</li><li>其他程序性异常（算术溢出，内存溢出等等）</li></ul></blockquote><table><thead><tr><th>类别</th><th>原因</th><th>异步/同步</th><th>返回行为</th></tr></thead><tbody><tr><td><em>中断 Interrupt</em></td><td><em>来自I/O设备、其他硬件部件</em></td><td><em>异步</em></td><td><em>总是返回到下一条指令</em></td></tr><tr><td>陷入 Trap</td><td>有意安排</td><td>同步</td><td>返回到下一条指令</td></tr><tr><td>故障 Falut</td><td>可恢复的错误</td><td>同步</td><td>返回到当前指令</td></tr><tr><td>终止 Abort</td><td>不可恢复的错误</td><td>同步</td><td>不会返回</td></tr></tbody></table><h3 id=21-为什么引入中断与异常>2.1 为什么引入中断与异常
<a class=anchor href=#21-%e4%b8%ba%e4%bb%80%e4%b9%88%e5%bc%95%e5%85%a5%e4%b8%ad%e6%96%ad%e4%b8%8e%e5%bc%82%e5%b8%b8>#</a></h3><ul><li><p>中断的引入：为了支持CPU和设备之间的并行操作。</p><p>当CPU启动设备进行输入/输出后，设备便可以独立工作，CPU转去处理与此次输入/输出不相关的事情；当设备完成输入/输出后，通过向CPU发中断报此次输入/输出的结果，让CPU决定如何处理以后的事情。</p></li><li><p>异常的引入：表示CPU执行指令时本身出现的问题。</p><p>如算术溢出、除零、取数时的奇偶错，访存地址时越界或执行了“陷入指令”等，这时硬件改变了CPU当前的执行流程，转到相应的错误处理程序或异常处理程序或执行系统调用。</p></li></ul><h3 id=22-原理>2.2 原理
<a class=anchor href=#22-%e5%8e%9f%e7%90%86>#</a></h3><ul><li><p>中断/异常机制是现代计算机系统的核心机制之一。</p><p>硬件和软件相互配合而使计算机系统得以充分发挥能力。</p></li><li><p>硬件该做什么事?--中断/异常响应</p><p>捕获中断源发出的中断/异常请求，以一定方式响应，将处理器控制权交给特定的处理程序。</p></li><li><p>软件要做什么事?--中断/异常处理程序</p><p>识别中断/异常类型并完成相应的处理。</p></li></ul><h4 id=221-中断响应>2.2.1 中断响应
<a class=anchor href=#221-%e4%b8%ad%e6%96%ad%e5%93%8d%e5%ba%94>#</a></h4><p>发现中断，接收中断的过程。由中断硬件部件完成。</p><p>处理控制器部件中设有<strong>中断寄存器</strong>。</p><blockquote><p><strong>处理控制器</strong>是计算机系统中的一个重要组成部分，它由硬件和软件两部分组成。硬件部分包括处理器、寄存器、高速缓存等，软件部分包括操作系统和应用程序。处理控制器的主要功能是处理和控制计算机系统中的数据流和输入输出，以及解决性能、安全、健壮等问题。在计算机系统中，处理控制器是负责管理和协调各个硬件设备和软件应用程序之间通信和数据传输的关键部件。它可以通过操作系统运行机制（系统调用）和物理机器界面来与操作系统和硬件进行交互。</p><p><strong>中断寄存器</strong>是计算机中一种特殊的寄存器，用于存储中断处理程序的返回地址和处理状态。</p><p>当计算机遇到中断事件时，处理器会自动将当前程序的执行状态保存到堆栈中，并将处理器的控制权转移给中断处理程序。当中断处理程序完成后，处理器会从堆栈中恢复原程序的执行状态，并将控制权返回给原程序继续执行。</p><p>在x86架构中，中断寄存器被称为<strong>EFLAGS寄存器</strong>，它包含了处理器的一些状态信息，如进位标志、零标志和符号标志等。此外，EFLAGS寄存器还包含了<strong>中断标志位</strong>(IF)。当IF标志位被设置为<code>1</code>时，处理器允许中断事件的发生，否则处理器会忽略所有中断事件。这个标志位可以被操作系统用来控制中断的开关。</p><p>总之，中断寄存器是计算机中非常重要的一个硬件寄存器，它是中断处理机制的核心。中断处理机制可以使计算机在运行过程中能够及时响应外部事件，提高计算机的效率和稳定性。</p></blockquote><p><img src=/img/course/os/2/interrupt-exception.png alt=interrupt></p><center style=font-size:.8rem;color:grey;font-style:italic>中断响应的简单过程</center><h4 id=222-中断向量表>2.2.2 中断向量表
<a class=anchor href=#222-%e4%b8%ad%e6%96%ad%e5%90%91%e9%87%8f%e8%a1%a8>#</a></h4><ul><li><p>中断向量</p><p>一个<strong>内存单元</strong>，存放
<a href=/zh-cn/docs/note/operating_system_peking/2_env_and_logic/#223-%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f>中断处理程序</a>入口地址和程序运行时所需的处理机状态字。</p></li></ul><p><img src=/img/course/os/2/interrupt-axios.png alt=interrupt-vetor></p><center style=font-size:.8rem;color:grey;font-style:italic>中断向量</center><p>执行流程：按中断号/异常类型的不同，通过中断向量表转移控制权给中断处理程序。</p><blockquote><p>📖 Linux中的中断向量表</p><table><thead><tr><th>向量范围</th><th>用途</th></tr></thead><tbody><tr><td>0~19</td><td>不可屏蔽中断和异常</td></tr><tr><td>0</td><td>除0</td></tr><tr><td>1</td><td>单步调试</td></tr><tr><td>4</td><td>算术溢出</td></tr><tr><td>6</td><td>非法操作数</td></tr><tr><td>12</td><td>栈异常</td></tr><tr><td>13</td><td>保护性错误</td></tr><tr><td>14</td><td>缺页异常</td></tr><tr><td>20~31</td><td>Intel保留</td></tr><tr><td>32~127</td><td>外部中断(IRQ)</td></tr><tr><td>128(0x80)</td><td>用于系统调用的可编程异常</td></tr><tr><td>129~238</td><td>外部中断</td></tr><tr><td>239</td><td>本地APIC时钟中断</td></tr><tr><td>240</td><td>本地APIC高温中断</td></tr><tr><td>241~250</td><td>Linux保留</td></tr><tr><td>251~253</td><td>处理器间中断</td></tr><tr><td>254</td><td>本地APIC错误中断</td></tr><tr><td>255</td><td>本地APIC伪中断</td></tr></tbody></table></blockquote><h4 id=223-中断处理程序>2.2.3 中断处理程序
<a class=anchor href=#223-%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f>#</a></h4><p>设计操作系统时，为每一类中断/异常事件编好相应的处理程序，并设置好
<a href=/zh-cn/docs/note/operating_system_peking/2_env_and_logic/#222-%e4%b8%ad%e6%96%ad%e5%90%91%e9%87%8f%e8%a1%a8>中断向量表</a>。</p><p>系统运行时若响应中断，中断硬件部件将CPU控制权转给中断处理程序:</p><ul><li>保存相关寄存器信息</li><li>分析中断/异常的具体原因</li><li>执行对应的处理功能</li><li>恢复现场，返回被事件打断的程序</li></ul><h4 id=224-中断异常处理流程>2.2.4 中断/异常处理流程
<a class=anchor href=#224-%e4%b8%ad%e6%96%ad%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b>#</a></h4><p><img src=/img/course/os/2/interrupt-flow.png alt=interrupt-handle-flow></p><center style=font-size:.8rem;color:grey;font-style:italic>中断处理流程</center><p>中断/异常机制小结：以设备输入输出中断为例：</p><ul><li>打印机给CPU发中断信号</li><li>CPU处理完当前指令后检测到中断，判断出中断来源并向相关设备发确认信号</li><li>CPU开始为软件处理中断做准备:<ul><li>处理器状态被切换到<strong>内核态</strong></li><li>在系统栈中保存被中断程序的重要上下文环境，主要是<strong>程序计数器PC</strong>、<strong>程序状态字PSW</strong></li></ul></li><li>CPU根据中断码查中断向量表，获得与该中断相关的处理程序的入口地址，并将PC设置成该地址，新的指令周期开始时，CPU控制转移到中断处理程序</li><li>中断处理程序开始工作<ul><li>在系统栈中保存现场信息</li><li>检查I/0设备的状态信息，操纵I/O设备或者在设备和内存之间传送数据等等<blockquote><p>📖 中断处理程序的处理，通常分为两类:</p><ul><li>I/O操作正常结束<ul><li>若有程序正等待此次I/O的结果，则应将其唤醒</li><li>若要继续I/O操作，需要准备好数据重新启动I/O</li></ul></li><li>I/O操作出现错误<ul><li>需要重新执行失败的I/O操作</li><li>重试次数有上限，达到时系统将判定硬件故障</li></ul></li></ul></blockquote></li></ul></li><li>中断处理结束时，CPU检测到中断返回指令，从系统栈中恢复被中断程序的上下文环境，CPU状态恢复成原来的状态，PSW和PC恢复成中断前的值，CPU开始一个新的指令周期</li></ul><h3 id=23-x86中的中断与异常机制>2.3 x86中的中断与异常机制
<a class=anchor href=#23-x86%e4%b8%ad%e7%9a%84%e4%b8%ad%e6%96%ad%e4%b8%8e%e5%bc%82%e5%b8%b8%e6%9c%ba%e5%88%b6>#</a></h3><ul><li><p>中断</p><p>由硬件信号引发的，分为可屏蔽和不可屏蔽中断</p></li><li><p>异常</p><ul><li>由指令执行引发的，比如除零异常</li><li>80x86处理器发布了大约20种不同的异常</li><li>对于某些异常，CPU会在执行异常处理程序之前产生硬件出错码，并压入内核态堆栈</li></ul></li><li><p>系统调用</p><p>异常的一种，用户态到内核态的唯一入口</p></li><li><p>中断控制器(PIC或APIC)</p><p>负责将硬件的中断信号转换为中断向量，并引发CPU中断</p></li><li><p>实模式：中断向量表(Interrupt Vector)</p><ul><li>存放中断服务程序的入口地址<ul><li>入口地址 = 段地址左移4位 + 偏移地址</li><li>不支持CPU运行状态切换</li><li>中断处理与一般的过程调用相似</li></ul></li></ul></li><li><p>保护模式：中断描述符表(IDTInterrupt Descriptor Table)</p><p>采用门(gate)描述符数据结构表示中断向量</p></li></ul><h4 id=231-中断门描述符表>2.3.1 中断门描述符表
<a class=anchor href=#231-%e4%b8%ad%e6%96%ad%e9%97%a8%e6%8f%8f%e8%bf%b0%e7%ac%a6%e8%a1%a8>#</a></h4><p>四种类型门描述符：</p><ul><li><del>任务门(Task Gate)</del></li><li>中断门(Interrupt Gate)
给出段选择符(Segment Selector)、中断/异常程序的段内偏移量(Offset)
通过中断门后系统会自动禁止中断（通过设置寄存器的中断标识位IF完成）</li><li>陷阱门(Trap Gate)
与中断门类似，但通过陷阱门后系统不会自动禁止中断</li><li><del>调用门（Call Gate）</del></li></ul><h4 id=232-中断异常的硬件处理过程>2.3.2 中断/异常的硬件处理过程
<a class=anchor href=#232-%e4%b8%ad%e6%96%ad%e5%bc%82%e5%b8%b8%e7%9a%84%e7%a1%ac%e4%bb%b6%e5%a4%84%e7%90%86%e8%bf%87%e7%a8%8b>#</a></h4><ol><li><p>确定与中断或异常关联的向量<code>i</code></p></li><li><p>通过IDTR寄存器找到IDT表，获得中断描述符(表中的第i项)</p></li><li><p>从GDTR寄存器获得GDT的地址；结合中断描述符中的段选择符，在GDT表获取对应的段描述符；从该段描述符中得到中断或异常处理程序所在的段基址</p><p>IDT段选择符→ GDT段描述符→ GDT段基址</p></li><li><p>特权级检查（2、3步中包含特权级检查）</p></li><li><p>检查是否发生了特权级的变化，如果是，则进行堆栈切换(必须使用与新的特权级相关的栈)</p></li><li><p>硬件压栈，保存上下文环境；如果异常产生了硬件出错码，也将它保存在栈中</p></li><li><p>如果是中断门，清IF位（中断标识位），陷进门不必如此做</p></li><li><p>通过中断描述符中的段内偏移量和段描述符中的基地址，找到中断/异常处理程序的入口地址，执行其第一条指令</p></li></ol><p><img src=/img/course/os/2/interrupt-hardware-handler.png alt=中断异常硬件处理流程></p><center style=font-size:.8rem;color:grey;font-style:italic>x86的中断/异常的硬件处理过程</center><h2 id=3-系统调用机制>3 系统调用机制
<a class=anchor href=#3-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e6%9c%ba%e5%88%b6>#</a></h2><blockquote><p>应用程序通过访管指令(或中断/异常机制)来实现系统调用。</p></blockquote><h3 id=31-系统调用的概念>3.1 系统调用的概念
<a class=anchor href=#31-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e7%9a%84%e6%a6%82%e5%bf%b5>#</a></h3><p>用户在编程时可以调用的操作系统功能。</p><ul><li>系统调用（System Call）是操作系统提供给编程人员的唯一接口</li><li><strong>使CPU状态从用户态陷入到内核态</strong></li><li>每个操作系统都提供了几百种系统调用（进程控制、进程通信、文件使用、目录操作、设备管理、信息维护等等）</li></ul><center style=font-size:.8rem;font-style:italic;color:gray><img style=width:50% alt=系统调用 src=/img/course/os/2/system-invoke.png><p>系统调用与库函数、API、内核函数的区别与联系</center><p>用户程序往往通过调用函数来进行系统调用，进入内核。</p><h3 id=32-系统调用的设计>3.2 系统调用的设计
<a class=anchor href=#32-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e7%9a%84%e8%ae%be%e8%ae%a1>#</a></h3><h4 id=321-系统调用的要素>3.2.1 系统调用的要素
<a class=anchor href=#321-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e7%9a%84%e8%a6%81%e7%b4%a0>#</a></h4><ol><li><p>中断/异常机制</p><p>支持系统调用服务的实现。</p></li><li><p>选择一条特殊指令：陷入指令（亦称访管指令）</p><p>引发异常，完成用户态到内核态的切换 。</p><blockquote><p>所有的系统调用都使用这条指令。</p></blockquote></li><li><p>系统调用号和
<a href=/zh-cn/docs/note/operating_system_peking/2_env_and_logic/#322-%e5%8f%82%e6%95%b0%e7%9a%84%e4%bc%a0%e9%80%92>参数</a><br>每个系统调用都事先给定一个编号（功能号） 。</p><blockquote><p>通过编号（功能号）来区分不同的系统调用</p></blockquote></li><li><p>系统调用表</p><p>存放系统调用服务例程的入口地址。</p></li></ol><h4 id=322-参数的传递>3.2.2 参数的传递
<a class=anchor href=#322-%e5%8f%82%e6%95%b0%e7%9a%84%e4%bc%a0%e9%80%92>#</a></h4><blockquote><p>❓ 怎样实现用户程序的参数传递给内核？</p></blockquote><p>常用的3种实现方法：</p><ul><li>由陷入指令自带参数：<ul><li>陷入指令的长度有限，且还要携带系统调用功能号，只能自带有限的参数。</li></ul></li><li><strong>通过通用寄存器传递参数（常用）</strong>：<ul><li>这些寄存器是操作系统和用户程序都能访问的，但寄存器的个数会限制传递参数的数量。</li></ul></li><li>在内存中开辟专用堆栈区来传递参数</li></ul><h4 id=323-系统调用示例分析>3.2.3 系统调用示例分析
<a class=anchor href=#323-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e7%a4%ba%e4%be%8b%e5%88%86%e6%9e%90>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=ln> 1</span><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=cp></span><span class=kt>int</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>	<span class=kt>char</span> <span class=n>string</span><span class=p>[</span><span class=mi>5</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=sc>&#39;H&#39;</span><span class=p>,</span> <span class=sc>&#39;e&#39;</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>,</span> <span class=sc>&#39;l&#39;</span><span class=p>,</span> <span class=sc>&#39;o&#39;</span><span class=p>,</span> <span class=sc>&#39;!&#39;</span><span class=p>,</span> <span class=sc>&#39;\n&#39;</span><span class=p>};</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>	<span class=nf>write</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>string</span><span class=p>,</span> <span class=mi>7</span><span class=p>);</span>    <span class=c1>// 系统调用1
</span></span></span><span class=line><span class=ln> 5</span><span class=cl><span class=c1></span>	<span class=k>return</span> <span class=mi>0</span><span class=err>；</span>              <span class=c1>// 系统调用2
</span></span></span><span class=line><span class=ln> 6</span><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>
</span></span><span class=line><span class=ln> 8</span><span class=cl><span class=c1>// 汇编语言编译后的代码（示例）
</span></span></span><span class=line><span class=ln> 9</span><span class=cl><span class=c1></span><span class=p>.</span><span class=n>section</span> <span class=p>.</span><span class=n>data</span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=nl>output</span><span class=p>:</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>	<span class=n>ascii</span> <span class=s>&#34;Hello!</span><span class=se>\n</span><span class=s>&#34;</span>
</span></span><span class=line><span class=ln>12</span><span class=cl><span class=nl>output_end</span><span class=p>:</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>	<span class=p>.</span><span class=n>equ</span> <span class=n>len</span><span class=p>,</span> <span class=n>output_end</span><span class=o>-</span><span class=n>output</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>
</span></span><span class=line><span class=ln>15</span><span class=cl><span class=p>.</span><span class=n>section</span> <span class=p>.</span><span class=n>text</span>
</span></span><span class=line><span class=ln>16</span><span class=cl><span class=p>.</span><span class=n>globl_start</span>
</span></span><span class=line><span class=ln>17</span><span class=cl><span class=nl>_start</span><span class=p>:</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>	<span class=n>movl</span> <span class=err>$</span><span class=mi>4</span><span class=p>,</span> <span class=o>%</span><span class=n>eax</span>         <span class=err>#</span> <span class=n>eax寄存器存放系统调用编号</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>	<span class=n>movl</span> <span class=err>$</span><span class=mi>1</span><span class=p>,</span> <span class=o>%</span><span class=n>ebx</span>         <span class=err>#</span> <span class=err>通用寄存器传递参数</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>	<span class=n>movl</span> <span class=err>$</span><span class=n>output</span><span class=p>,</span> <span class=o>%</span><span class=n>ecx</span>    <span class=err>#</span> <span class=err>参数</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>	<span class=n>movl</span> <span class=err>$</span><span class=n>len</span><span class=p>,</span><span class=o>%</span><span class=n>edx</span>        <span class=err>#</span> <span class=err>参数</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>	<span class=kt>int</span> <span class=err>$</span><span class=mh>0x80</span>             <span class=err>#</span> <span class=err>陷入指令，引发一次系统调用</span>
</span></span><span class=line><span class=ln>23</span><span class=cl><span class=nl>end</span><span class=p>:</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>	<span class=n>movl</span> <span class=err>$</span><span class=mi>1</span><span class=p>,</span> <span class=o>%</span><span class=n>eax</span>         <span class=err>#</span> <span class=err>以下是</span><span class=k>return</span> <span class=mi>0</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>	<span class=n>movl</span> <span class=err>$</span><span class=mi>4</span><span class=p>,</span> <span class=o>%</span><span class=n>ebx</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>	<span class=kt>int</span> <span class=err>$</span><span class=mh>0x80</span>
</span></span></code></pre></div><h3 id=33-系统调用的执行过程>3.3 系统调用的执行过程
<a class=anchor href=#33-%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b>#</a></h3><p>当CPU执行到特殊的陷入指令时：</p><ol><li>中断/异常机制<ul><li>硬件保护现场，通过查询中断向量表（描述符表），把CPU的控制权转交给中断处理程序，或者叫系统调用总入口程序。</li></ul></li><li>系统调用总入口程序<ul><li>保存现场，将系统调用参数保存在内核的堆栈中，查找系统调用表，把控制权交给对应的系统调用的处理程序或者内核函数</li></ul></li><li>执行系统调用例程</li><li>恢复现场，返回用户程序</li></ol><h2 id=4-基于x86的linux系统调用机制简介>4 基于x86的Linux系统调用机制简介
<a class=anchor href=#4-%e5%9f%ba%e4%ba%8ex86%e7%9a%84linux%e7%b3%bb%e7%bb%9f%e8%b0%83%e7%94%a8%e6%9c%ba%e5%88%b6%e7%ae%80%e4%bb%8b>#</a></h2><ul><li>陷入指令选择128号<ul><li><code>int $0x80</code></li></ul></li><li>门描述符<ul><li>系统初始化时：对IDT表中的128号门初始化</li><li>门描述符的2、3两个字节：内核代码段选择符
0、1、6、7四个字节：偏移量（指向system_call()）</li><li>门类型：<code>15</code> 陷井门</li><li>DPL：<code>3</code> 与用户级别相同，允许用户使用该门描述符</li></ul></li></ul><blockquote><p>📖 系统调用号示例</p><table><thead><tr><th>#define_NR_exit</th><th>1</th></tr></thead><tbody><tr><td>#define_NR_fork</td><td>2</td></tr><tr><td>#define_NR_read</td><td>3</td></tr><tr><td>#define_NR_write</td><td>4</td></tr><tr><td>#define_NR_open</td><td>5</td></tr><tr><td>#define_NR_close</td><td>6</td></tr><tr><td>#define_NR_waitpid</td><td>7</td></tr><tr><td>#define_NR_create</td><td>8</td></tr><tr><td>#define_NR_link</td><td>9</td></tr><tr><td>#define_NR_unlink</td><td>10</td></tr><tr><td>#define_NR_execve</td><td>11</td></tr><tr><td>#define_NR_chdir</td><td>12</td></tr><tr><td>#define_NR_time</td><td>13</td></tr></tbody></table></blockquote><p>系统执行<code>INT $0x80</code>指令后：</p><ul><li>由于特权级的改变，要切换栈
用户栈→内核栈
CPU从任务状态段TSS中装入新的栈指针(SS:ESP)，指向内核栈。</li><li>用户栈的信息(SS:ESP)、EFLAGS、用户态CS、EIP寄存器的内容压栈(返回用)</li><li>将EFLAGS压栈后，复位TF，IF位保持不变</li><li>用128在IDT中找到该门描述符，从中找出段选择符装入代码段寄存器CS</li><li>代码段描述符中的基地址+陷阱门描述符中的偏移量 →定位 system_call()的入口地址</li></ul><p><img src=/img/course/os/2/linux-system-invoke.png alt=Linux系统调用执行流程></p><center style=font-size:.8rem;font-style:italic;color:grey>x86的Linux系统调用机制</center><ol><li>用户态下调用C库的库函数，如<code>write()</code></li><li>封装后的<code>write()</code>先做好参数传递工作，然后使用<code>int 0x80</code>产生一次异常</li><li>CPU通过<code>0x80</code>号在IDT中找到对应的服务例程<code>system_call()</code>，调用之<ol><li>陷入内核态</li><li>压栈</li><li>查询系统调用表，调用内核函数</li></ol></li><li>执行完成后，通过<code>ret_from_sys_call</code>返回用户例程</li></ol><p><img src=/img/course/os/2/linux-system-invoke-stack.png alt=中断发生后linux硬件底层的压栈顺序></p><center style=font-size:.8rem;font-style:italic;color:grey>中断发生后linux硬件底层的压栈顺序</center><p>中断发生后，OS底层的工作步骤：</p><ol><li>硬件压栈:程序计数器等</li><li>硬件从中断向量装入新的程序计数器等</li><li>汇编语言过程保存寄存器值</li><li>汇编语言过程设置新的堆栈</li><li>C语言中断服务程序运行(例:读并缓冲输入)</li><li>进程调度程序决定下一个将运行的进程</li><li>C语言过程返回至汇编代码</li><li>汇编语言过程开始运行新的 当前进程</li></ol><h2 id=5-本章重点>5 本章重点
<a class=anchor href=#5-%e6%9c%ac%e7%ab%a0%e9%87%8d%e7%82%b9>#</a></h2><ul><li>理解计算机系统的保护机制<ul><li>掌握处理器状态</li><li>掌握特权指令与非特权指令</li></ul></li><li>掌握中断/异常机制<ul><li>掌握中断/异常的基本概念</li><li>理解中断/异常机制的工作原理</li></ul></li><li>掌握系统调用机制<ul><li>掌握系统调用设计原理</li><li>掌握系统调用执行过程</li></ul></li><li>重点阅读教材<ul><li>第1章相关内容:1.3、1.6</li><li>第2章第52页图2-5及说明该图思路的段落</li></ul></li><li>重点概念<ul><li><a href=/zh-cn/docs/note/operating_system_peking/2_env_and_logic/#17-cpu%e7%8a%b6%e6%80%81%e4%b9%8b%e9%97%b4%e7%9a%84%e8%bd%ac%e6%8d%a2>CPU状态</a></li><li>内核态/用户态</li><li><a href=/zh-cn/docs/note/operating_system_peking/2_env_and_logic/#15-%e7%89%b9%e6%9d%83%e6%8c%87%e4%bb%a4%e5%92%8c%e9%9d%9e%e7%89%b9%e6%9d%83%e6%8c%87%e4%bb%a4>特权指令/非特权指令</a></li><li>中断异常</li><li>中断响应</li><li>中断向量</li><li><a href=/zh-cn/docs/note/operating_system_peking/2_env_and_logic/#223-%e4%b8%ad%e6%96%ad%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f>中断处理程序</a></li><li>系统调用</li><li>陷入指令</li><li>系统调用号</li><li>系统调用表</li></ul></li></ul></article><div class=next-prev><hr><div class="page-navi flex" id=pagenavi><div class=pre-page>←
<a href=https://wangy325.github.io/zh-cn/docs/note/operating_system_peking/1_intro/>引论</a></div><div class=next-page><a href=https://wangy325.github.io/zh-cn/docs/note/operating_system_peking/3_processes_and_threads/>进程和线程模型</a> →</div></div></div><section class=related><div class=rel-title>相似文章</div><div class=rel-items><a href=/zh-cn/docs/note/operating_system_peking/1_intro/ class=related__link><div>引论</div></a></div><hr></section><div class=book-comments><div class=giscus-thread></div><script src=https://giscus.app/client.js data-repo=wangy325/wangy325.github.io data-repo-id=R_kgDOHhhDZg data-category=Announcements data-category-id=DIC_kwDOHhhDZs4ChbMn data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=noborder_light data-loading=lazy data-lang=zh-CN crossorigin=anonymous async></script></div><div class=copyright><hr class=cline><p>Notes and Memos by wangy325
<a href=https://creativecommons.org/licenses/by/4.0/deed.en title="Creative Commons Attribution">&copy; CC BY 4.0</a></p><p>2019-2025. Powered by
<a href=https://github.com/alex-shpak/hugo-book>Hugo Book</a>
Presented by Github.</p></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><div id=toc-new><ul class=nav><li class=nav-item><a id=t1处理器状态模式 href=javascript:void(0) onclick='return scrolly("1-处理器状态模式"),!1'>1 处理器状态(模式)</a><ul class=nav><li class=nav-item><a id=t11中央处理器CPU href=javascript:void(0) onclick='return scrolly("11-中央处理器cpu"),!1'>1.1 中央处理器(CPU)</a></li><li class=nav-item><a id=t12控制和状态寄存器 href=javascript:void(0) onclick='return scrolly("12-控制和状态寄存器"),!1'>1.2 控制和状态寄存器</a></li><li class=nav-item><a id=t13操作系统的需求——保护 href=javascript:void(0) onclick='return scrolly("13-操作系统的需求保护"),!1'>1.3 操作系统的需求——保护</a></li><li class=nav-item><a id=t14处理器模式状态MODE href=javascript:void(0) onclick='return scrolly("14-处理器模式状态mode"),!1'>1.4 处理器模式/状态(MODE)</a></li><li class=nav-item><a id=t15特权指令和非特权指令 href=javascript:void(0) onclick='return scrolly("15-特权指令和非特权指令"),!1'>1.5 特权指令和非特权指令</a></li><li class=nav-item><a id=t16实例：x86系列处理器 href=javascript:void(0) onclick='return scrolly("16-实例：x86系列处理器"),!1'>1.6 实例：x86系列处理器</a></li><li class=nav-item><a id=t17CPU状态之间的转换 href=javascript:void(0) onclick='return scrolly("17-cpu状态之间的转换"),!1'>1.7 CPU状态之间的转换</a></li></ul></li><li class=nav-item><a id=t2中断与异常机制 href=javascript:void(0) onclick='return scrolly("2-中断与异常机制"),!1'>2 中断与异常机制</a><ul class=nav><li class=nav-item><a id=t21为什么引入中断与异常 href=javascript:void(0) onclick='return scrolly("21-为什么引入中断与异常"),!1'>2.1 为什么引入中断与异常</a></li><li class=nav-item><a id=t22原理 href=javascript:void(0) onclick='return scrolly("22-原理"),!1'>2.2 原理</a><ul class=nav><li class=nav-item><a id=t221中断响应 href=javascript:void(0) onclick='return scrolly("221-中断响应"),!1'>2.2.1 中断响应</a></li><li class=nav-item><a id=t222中断向量表 href=javascript:void(0) onclick='return scrolly("222-中断向量表"),!1'>2.2.2 中断向量表</a></li><li class=nav-item><a id=t223中断处理程序 href=javascript:void(0) onclick='return scrolly("223-中断处理程序"),!1'>2.2.3 中断处理程序</a></li><li class=nav-item><a id=t224中断异常处理流程 href=javascript:void(0) onclick='return scrolly("224-中断异常处理流程"),!1'>2.2.4 中断/异常处理流程</a></li></ul></li><li class=nav-item><a id=t23x86中的中断与异常机制 href=javascript:void(0) onclick='return scrolly("23-x86中的中断与异常机制"),!1'>2.3 x86中的中断与异常机制</a><ul class=nav><li class=nav-item><a id=t231中断门描述符表 href=javascript:void(0) onclick='return scrolly("231-中断门描述符表"),!1'>2.3.1 中断门描述符表</a></li><li class=nav-item><a id=t232中断异常的硬件处理过程 href=javascript:void(0) onclick='return scrolly("232-中断异常的硬件处理过程"),!1'>2.3.2 中断/异常的硬件处理过程</a></li></ul></li></ul></li><li class=nav-item><a id=t3系统调用机制 href=javascript:void(0) onclick='return scrolly("3-系统调用机制"),!1'>3 系统调用机制</a><ul class=nav><li class=nav-item><a id=t31系统调用的概念 href=javascript:void(0) onclick='return scrolly("31-系统调用的概念"),!1'>3.1 系统调用的概念</a></li><li class=nav-item><a id=t32系统调用的设计 href=javascript:void(0) onclick='return scrolly("32-系统调用的设计"),!1'>3.2 系统调用的设计</a><ul class=nav><li class=nav-item><a id=t321系统调用的要素 href=javascript:void(0) onclick='return scrolly("321-系统调用的要素"),!1'>3.2.1 系统调用的要素</a></li><li class=nav-item><a id=t322参数的传递 href=javascript:void(0) onclick='return scrolly("322-参数的传递"),!1'>3.2.2 参数的传递</a></li><li class=nav-item><a id=t323系统调用示例分析 href=javascript:void(0) onclick='return scrolly("323-系统调用示例分析"),!1'>3.2.3 系统调用示例分析</a></li></ul></li><li class=nav-item><a id=t33系统调用的执行过程 href=javascript:void(0) onclick='return scrolly("33-系统调用的执行过程"),!1'>3.3 系统调用的执行过程</a></li></ul></li><li class=nav-item><a id=t4基于x86的Linux系统调用机制简介 href=javascript:void(0) onclick='return scrolly("4-基于x86的linux系统调用机制简介"),!1'>4 基于x86的Linux系统调用机制简介</a></li><li class=nav-item><a id=t5本章重点 href=javascript:void(0) onclick='return scrolly("5-本章重点"),!1'>5 本章重点</a></li></ul></div><script>function scrolly(e){const t=40;var n=document.getElementById(e).offsetTop;window.scrollTo({top:n+t,behaviour:"smooth"})}</script></div></aside></main><div class=back-to-top><div id=back-to-top><img src=/svg/chevrons-up.svg srcset="/svg/chevrons-up.svg 500w" onclick=topFunction() class=black>
<img title=回到顶部 src=/svg/chevrons-up-blue.svg srcset="/svg/chevrons-up-blue.svg 500w" onclick=topFunction() class=blue></div><script>let mybutton=document.getElementById("back-to-top");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>500||document.documentElement.scrollTop>500?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){window.scrollTo({top:0,behavior:"smooth"})}</script></div><script src=/js/scroll-listening.js></script></body></html>