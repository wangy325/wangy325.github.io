<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>线程池 on xf&amp;pl</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/</link><description>Recent content in 线程池 on xf&amp;pl</description><generator>Hugo</generator><language>zh-CN</language><atom:link href="https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/index.xml" rel="self" type="application/rss+xml"/><item><title>Executors与Executor框架</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/7_1_Executors_and_ExecutorService/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/7_1_Executors_and_ExecutorService/</guid><description>&lt;p>&lt;code>Executors&lt;/code>可以称作执行器。Java并发系列的文章到目前为止，虽然没有特别说明，但是使用执行器(Executor(s))的次数已经难以计数了，&lt;code>Executors&lt;/code>提供了一些非常方便的静态方法，可以根据需要创建不同的&lt;code>ExecutorService&lt;/code>，然后调用其&lt;code>execute(Runnable)&lt;/code>或&lt;code>submit(Callable&amp;lt;T&amp;gt;)&lt;/code>方法。&lt;/p>
&lt;p>在并发条件下，执行器还有一个非常明显的优势，它使用&lt;strong>线程池&lt;/strong>管理线程，减少了系统创建和销毁线程的开销。在一般的Java并发过程中，也建议使用执行器完成任务而非显式地创建线程。&lt;/p>
&lt;p>本文将从执行器开始，阐述Java中的线程池。&lt;/p></description></item><item><title>ThreadPoolExecutor(一)</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/7_2_ThreadPoolExecutor1/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/7_2_ThreadPoolExecutor1/</guid><description>&lt;p>
 &lt;a href="https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/7_1_Executors_and_ExecutorService/">前文&lt;/a>就已经提过，&lt;code>Executors&lt;/code>执行器创建的线程池包括不同实现，可以应对不同的场景，那么Java中包含哪些实现呢？&lt;/p>
&lt;p>本问就来讨论这些实现。&lt;/p></description></item><item><title>ThreadPoolExecutor(二)</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/7_3_ThreadPoolExecutor2/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/7_3_ThreadPoolExecutor2/</guid><description>&lt;p>
 &lt;a href="https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/7_2_ThreadPoolExecutor1/#threadpoolexecutor">前文&lt;/a>说过，&lt;code>ThreadPoolExecutor&lt;/code>实例代表了Java线程池，前面我们介绍了&lt;code>ThreadPoolExecutor&lt;/code>的构造器和几个核心概念，在本节中，我们着重介绍线程池的执行过程以及线程池的关闭。&lt;/p></description></item><item><title>CompletionService</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/7_4_CompletionService/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/7_4_CompletionService/</guid><description>在提交单个任务时，使用submit()或者execute()方法或许能够满足要求，但如果需要控制多个任务时，依次提交的操作看起来“有些繁琐”，此时我们可以使用ExecutorService提供的invokeAny/invokeAll方法，在介绍CompletionService接口时，我们不妨先看看这两个方法。
之前介绍AbstractExecutorService时提到，这两个方法是在这个抽象类中实现的，其中前者在获取到一个任务的返回值时便取消其他（未执行或正在执行的任务）任务，而后者需要等待所有的任务执行完成之后才能对任务的返回进行处理，接下来我们分别来看：
invokeAll会阻塞等待所有的任务执行完成。
1public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks) 2 throws InterruptedException { 3 if (tasks == null) 4 throw new NullPointerException(); 5 ArrayList&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; futures = new ArrayList&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;(tasks.size()); 6 boolean done = false; 7 try { 8 for (Callable&amp;lt;T&amp;gt; t : tasks) { 9 RunnableFuture&amp;lt;T&amp;gt; f = newTaskFor(t); 10 futures.add(f); 11 execute(f); 12 } 13 // 有序迭代 14 for (int i = 0, size = futures.size(); i &amp;lt; size; i++) { 15 Future&amp;lt;T&amp;gt; f = futures.</description></item><item><title>ScheduledExecutorService(一)</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/8_1_ScheduledExecutorService1/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/8_1_ScheduledExecutorService1/</guid><description>&lt;p>除了&lt;code>ThreadPoolExecutor&lt;/code>之外，Java执行器（Executor）框架还提供了可以在指定延迟之后执行一次或周期执行任务的接口&lt;code>ScheduledExecutorService&lt;/code>，较
 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Timer.html">java.util.Timer&lt;/a>而言，它是更好的选择。&lt;/p>
&lt;p>与
 &lt;a href="https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/7_2_ThreadPoolExecutor1/#threadpoolexecutor">线程池&lt;/a>不同的是，用于计划执行的&lt;code>ScheduledThreadPoolExecutor&lt;/code>使用&lt;code>ScheduledFutureTask&lt;/code>作为任务，使用&lt;code>DelayedWorkQueue&lt;/code>作为任务队列，以实现计划（周期）执行的目的。&lt;/p></description></item><item><title>ScheduledExecutorService(二)</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/8_2_ScheduledExecutorService2/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0800</pubDate><guid>https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/8_2_ScheduledExecutorService2/</guid><description>&lt;h2 id="引例">
 引例
 &lt;a class="anchor" href="#%e5%bc%95%e4%be%8b">#&lt;/a>
&lt;/h2>
&lt;p>
 &lt;a href="https://wangy325.github.io/zh-cn/docs/java/concurrency/pools/8_1_ScheduledExecutorService1/#scheduledfuturetask">前文&lt;/a>介绍了&lt;code>ScheduledFutureTask&lt;/code>和&lt;code>DeleyedWorkQueue&lt;/code>这么多，都是为了更好地理解任务执行的流程，在这之前，我们不妨先看如下示例：&lt;/p></description></item></channel></rss>