<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>并发组件 on Endless River</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/components/</link><description>Recent content in 并发组件 on Endless River</description><generator>Hugo</generator><language>zh-CN</language><atom:link href="https://wangy325.github.io/zh-cn/docs/java/concurrency/components/index.xml" rel="self" type="application/rss+xml"/><item><title>CountDownLatch</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/components/9_1_countdownlatch/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh-cn/docs/java/concurrency/components/9_1_countdownlatch/</guid><description>&lt;h2 id="countdownlatch">
 CountDownLatch
 &lt;a class="anchor" href="#countdownlatch">#&lt;/a>
&lt;/h2>
&lt;p>在讨论线程的基本概念时，我们说过&lt;code>join()&lt;/code>方法可使当前线程等待调用join方法的线程执行完，可以实现简单的
 &lt;a href="https://wangy325.github.io/zh-cn/docs/java/concurrency/conecptes/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/#%e5%8a%a0%e5%85%a5%e7%ba%bf%e7%a8%8bjoin">无锁同步&lt;/a>，使用&lt;code>CountDownLatch&lt;/code>可以更加简单的实现这一目的。毕竟，&lt;code>join()&lt;/code>方法的语义“加入一个线程”不是很容易就能让人理解。相较于&lt;code>join()&lt;/code>方法，&lt;code>CountDownLatch&lt;/code>的语义就明确多了。&lt;/p></description></item><item><title>CyclicBarrier</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/components/9_2_cyclicbarrier/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh-cn/docs/java/concurrency/components/9_2_cyclicbarrier/</guid><description>&lt;h2 id="cyclicbarrier">
 CyclicBarrier
 &lt;a class="anchor" href="#cyclicbarrier">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>CyclicBarrier&lt;/code>被称为“同步屏障”，事实上就可以把它理解为一个屏障，多个任务调用屏障的&lt;code>await()&lt;/code>方法将被阻塞，直到所有的任务都进入阻塞，那么屏障开启，所有任务继续执行。这看起来和&lt;code>CountDownLatch&lt;/code>非常像，不过&lt;code>CountDownLatch&lt;/code>只能触发一次，而&lt;code>CyclicBarrier&lt;/code>可以多次重用，这是它们的主要区别之一。&lt;/p>
&lt;p>和&lt;code>CountDownLatch&lt;/code>一样，&lt;code>CyclicBarrier&lt;/code>接受一个整型参数，表示可限制的线程数。除此之外，&lt;code>CyclicBarrier&lt;/code>还可以接受一个&lt;code>Runnable&lt;/code>作为参数，这个参数称作&lt;code>barrierAction&lt;/code>，&lt;code>barrierAction&lt;/code>在所有线程到达屏障之后即开始执行，其他任务&lt;strong>只能等待&lt;/strong>&lt;code>barrierAction&lt;/code>执行完毕之后才能继续执行，这是&lt;code>CyclicBarrier&lt;/code>和&lt;code>CountDownLatch&lt;/code>的区别之二。&lt;/p></description></item><item><title>Semaphore</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/components/9_3_semaphore/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh-cn/docs/java/concurrency/components/9_3_semaphore/</guid><description>Semaphore # 无论是显式锁还是通过synchronized关键字获取的隐式锁，其在任一时刻都只能让一个任务访问资源，而Semaphore（计数信号量）允许多个任务同时访问资源。可以把Semaphore看作是持有对象访问许可（permits）的“security”。访问对象时，须先通过acquire()获取许可，若此时没有许可可用，那么acquire()将阻塞，否则获取许可，可用许可数-1；使用完资源后，通过release()方法返还许可。事实上，并没有实际上的许可证对象，Semaphore通过协同各个线程工作，来达到目的。
Semaphore的构造器接受一个“公平性参数”。不传入此参数或传入false时，线程获取许可的顺序无法保证，即使线程阻塞了很久，其仍然可能被刚调用acquire()方法的线程“抢走”许可，这可能会导致线程“饿死”。当传入true时，Semaphore保证线程获取许可的顺序和其调用acquire()方法之后被执行的顺序一致1，也就是先执行的任务先获取许可（FIFO）。需要说明的是，tryAcquire()方法不遵循公平性原则，如果有许可可用，它直接获取之。在使用Semaphore时，一般将其设置为公平的
Semaphore通常用于限制访问资源的线程数量，典型的例子就是控制“池”的并发访问量。下例中使用Semaphore控制池中的对象方法，当需要使用时，可以将它们“签出”（checkout），使用完毕之后再将其“签入”（checkin），使用泛型类封装功能2。
1class Pool&amp;lt;T&amp;gt; { 2 private final int size; 3 final List&amp;lt;T&amp;gt; items = new ArrayList&amp;lt;&amp;gt;(); 4 private final boolean[] checkedOut; 5 private final Semaphore available; 6 7 public Pool(Class&amp;lt;T&amp;gt; classObject, int size) { 8 this.size = size; 9 checkedOut = new boolean[size]; 10 available = new Semaphore(size, true); 11 // Load pool with objects that can be checked out: 12 for (int i = 0; i &amp;lt; size; ++i) { 13 try { 14 // Assumes a default constructor: 15 items.</description></item><item><title>Exchanger</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/components/9_4_exchanger/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh-cn/docs/java/concurrency/components/9_4_exchanger/</guid><description>&lt;h2 id="exchanger">
 Exchanger
 &lt;a class="anchor" href="#exchanger">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>Exchanger&lt;/code>是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，各自拥有一个对象，离开时交换它们拥有的对象。栅栏可以用来设计缓存对象，2个任务分别来使用和清空缓存，当缓存空间满时，则在Exchanger上交换缓存，缓存得以重复使用&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。&lt;/p></description></item><item><title>PriorityBlockingQueue and DelayQueue</title><link>https://wangy325.github.io/zh-cn/docs/java/concurrency/components/9_5_priorityblockqueue_delayqueue/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh-cn/docs/java/concurrency/components/9_5_priorityblockqueue_delayqueue/</guid><description>PriorityBlockingQueue # PriorityBlockingQueue就是一个基础的可阻塞的 优先级队列，当队列为空时，从队列中获取元素时被阻塞。其余特性和优先级队列是一致的。
下例展示了如何构建一个可以放入优先级队列的任务：
1public class PrioritizedTask implements Runnable, Comparable&amp;lt;PrioritizedTask&amp;gt; { 2 protected static List&amp;lt;PrioritizedTask&amp;gt; sequence = new ArrayList&amp;lt;&amp;gt;(); 3 private Random rand = new Random(47); 4 private static int counter = 0; 5 private final int id = counter++; 6 private final int priority; 7 8 9 public PrioritizedTask(int priority) { 10 this.priority = priority; 11 sequence.add(this); 12 } 13 14 @Override 15 public int compareTo(PrioritizedTask arg) { 16 return priority &amp;lt; arg.</description></item></channel></rss>