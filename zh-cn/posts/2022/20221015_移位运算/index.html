<!doctype html><html lang=zh-CN dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="位运算是直接操作内存中的二进制数据。因此运算效率比常规的四则运算高出不少。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://wangy325.github.io/zh-cn/posts/2022/20221015_%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/"><meta property="og:site_name" content="xf&pl"><meta property="og:title" content="移位运算"><meta property="og:description" content="位运算是直接操作内存中的二进制数据。因此运算效率比常规的四则运算高出不少。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-15T09:01:23+08:00"><meta property="article:modified_time" content="2022-10-15T09:01:23+08:00"><title>移位运算 | xf&amp;pl</title>
<link rel=icon href=/favicon.png><link rel=manifest href=/manifest.json><link rel=canonical href=https://wangy325.github.io/zh-cn/posts/2022/20221015_%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/><link rel=stylesheet href=/book.min.21a480c3e6e72098579e2787d343e35263286cda9742462341e6aa278fbea46c.css integrity="sha256-IaSAw+bnIJhXnieH00PjUmMobNqXQkYjQeaqJ4++pGw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh-cn.search.min.c2df43b03e7a9ae96b82634fe3204a8b52c807150e1a240387fa9731a83ccbf5.js integrity="sha256-wt9DsD56mulrgmNP4yBKi1LIBxUOGiQDh/qXMag8y/U=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-HHNKR5H8KN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-HHNKR5H8KN")}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><div class=navi-bar id=navibar><div id=page-title><h2 class=book-brand><a class="flex align-center" href=/zh-cn/><span>xf&amp;pl</span></a></h2></div><div class=page-navi-col><nav><ul><li><a href=/zh-cn/docs/java/>Java</a></li><li><a href=/zh-cn/docs/design_pattern/>DP</a></li><li class=book-section-flat><a href=/zh-cn/docs/note/>Mooc</a></li><li class=book-section-flat><a href=/zh-cn/docs/snippets/>Snippets</a></li></ul><ul><li><a href=/zh-cn/posts/>Blog</a></li><li><a href=/zh-cn/archive/>Archive</a></li></ul></nav></div><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/ required pattern=\S+.*>
<span class=clear_search><img src=/svg/close.svg onclick=clearInput()></span><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><script>function clearInput(){document.getElementById("book-search-input").value="";for(var e=document.getElementById("book-search-results");e.firstChild;)e.removeChild(e.firstChild)}</script><ul class=book-languages><li><a class="flex align-center"><img src=/svg/language.svg class=book-icon alt=Languages>
简体中文</a></label><ul><li><a href=https://wangy325.github.io/en/>English</a></li></ul></li></ul></div><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label><h3>移位运算</h3><label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><div id=toc-new><ul class=nav><li class=nav-item><a id=t1左移运算 href=javascript:void(0) onclick='return scrolly("1左移运算"),!1'>1.左移运算</a></li><li class=nav-item><a id=t2右移运算 href=javascript:void(0) onclick='return scrolly("2-右移运算"),!1'>2. 右移运算</a><ul class=nav><li class=nav-item><a id=t21逻辑右移 href=javascript:void(0) onclick='return scrolly("21-逻辑右移"),!1'>2.1 逻辑右移</a></li><li class=nav-item><a id=t22算术右移 href=javascript:void(0) onclick='return scrolly("22-算术右移"),!1'>2.2 算术右移</a></li></ul></li></ul></div><script>function scrolly(e){const t=40;var n=document.getElementById(e).offsetTop;window.scrollTo({top:n+t,behaviour:"smooth"})}</script></aside></header><article class="markdown book-post"><h1>移位运算</h1><div class="postmeta flex align-cneter" style=justify-content:center><div class="created flex align-cneter"><img src=/svg/calendar-event.svg class=book-icon alt>
<a title='创建者 wangy325'>2022-10-15</a></div><div class="cates flex align-center"><img src=/svg/cates.svg class=book-icon alt>
<a href=/zh-cn/categories/algo/>Algo</a></div></div><p>位运算是直接操作内存中的二进制数据。因此运算效率比常规的四则运算高出不少。</p><h2 id=1左移运算>1.左移运算
<a class=anchor href=#1%e5%b7%a6%e7%a7%bb%e8%bf%90%e7%ae%97>#</a></h2><p>左移运算用<code>&lt;&lt;</code>表示，按照<strong>高位舍弃，低位补0</strong>的方式将所有数据位向左移动。</p><p>直观来讲，向左移1位等同于将数值乘以2。大多数情形下也确实如此。如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=ln>1</span><span class=cl><span class=k>val</span> <span class=py>a</span> <span class=p>=</span> <span class=m>3</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=n>println</span><span class=p>(</span><span class=s2>&#34;a &lt;&lt; 1 = </span><span class=si>${a shl 1}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1>// 6
</span></span></span><span class=line><span class=ln>3</span><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>b</span> <span class=p>=</span> <span class=p>-</span><span class=m>1</span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=n>println</span><span class=p>(</span><span class=s2>&#34;b &lt;&lt; 1 = </span><span class=si>${b shl 1}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1>// -2
</span></span></span><span class=line><span class=ln>5</span><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>c</span> <span class=p>=</span> <span class=p>-</span><span class=m>0xff</span>
</span></span><span class=line><span class=ln>6</span><span class=cl><span class=n>println</span><span class=p>(</span><span class=s2>&#34;c &lt;&lt; 1 = </span><span class=si>${c shl 1}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1>// -510
</span></span></span><span class=line><span class=ln>7</span><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>d</span> <span class=p>=</span> <span class=m>0xff</span>
</span></span><span class=line><span class=ln>8</span><span class=cl><span class=n>println</span><span class=p>(</span><span class=s2>&#34;d &lt;&lt; 1 = </span><span class=si>${d shl 1}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1>// 510
</span></span></span></code></pre></div><blockquote><p>Kotlin 中使用特定的移位操作符。</p></blockquote><p>但是，这是数据没有溢出的情形。如果一个数足够大，移位时可能会发生数据溢出：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=ln>1</span><span class=cl><span class=k>val</span> <span class=py>a</span> <span class=p>=</span> <span class=m>0x5FFFFFFF</span> <span class=c1>// 1610612736 
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=c1></span><span class=n>println</span><span class=p>(</span><span class=s2>&#34;a &lt;&lt; 1 = </span><span class=si>${a shl 1}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1>// -1073741826
</span></span></span><span class=line><span class=ln>3</span><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>b</span> <span class=p>=</span> <span class=p>-</span><span class=m>0x60000000</span> <span class=c1>// -1610612736 
</span></span></span><span class=line><span class=ln>4</span><span class=cl><span class=c1></span><span class=n>println</span><span class=p>(</span><span class=s2>&#34;b &lt;&lt; 1 = </span><span class=si>${b shl 1}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1>// 1073741824
</span></span></span></code></pre></div><p>上面的2种情形则有不同，当它们向左移位时，按照之前的逻辑，各自的值会翻倍。得到的结果超出了32位整数（int）的取值范围（-2<sup>32</sup> ~2<sup>32</sup>-1），超出的数位被舍弃。以<code>0x5FFFFFFF</code>为例，其2进制表示为：</p><pre tabindex=0><code>        0101 1111 1111 1111 1111 1111 1111 1111
    &lt;&lt; 1
    ---------------------------------------------
      0 1011 1111 1111 1111 1111 1111 1111 1110
</code></pre><p>最高位的0被舍弃，得到的结果高位为1，结果为负数。</p><blockquote><p>左移运算为什么不需要区分逻辑左移和算术左移呢？</p><p>左移位数与符号位后位数对应的数只要是1，左移就会溢出，符号发生改变；反之，如果是0，则符号不会发生改变。</p></blockquote><p>因为左移运算存在溢出。以上述<code>-0x60000000</code>为例，其原码的最高位为1（符号位后一位），由此可知，其左移1位，就会溢出，下图展示了其运算过程：</p><pre tabindex=0><code>    原码：0110 0000 0000 0000 0000 0000 0000 0000
    反码：1001 1111 1111 1111 1111 1111 1111 1111
    补码：1010 0000 0000 0000 0000 0000 0000 0000
   &lt;&lt; 1:   
    ---------------------------------------------------
       1 0100 0000 0000 0000 0000 0000 0000 0000
</code></pre><h2 id=2-右移运算>2. 右移运算
<a class=anchor href=#2-%e5%8f%b3%e7%a7%bb%e8%bf%90%e7%ae%97>#</a></h2><p>和左移运算一样，右移运算将所有的数据位向右移动，<strong>低位舍弃，高位补0/1</strong>。需要注意的是，对于有符号数，由于计算机用最高位表示符号位，因此根据符号位是否移动，可以将右移运算分为<strong>逻辑右移</strong>和<strong>算术右移</strong>。</p><blockquote><p>对于正数来讲，逻辑右移和算术右移是相等的，正数的最高位为0，向右移动时，高位补充的也是0，对结果没有影响。</p></blockquote><h3 id=21-逻辑右移>2.1 逻辑右移
<a class=anchor href=#21-%e9%80%bb%e8%be%91%e5%8f%b3%e7%a7%bb>#</a></h3><p>逻辑右移又叫“无符号右移”，使用<code>>>></code>表示，“逻辑”的意思是，不考虑符号位，所有数位全部右移。在这种情况下，负数右移就会发生符号变化。就像下面这样：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=ln>1</span><span class=cl><span class=k>val</span> <span class=py>a</span> <span class=p>=</span> <span class=p>-</span><span class=m>0xf</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=n>println</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>$a</span><span class=s2> &gt;&gt;&gt; 1 = </span><span class=si>${a ushr 1}</span><span class=s2>&#34;</span><span class=p>)</span>  <span class=c1>// -15 &gt;&gt;&gt; 1 = 2147483640
</span></span></span><span class=line><span class=ln>3</span><span class=cl><span class=c1></span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=k>val</span> <span class=py>b</span> <span class=p>=</span> <span class=m>0xf</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=n>println</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>$b</span><span class=s2> &gt;&gt;&gt; 1 = </span><span class=si>${b ushr 1}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1>// 15 &gt;&gt;&gt; 1 = 7
</span></span></span><span class=line><span class=ln>6</span><span class=cl><span class=c1></span>
</span></span><span class=line><span class=ln>7</span><span class=cl><span class=k>val</span> <span class=py>c</span> <span class=p>=</span> <span class=p>-</span><span class=m>0x80000000</span>
</span></span><span class=line><span class=ln>8</span><span class=cl><span class=n>println</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>$c</span><span class=s2> &gt;&gt;&gt; 1 = </span><span class=si>${c ushr 1}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1>// -2147483648 &gt;&gt;&gt; 1 = 1073741824
</span></span></span></code></pre></div><p>可见，逻辑右移运算在操作负数的情况下，直接移动了符号位，最高位补0，负数也变成了正数。</p><p>下图简单地以<code>-0xf</code>为例，解释运算过程：</p><pre tabindex=0><code>正数原码：0000 0000 0000 0000 0000 0000 0000 1111
    反码：1111 1111 1111 1111 1111 1111 1111 0000
    补码：1111 1111 1111 1111 1111 1111 1111 0001
----------------------------------------------------
&gt;&gt;&gt; 1   : 0111 1111 1111 1111 1111 1111 1111 1000 1
    
</code></pre><h3 id=22-算术右移>2.2 算术右移
<a class=anchor href=#22-%e7%ae%97%e6%9c%af%e5%8f%b3%e7%a7%bb>#</a></h3><p>算术右移使用<code>>></code>表示，相较于逻辑右移，算术右移考虑符号位：</p><ul><li>若移动的是正数，符号位是0，移动时，符号位保持0不变，移动多少位，就在符号位后补多少0。从这个描述来看，正数的算术右移和逻辑右移结果是相等的；</li><li>若移动的是负数，符号位是1，，移动时，符号位保持1不变，移动多少位，就在符号位后补多少1。</li></ul><p>简而言之，算术右移正数补0，负数补1。算术右移的结果就是，值变为原来的1/2。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=ln>1</span><span class=cl><span class=k>val</span> <span class=py>a</span> <span class=p>=</span> <span class=p>-</span><span class=m>0xf</span>
</span></span><span class=line><span class=ln>2</span><span class=cl><span class=n>println</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>$a</span><span class=s2> &gt;&gt; 1 = </span><span class=si>${a shr 1}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1>// -15 &gt;&gt; 1 = -8
</span></span></span><span class=line><span class=ln>3</span><span class=cl><span class=c1></span>
</span></span><span class=line><span class=ln>4</span><span class=cl><span class=k>val</span> <span class=py>b</span> <span class=p>=</span> <span class=m>0xf</span>
</span></span><span class=line><span class=ln>5</span><span class=cl><span class=n>println</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>$b</span><span class=s2> &gt;&gt; 1 = </span><span class=si>${b shr 1}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1>// 15 &gt;&gt; 1 = 7
</span></span></span><span class=line><span class=ln>6</span><span class=cl><span class=c1></span>
</span></span><span class=line><span class=ln>7</span><span class=cl><span class=k>val</span> <span class=py>c</span> <span class=p>=</span> <span class=p>-</span><span class=m>0x80000000</span>
</span></span><span class=line><span class=ln>8</span><span class=cl><span class=n>println</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>$c</span><span class=s2> &gt;&gt; 1 = </span><span class=si>${c shr 1}</span><span class=s2>&#34;</span><span class=p>)</span> <span class=c1>// -2147483648 &gt;&gt; 1 = -1073741824
</span></span></span></code></pre></div><blockquote><p>右移运算不会出现溢出。</p></blockquote></article><div class=next-prev><hr><div class="page-navi flex" id=pagenavi><div class=pre-page>←
<a href=https://wangy325.github.io/zh-cn/posts/2022/20221014_%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/>位运算的小技巧</a></div><div class=next-page><a href=https://wangy325.github.io/zh-cn/posts/2022/20221014_%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/>异或运算</a> →</div></div></div><section class=related><div class=rel-title>相似文章</div><div class=rel-items><a href=/zh-cn/posts/2022/20221014_%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/ class=related__link><div>异或运算</div></a><a href=/zh-cn/posts/2022/20221014_%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/ class=related__link><div>同余定理与二进制补码</div></a><a href=/zh-cn/posts/2020/20201204_01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%982%E4%BE%8B/ class=related__link><div>背包问题2例</div></a></div><hr></section><div class=book-comments><div class=giscus-thread></div><script src=https://giscus.app/client.js data-repo=wangy325/wangy325.github.io data-repo-id=R_kgDOHhhDZg data-category=Announcements data-category-id=DIC_kwDOHhhDZs4ChbMn data-mapping=og:title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=noborder_light data-loading=lazy data-lang=zh-CN crossorigin=anonymous async></script></div><div class=copyright><hr class=cline><p>Notes and Memos by wangy325
<a href=https://creativecommons.org/licenses/by/4.0/deed.en title="Creative Commons Attribution">&copy; CC BY 4.0</a></p><p>2019-2025. Powered by
<a href=https://github.com/alex-shpak/hugo-book>Hugo Book</a>
Presented by Github.</p></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><div id=toc-new><ul class=nav><li class=nav-item><a id=t1左移运算 href=javascript:void(0) onclick='return scrolly("1左移运算"),!1'>1.左移运算</a></li><li class=nav-item><a id=t2右移运算 href=javascript:void(0) onclick='return scrolly("2-右移运算"),!1'>2. 右移运算</a><ul class=nav><li class=nav-item><a id=t21逻辑右移 href=javascript:void(0) onclick='return scrolly("21-逻辑右移"),!1'>2.1 逻辑右移</a></li><li class=nav-item><a id=t22算术右移 href=javascript:void(0) onclick='return scrolly("22-算术右移"),!1'>2.2 算术右移</a></li></ul></li></ul></div><script>function scrolly(e){const t=40;var n=document.getElementById(e).offsetTop;window.scrollTo({top:n+t,behaviour:"smooth"})}</script></div></aside></main><div class=back-to-top><div id=back-to-top><img src=/svg/chevrons-up.svg srcset="/svg/chevrons-up.svg 500w" onclick=topFunction() class=black>
<img title=回到顶部 src=/svg/chevrons-up-blue.svg srcset="/svg/chevrons-up-blue.svg 500w" onclick=topFunction() class=blue></div><script>let mybutton=document.getElementById("back-to-top");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>500||document.documentElement.scrollTop>500?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){window.scrollTo({top:0,behavior:"smooth"})}</script></div><script src=/js/scroll-listening.js></script></body></html>