<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>并发 on Endless River</title><link>https://wangy325.github.io/zh/tags/%E5%B9%B6%E5%8F%91/</link><description>Recent content in 并发 on Endless River</description><generator>Hugo</generator><language>zh</language><lastBuildDate>Wed, 07 Aug 2024 16:20:46 +0800</lastBuildDate><atom:link href="https://wangy325.github.io/zh/tags/%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>线程与任务(一)</title><link>https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_1/</link><pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_1/</guid><description>&lt;p>&lt;strong>并发&lt;/strong>的本质是多个线程同时处理某个任务&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，&lt;del>不同于进程&lt;/del>，线程可以访问同一共享资源（临界资源），当程序不够健壮时，使用多线程就可能带来问题，这是要反复讨论并发的原因之一。&lt;/p>
&lt;p>在Java中，必须明白一点：线程由Thread类启动，但Thread类并不执行任何操作，&lt;strong>它只是驱动赋予它的任务&lt;/strong>。因此将&lt;strong>线程与任务&lt;/strong>的概念区分开，有利于理解并发。&lt;/p>
&lt;p>实际上，开发过程中线程与任务（的联系）被隔离的更加明显，往往不需要显式地声明(创建)线程，然后将任务（声明任务是必须的）分配给线程，并由线程负责驱动（ &lt;em>allocate task to thread to execute&lt;/em> ），这一过程通常由&lt;strong>线程池&lt;/strong>完成 。&lt;/p></description></item><item><title>线程与任务(二)</title><link>https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/</link><pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/</guid><description>&lt;p>
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_1/">第一篇文章&lt;/a>中，讨论了线程与任务的概念，以及利用任务（&lt;em>Runnable接口&lt;/em>）来创建线程。&lt;/p>
&lt;p>同时，讨论了线程的生命周期。此外，介绍了线程的优先级以及守护线程这两个实用性不高的概念。&lt;/p>
&lt;p>最后，讨论了线程的中断状态这个概念。线程的中断状态以及如何响应中断，对于理解线程的运行机制很重要。&lt;/p>
&lt;p>这一篇，继续讨论几个线程相关的概念，包括：&lt;/p>
&lt;ul>
&lt;li>线程的让步&lt;/li>
&lt;li>等待线程加入&lt;/li>
&lt;li>自管理线程&lt;/li>
&lt;li>处理线程的异常&lt;/li>
&lt;/ul></description></item><item><title>资源访问受限--引论</title><link>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_1/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_1/</guid><description>&lt;p>在
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_1/">线程与任务&lt;/a>文中，虽然创建了多线程，并且线程之间出现了一些&lt;strong>不可预测&lt;/strong>的CPU调度，但是由于线程之间是&lt;strong>相互隔离&lt;/strong>的——&lt;strong>线程没有访问共同的资源&lt;/strong>，尽管在执行任务的过程可能被CPU剥夺运行权，但是当它们再次获得运行权时对运行结果并没有影响，它们是安全的。&lt;/p>
&lt;blockquote>
&lt;p>实际上，上篇文章通过&lt;code>join()&lt;/code>方法演示了
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/#%e7%ae%80%e5%8d%95%e7%9a%84%e6%97%a0%e9%94%81%e5%90%8c%e6%ad%a5">一种安全访问共享资源的方法&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>考虑一种情况，如果&lt;strong>多个线程访问同一资源&lt;/strong>，并对资源内容进行修改，会发生什么情况？&lt;/p>
&lt;p>对于&lt;strong>非原子性&lt;/strong>操作，多线程下会出现&lt;strong>竞争条件&lt;/strong>。例如，对于操作&lt;code>accounts[to] += amount&lt;/code>，可以被拆分为多个CPU指令：&lt;/p>
&lt;ol>
&lt;li>加载accounts[to]到寄存器&lt;/li>
&lt;li>增加amount&lt;/li>
&lt;li>将结果写回acounts[to]&lt;/li>
&lt;/ol>
&lt;p>上述3个步骤中，线程执行到&lt;strong>任一步骤&lt;/strong>时都可能被剥夺运行权。&lt;/p>
&lt;p>如此一来，最后的结果就变得不可预测。&lt;/p></description></item><item><title>锁和条件</title><link>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_2_%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_2_%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6/</guid><description>&lt;h2 id="可重入锁">
 可重入锁
 &lt;a class="anchor" href="#%e5%8f%af%e9%87%8d%e5%85%a5%e9%94%81">#&lt;/a>
&lt;/h2>
&lt;p>Java SE 5之后提供了位于&lt;code>java.util.concurrent.locks&lt;/code>包下的显式&lt;strong>互斥机制&lt;/strong>——Lock对象（显式锁），Lock对象必须被&lt;strong>显式的创建，锁定和释放&lt;/strong>。&lt;/p>
&lt;p>一般情况下 ，ReentrantLock保护代码块的基本结构是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>myLock.&lt;span style="color:#a6e22e">lock&lt;/span>(); &lt;span style="color:#75715e">// 可重入锁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 临界区代码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;span style="color:#66d9ef">finally&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myLock.&lt;span style="color:#a6e22e">unlock&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个结构可以确保同一时间只有&lt;strong>一个线程&lt;/strong>进入临界区( &lt;em>critical section&lt;/em> )，其他线程调用&lt;code>lock()&lt;/code>时会被阻塞，直到第一个线程释放锁。&lt;/p></description></item><item><title>synchronized关键字</title><link>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_3_synchronized/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_3_synchronized/</guid><description>&lt;p>自Java 1.0开始，每一个对象都有一个隐式&lt;strong>内部锁&lt;/strong>（ &lt;em>intrinsic lock&lt;/em> ），在Java API Specification中通常被称为&lt;strong>监视器&lt;/strong>（ &lt;em>monitor&lt;/em> ）。这个内部锁由&lt;code>synchronized&lt;/code>关键字提供支持。&lt;code>synchronized&lt;/code>关键字的语义就是“同步的”，这意味着使用这个关键字可以处理共享资源的冲突。&lt;/p>
&lt;p>当访问被&lt;code>synchronized&lt;/code>关键字保护的方法或代码块时，它将检查锁能否获得——&lt;strong>这个锁可以是当前类对象的锁，也可以是一个临时锁&lt;/strong>( &lt;em>ad-hoc lock&lt;/em> )，取决你如何使用，任务执行完成之后会释放锁。&lt;/p>
&lt;p>和&lt;code>ReentrantLock&lt;/code>一样，&lt;code>synchronized&lt;/code>关键字获取的锁也是&lt;strong>独占锁&lt;/strong>，并且也是“可重入”的，某个任务可以多次获得对象的锁，并由计数器维护获得锁的次数，当退出一个方法时，计数器-1，完全退出时，才释放锁，这和可重入锁的机制是一样的。&lt;/p></description></item><item><title>原子性和可见性</title><link>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_4_%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_4_%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB/</guid><description>&lt;p>原子性一般指&lt;strong>原子操作&lt;/strong>，原子操作不能&lt;strong>被线程调度机制中断&lt;/strong>，一旦操作开始，那么它一定可以在可能发生的上下文切换之前完成。Java语言规范规定了对基本对象(long和double除外)的读写操作是原子的。&lt;/p>
&lt;p>&lt;strong>不能将原子性和同步划等号&lt;/strong>！更不能使用原子性来代替同步，当你想使用原子性代替同步写出无锁代码时，思考 
 &lt;a href="https://inside.java/u/BrianGoetz/">&lt;em>Brain Goetz&lt;/em>&lt;/a> 的建议：&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>&lt;strong>If you can write a high-performance JVM for a modern microprocessor, then you are qualified to think about whether you can avoid synchronizing.&lt;/strong>&lt;/em>&lt;/p>
&lt;/blockquote></description></item><item><title>线程本地存储</title><link>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_5_%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_5_%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</guid><description>&lt;p>使用&lt;code>synchronized&lt;/code>关键字对整个方法加锁（防止其他线程访问整个方法）往往会带来更大的性能开销，如果你只想保护某些代码块，可以使用&lt;strong>同步代码块&lt;/strong>，这一段被锁保护的代码块就称为&lt;strong>临界区&lt;/strong>（ &lt;em>critical section&lt;/em> ），前面的&lt;strong>显式锁&lt;/strong>所保护的区域以及使用&lt;strong>synchronized&lt;/strong>保护的代码块都是临界区。&lt;/p></description></item><item><title>获取任务的返回值</title><link>https://wangy325.github.io/zh/docs/java/concurrency/3%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/3%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</guid><description>&lt;h1 id="获取任务的返回值">
 获取任务的返回值
 &lt;a class="anchor" href="#%e8%8e%b7%e5%8f%96%e4%bb%bb%e5%8a%a1%e7%9a%84%e8%bf%94%e5%9b%9e%e5%80%bc">#&lt;/a>
&lt;/h1>
&lt;p>要创建一个任务，通常实现&lt;code>Runnable&lt;/code>接口。不幸的是，&lt;code>Runnable&lt;/code>接口的&lt;code>run()&lt;/code>方法返回&lt;code>void&lt;/code>，因此，其并不适合处理计算任务。&lt;/p>
&lt;p>考虑一个经典的问题：用多线程分段计算0-100的加和，我们需要把每个线程计算的值汇总，然后再求和，那么应该怎样获取每个任务返回值呢？&lt;/p>
&lt;p>Java提供了&lt;code>Callable&lt;/code>和&lt;code>Future&lt;/code>接口，使任务有提供返回值的能力。&lt;/p></description></item><item><title>死锁问题2例</title><link>https://wangy325.github.io/zh/docs/java/concurrency/4%E6%AD%BB%E9%94%81/</link><pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/4%E6%AD%BB%E9%94%81/</guid><description>&lt;p>Java有能力使任务为等待某些条件成立而进入阻塞状态，所以就有可能出现这样一种情况：某个任务在等待另一个任务，而后者又在等待其他的任务，这样一直等待下去，直到等待链上的最后一个任务又在等待第一个任务释放锁，这样就出现了任务之间相互等待的连续循环现象，这种情况出现之后，没有哪个任务能够执行，于是 &lt;strong>死锁&lt;/strong> 出现。&lt;/p>
&lt;p>死锁之所以难以规避，其重要的原因就在于其不确定性，可能程序运行良好，但是有潜在的死锁风险，这个风险在&lt;strong>某些域的初始条件&lt;/strong>变化时，变得特别大，导致程序很快死锁。同时，死锁难以复现，当程序出现死锁时，往往只能通过jvm的堆栈日志来探究原因。&lt;/p></description></item><item><title>终结任务</title><link>https://wangy325.github.io/zh/docs/java/concurrency/5%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1/</link><pubDate>Fri, 23 Oct 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/5%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1/</guid><description>&lt;h2 id="终结任务">
 终结任务
 &lt;a class="anchor" href="#%e7%bb%88%e7%bb%93%e4%bb%bb%e5%8a%a1">#&lt;/a>
&lt;/h2>
&lt;p>一般地，如果程序运行良好，任务执行完所需操作后自然结束，任务终结。&lt;/p>
&lt;p>如果任务执行时出现异常，任务也会终结。&lt;/p>
&lt;p>在设计多个线程协同工作的任务时，需要判断&lt;strong>任务终结的条件&lt;/strong>，以便合适地终结任务，这点尤为重要。&lt;/p>
&lt;p>在本节中主要讨论在多线程协同工作的情况下，如何合适的终结任务。&lt;/p></description></item><item><title>生产者-消费者与阻塞队列</title><link>https://wangy325.github.io/zh/docs/java/concurrency/6%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</link><pubDate>Mon, 26 Oct 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/6%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</guid><description>&lt;p>在讨论线程协作的时候，已经讨论了生产者与消费者雏形，比如录音是生产者，而播放则是消费者；同样的，在汽车打蜡的模型中，打蜡可看作生产者，抛光可看作消费者；只是它们的关系是简单的生产-消费关系。&lt;/p>
&lt;p>除了简单的线程协同之外，Java提供了&lt;strong>同步队列&lt;/strong>来解决线程的协同问题，本节重点讨论这部分的内容。&lt;/p></description></item><item><title>阻塞队列的使用2例</title><link>https://wangy325.github.io/zh/docs/java/concurrency/6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A82%E4%BE%8B/</link><pubDate>Mon, 26 Oct 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A82%E4%BE%8B/</guid><description>&lt;p>
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/6%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/">上一篇文章&lt;/a>介绍了juc的几种主要阻塞队列。&lt;/p>
&lt;p>本文使用2个例子，演示了阻塞队列在Java中的应用。&lt;/p></description></item><item><title>Executors与Executor框架</title><link>https://wangy325.github.io/zh/docs/java/concurrency/7_1_Executors_and_ExecutorService/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/7_1_Executors_and_ExecutorService/</guid><description>&lt;p>&lt;code>Executors&lt;/code>可以称作执行器。Java并发系列的文章到目前为止，虽然没有特别说明，但是使用执行器(Executor(s))的次数已经难以计数了，&lt;code>Executors&lt;/code>提供了一些非常方便的静态方法，可以根据需要创建不同的&lt;code>ExecutorService&lt;/code>，然后调用其&lt;code>execute(Runnable)&lt;/code>或&lt;code>submit(Callable&amp;lt;T&amp;gt;)&lt;/code>方法。&lt;/p>
&lt;p>在并发条件下，执行器还有一个非常明显的优势，它使用&lt;strong>线程池&lt;/strong>管理线程，减少了系统创建和销毁线程的开销。在一般的Java并发过程中，也建议使用执行器完成任务而非显式地创建线程。&lt;/p>
&lt;p>本文将从执行器开始，阐述Java中的线程池。&lt;/p></description></item><item><title>ThreadPoolExecutor-1</title><link>https://wangy325.github.io/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/</guid><description>&lt;p>
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/7_1_Executors_and_ExecutorService/">前文&lt;/a>就已经提过，&lt;code>Executors&lt;/code>执行器创建的线程池包括不同实现，可以应对不同的场景，那么Java中包含哪些实现呢？&lt;/p>
&lt;p>本问就来讨论这些实现。&lt;/p></description></item><item><title>ThreadPoolExecutor-2</title><link>https://wangy325.github.io/zh/docs/java/concurrency/7_3_ThreadPoolExecutor2/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/7_3_ThreadPoolExecutor2/</guid><description>&lt;p>
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/#threadpoolexecutor">前文&lt;/a>说过，&lt;code>ThreadPoolExecutor&lt;/code>实例代表了Java线程池，前面我们介绍了&lt;code>ThreadPoolExecutor&lt;/code>的构造器和几个核心概念，在本节中，我们着重介绍线程池的执行过程以及线程池的关闭。&lt;/p></description></item><item><title>CompletionService</title><link>https://wangy325.github.io/zh/docs/java/concurrency/7_4_CompletionService/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/7_4_CompletionService/</guid><description>在提交单个任务时，使用submit()或者execute()方法或许能够满足要求，但如果需要控制多个任务时，依次提交的操作看起来“有些繁琐”，此时我们可以使用ExecutorService提供的invokeAny/invokeAll方法，在介绍CompletionService接口时，我们不妨先看看这两个方法。
之前介绍AbstractExecutorService时提到，这两个方法是在这个抽象类中实现的，其中前者在获取到一个任务的返回值时便取消其他（未执行或正在执行的任务）任务，而后者需要等待所有的任务执行完成之后才能对任务的返回进行处理，接下来我们分别来看：
invokeAll会阻塞等待所有的任务执行完成。
public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks) throws InterruptedException { if (tasks == null) throw new NullPointerException(); ArrayList&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; futures = new ArrayList&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;(tasks.size()); boolean done = false; try { for (Callable&amp;lt;T&amp;gt; t : tasks) { RunnableFuture&amp;lt;T&amp;gt; f = newTaskFor(t); futures.add(f); execute(f); } // 有序迭代 for (int i = 0, size = futures.size(); i &amp;lt; size; i++) { Future&amp;lt;T&amp;gt; f = futures.get(i); if (!f.isDone()) { try { // 阻塞等待任务执行完成 f.</description></item><item><title>ScheduledExecutorService-1</title><link>https://wangy325.github.io/zh/docs/java/concurrency/8_1_ScheduledExecutorService1/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/8_1_ScheduledExecutorService1/</guid><description>&lt;p>除了&lt;code>ThreadPoolExecutor&lt;/code>之外，Java执行器（Executor）框架还提供了可以在指定延迟之后执行一次或周期执行任务的接口&lt;code>ScheduledExecutorService&lt;/code>，较
 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Timer.html">java.util.Timer&lt;/a>而言，它是更好的选择。&lt;/p>
&lt;p>与
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/#threadpoolexecutor">线程池&lt;/a>不同的是，用于计划执行的&lt;code>ScheduledThreadPoolExecutor&lt;/code>使用&lt;code>ScheduledFutureTask&lt;/code>作为任务，使用&lt;code>DelayedWorkQueue&lt;/code>作为任务队列，以实现计划（周期）执行的目的。&lt;/p></description></item><item><title>ScheduledExecutorService-2</title><link>https://wangy325.github.io/zh/docs/java/concurrency/8_2_ScheduledExecutorService2/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/8_2_ScheduledExecutorService2/</guid><description>&lt;h2 id="引例">
 引例
 &lt;a class="anchor" href="#%e5%bc%95%e4%be%8b">#&lt;/a>
&lt;/h2>
&lt;p>
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/8_1_ScheduledExecutorService1/#scheduledfuturetask">前文&lt;/a>介绍了&lt;code>ScheduledFutureTask&lt;/code>和&lt;code>DeleyedWorkQueue&lt;/code>这么多，都是为了更好地理解任务执行的流程，在这之前，我们不妨先看如下示例：&lt;/p></description></item><item><title>并发组件-CountDownLatch</title><link>https://wangy325.github.io/zh/docs/java/concurrency/9_1_countdownlatch/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/9_1_countdownlatch/</guid><description>&lt;h2 id="countdownlatch">
 CountDownLatch
 &lt;a class="anchor" href="#countdownlatch">#&lt;/a>
&lt;/h2>
&lt;p>在讨论线程的基本概念时，我们说过&lt;code>join()&lt;/code>方法可使当前线程等待调用join方法的线程执行完，可以实现简单的
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/#%e5%8a%a0%e5%85%a5%e7%ba%bf%e7%a8%8bjoin">无锁同步&lt;/a>，使用&lt;code>CountDownLatch&lt;/code>可以更加简单的实现这一目的。毕竟，&lt;code>join()&lt;/code>方法的语义“加入一个线程”不是很容易就能让人理解。相较于&lt;code>join()&lt;/code>方法，&lt;code>CountDownLatch&lt;/code>的语义就明确多了。&lt;/p></description></item><item><title>并发组件-CyclicBarrier</title><link>https://wangy325.github.io/zh/docs/java/concurrency/9_2_cyclicbarrier/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/9_2_cyclicbarrier/</guid><description>&lt;h2 id="cyclicbarrier">
 CyclicBarrier
 &lt;a class="anchor" href="#cyclicbarrier">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>CyclicBarrier&lt;/code>被称为“同步屏障”，事实上就可以把它理解为一个屏障，多个任务调用屏障的&lt;code>await()&lt;/code>方法将被阻塞，直到所有的任务都进入阻塞，那么屏障开启，所有任务继续执行。这看起来和&lt;code>CountDownLatch&lt;/code>非常像，不过&lt;code>CountDownLatch&lt;/code>只能触发一次，而&lt;code>CyclicBarrier&lt;/code>可以多次重用，这是它们的主要区别之一。&lt;/p>
&lt;p>和&lt;code>CountDownLatch&lt;/code>一样，&lt;code>CyclicBarrier&lt;/code>接受一个整型参数，表示可限制的线程数。除此之外，&lt;code>CyclicBarrier&lt;/code>还可以接受一个&lt;code>Runnable&lt;/code>作为参数，这个参数称作&lt;code>barrierAction&lt;/code>，&lt;code>barrierAction&lt;/code>在所有线程到达屏障之后即开始执行，其他任务&lt;strong>只能等待&lt;/strong>&lt;code>barrierAction&lt;/code>执行完毕之后才能继续执行，这是&lt;code>CyclicBarrier&lt;/code>和&lt;code>CountDownLatch&lt;/code>的区别之二。&lt;/p></description></item><item><title>并发组件-Semaphore</title><link>https://wangy325.github.io/zh/docs/java/concurrency/9_3_semaphore/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/9_3_semaphore/</guid><description>Semaphore # 无论是显式锁还是通过synchronized关键字获取的隐式锁，其在任一时刻都只能让一个任务访问资源，而Semaphore（计数信号量）允许多个任务同时访问资源。可以把Semaphore看作是持有对象访问许可（permits）的“security”。访问对象时，须先通过acquire()获取许可，若此时没有许可可用，那么acquire()将阻塞，否则获取许可，可用许可数-1；使用完资源后，通过release()方法返还许可。事实上，并没有实际上的许可证对象，Semaphore通过协同各个线程工作，来达到目的。
Semaphore的构造器接受一个“公平性参数”。不传入此参数或传入false时，线程获取许可的顺序无法保证，即使线程阻塞了很久，其仍然可能被刚调用acquire()方法的线程“抢走”许可，这可能会导致线程“饿死”。当传入true时，Semaphore保证线程获取许可的顺序和其调用acquire()方法之后被执行的顺序一致1，也就是先执行的任务先获取许可（FIFO）。需要说明的是，tryAcquire()方法不遵循公平性原则，如果有许可可用，它直接获取之。在使用Semaphore时，一般将其设置为公平的
Semaphore通常用于限制访问资源的线程数量，典型的例子就是控制“池”的并发访问量。下例中使用Semaphore控制池中的对象方法，当需要使用时，可以将它们“签出”（checkout），使用完毕之后再将其“签入”（checkin），使用泛型类封装功能2。
class Pool&amp;lt;T&amp;gt; { private final int size; final List&amp;lt;T&amp;gt; items = new ArrayList&amp;lt;&amp;gt;(); private final boolean[] checkedOut; private final Semaphore available; public Pool(Class&amp;lt;T&amp;gt; classObject, int size) { this.size = size; checkedOut = new boolean[size]; available = new Semaphore(size, true); // Load pool with objects that can be checked out: for (int i = 0; i &amp;lt; size; ++i) { try { // Assumes a default constructor: items.</description></item><item><title>并发组件-Exchanger</title><link>https://wangy325.github.io/zh/docs/java/concurrency/9_4_exchanger/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/9_4_exchanger/</guid><description>&lt;h2 id="exchanger">
 Exchanger
 &lt;a class="anchor" href="#exchanger">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>Exchanger&lt;/code>是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，各自拥有一个对象，离开时交换它们拥有的对象。栅栏可以用来设计缓存对象，2个任务分别来使用和清空缓存，当缓存空间满时，则在Exchanger上交换缓存，缓存得以重复使用&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。&lt;/p></description></item><item><title>并发组件-PBQ/DQ</title><link>https://wangy325.github.io/zh/docs/java/concurrency/9_5_priorityblockqueue_delayqueue/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/9_5_priorityblockqueue_delayqueue/</guid><description>PriorityBlockingQueue # PriorityBlockingQueue就是一个基础的可阻塞的 优先级队列，当队列为空时，从队列中获取元素时被阻塞。其余特性和优先级队列是一致的。
下例展示了如何构建一个可以放入优先级队列的任务：
public class PrioritizedTask implements Runnable, Comparable&amp;lt;PrioritizedTask&amp;gt; { protected static List&amp;lt;PrioritizedTask&amp;gt; sequence = new ArrayList&amp;lt;&amp;gt;(); private Random rand = new Random(47); private static int counter = 0; private final int id = counter++; private final int priority; public PrioritizedTask(int priority) { this.priority = priority; sequence.add(this); } @Override public int compareTo(PrioritizedTask arg) { return priority &amp;lt; arg.priority ? 1 : (priority &amp;gt; arg.priority ? -1 : 0); } @Override public void run() { try { TimeUnit.</description></item><item><title>JMM与volatile关键字(转)</title><link>https://wangy325.github.io/zh/docs/java/concurrency/10_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/10_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>&lt;h1 id="java内存模型与volatile关键字">
 Java内存模型与volatile关键字
 &lt;a class="anchor" href="#java%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e4%b8%8evolatile%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>
&lt;/h1>
&lt;p>本文转自
 &lt;a href="http://www.cnblogs.com/dolphin0520/p/3920373.html">Matrix海子&lt;/a>，是描述&lt;code>volatile&lt;/code>关键字非常好的一篇文章，从Java的内存模型开始，归本溯源的阐述了&lt;code>volatile&lt;/code>关键字在并发中的作用与局限&lt;/p>
&lt;p>此文部分内容参照了《深入理解Java虚拟机》&lt;/p></description></item></channel></rss>