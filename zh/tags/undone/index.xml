<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Undone on Endless River</title><link>https://wangy325.github.io/zh/tags/undone/</link><description>Recent content in Undone on Endless River</description><generator>Hugo</generator><language>zh</language><lastBuildDate>Thu, 15 Aug 2024 17:52:52 +0800</lastBuildDate><atom:link href="https://wangy325.github.io/zh/tags/undone/index.xml" rel="self" type="application/rss+xml"/><item><title>Spring声明式事务的使用</title><link>https://wangy325.github.io/zh/docs/java/spring/spring-transaction-propagation/</link><pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/spring/spring-transaction-propagation/</guid><description>&lt;h2 id="1-从transactional注解开始">
 1 从&lt;code>@Transactional&lt;/code>注解开始
 &lt;a class="anchor" href="#1-%e4%bb%8etransactional%e6%b3%a8%e8%a7%a3%e5%bc%80%e5%a7%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>@Transactional&lt;/code>注解是使用spring-transaction的最便捷方式。也是使用Spring框架开发最先接触的内容。&lt;/p>
&lt;p>当你在一个服务的方法上使用&lt;code>@Transactional&lt;/code>注解时，意味着你希望为此方法开启事务支持。如果你的项目成功配置了&lt;strong>数据源&lt;/strong>和&lt;strong>事务管理器&lt;/strong>，Spring会为此方法使用如下默认设置开启事务：&lt;/p></description></item><item><title>Courses</title><link>https://wangy325.github.io/zh/docs/note/course/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/course/</guid><description>本部分内容记录了系列课程的学习笔记。
这可能是一个漫长、缓慢且很难坚持的的过程。
操作系统原理 # Algorithms, Part I #</description></item><item><title>MySQL死锁</title><link>https://wangy325.github.io/zh/docs/craft/db/sql/6_mysql%E6%AD%BB%E9%94%81/</link><pubDate>Mon, 05 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/sql/6_mysql%E6%AD%BB%E9%94%81/</guid><description>&lt;p>MySQL死锁是指多个事务之间，由于每个事务持有另一个事务所需的锁而无法继续执行的情况。因所有事务都在等待相同的资源变得可用，而没有一个事务释放它所持有的锁。&lt;/p>
&lt;p>多个事务以相反的顺序锁定多个表中的行（通过诸如UPDATE或SELECT ... FOR UPDATE之类的语句），就可能发生死锁。&lt;/p>
&lt;p>死锁也可能发生在这些语句锁定索引记录和间隙范围时，每个事务获取一些锁但由于时间问题而没有获取其他锁。&lt;/p></description></item><item><title>Git合并与分支管理</title><link>https://wangy325.github.io/zh/posts/Git%E5%85%A5%E9%97%A82/</link><pubDate>Thu, 20 Sep 2018 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/Git%E5%85%A5%E9%97%A82/</guid><description>&lt;blockquote>
&lt;p>此文的操作背景在本次工作空间的master分支下, 并且追踪远程master分支
部分内容参考自
 &lt;a href="https://www.yiibai.com/git/git_pull.html">yibai.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>
 &lt;a href="https://wangy325.github.io/zh/posts/Git%E5%85%A5%E9%97%A81/">常用操作速查&lt;/a>说到, git版本控制的基本原型与操作逻辑. 如果出现两台机器(比如公司和家)上同时更改'本地仓库'内容并且&lt;code>push&lt;/code>到远程库中,那么必然会导致另一个版本库中的文件低于远程库,如果是有效的改动, 必然涉及到本地库和远程库同步的问题, 这涉及到3个关键词: &lt;code>fetch&lt;/code>, &lt;code>merge&lt;/code>, &lt;code>pull&lt;/code>&lt;/p></description></item></channel></rss>