<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>线程本地存储 on EndlessRiver</title><link>https://wangy325.github.io/zh/tags/%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</link><description>Recent content in 线程本地存储 on EndlessRiver</description><generator>Hugo -- gohugo.io</generator><language>zh</language><managingEditor>wangy325@qq.com (wangy325)</managingEditor><webMaster>wangy325@qq.com (wangy325)</webMaster><copyright>&amp;copy;2019-{year}, All Rights Reserved</copyright><lastBuildDate>Sat, 30 May 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://wangy325.github.io/zh/tags/%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>Java并发系列之4——死锁</title><link>https://wangy325.github.io/zh/posts/java/concurrency/4%E6%AD%BB%E9%94%81/</link><pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate><author>wangy325@qq.com (wangy325)</author><atom:modified>Fri, 26 Aug 2022 06:22:06 +0000</atom:modified><guid>https://wangy325.github.io/zh/posts/java/concurrency/4%E6%AD%BB%E9%94%81/</guid><description>&lt;p>Java有能力使任务为等待某些条件成立而进入阻塞状态，所以就有可能出现这样一种情况：某个任务在等待另一个任务，而后者又在等待其他的任务，这样一直等待下去，直到等待链上的最后一个任务又在等待第一个任务释放锁，这样就出现了任务之间相互等待的连续循环现象，这种情况出现之后，没有哪个任务能够执行，于是 &lt;strong>死锁&lt;/strong> 出现。&lt;/p>
&lt;p>死锁之所以难以规避，其重要的原因就在于其不确定性，可能程序运行良好，但是有潜在的死锁风险，这个风险在&lt;strong>某些域的初始条件&lt;/strong>变化时，变得特别大，导致程序很快死锁。同时，死锁难以复现，当程序出现死锁时，往往只能通过jvm的堆栈日志来探究原因。&lt;/p>
&lt;p>我们不妨回顾在&lt;a href="../2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90/#21-span-idcondition%E6%9D%A1%E4%BB%B6span">转账问题&lt;/a>中使用的等待条件——账户余额不足时使任务等待，在余额足够的时候再进行转账。这个程序没有问题，因为有100个账户每个账户初始金额1000元，而转账金额&lt;strong>不大于&lt;/strong>初始金额，所以任一时刻都会有账户的金额满足转账条件。如果去除转账金额不大于1000的限制，死锁就会发生。&lt;/p>
&lt;p>比如有2个账户&lt;/p>
&lt;pre>&lt;code>账户A 余额200元
账户B 余额300元
&lt;/code>&lt;/pre>
&lt;p>账户A向账户B转账300元，余额不足等待；账户B向账户A转账400，余额不足等待；程序就进入死锁。&lt;/p>
&lt;blockquote>
&lt;p>上面描述的死锁，线程的状态并不是BLOCKED，而是WAITING。资源上所有的线程都进入等待，实际上锁并没有被占用，但是程序无法被唤醒而继续运行。&lt;/p>
&lt;p>还有一种死锁，即线程的状态是BLOCKED，这种情形在使用多把锁时容易出现。&lt;/p>
&lt;/blockquote></description><dc:creator>wangy325</dc:creator><category>死锁</category><category>线程本地存储</category><category>并发</category></item></channel></rss>