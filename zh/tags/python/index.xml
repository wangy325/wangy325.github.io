<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on Endless River</title><link>https://wangy325.github.io/zh/tags/python/</link><description>Recent content in Python on Endless River</description><generator>Hugo</generator><language>zh</language><lastBuildDate>Thu, 25 Jul 2024 15:21:49 +0800</lastBuildDate><atom:link href="https://wangy325.github.io/zh/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>流程控制语句</title><link>https://wangy325.github.io/zh/docs/misc/py/1_flow_control/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/misc/py/1_flow_control/</guid><description># 用户输入一个数字 number = int(input(&amp;#34;请输入一个数字：&amp;#34;)) # 使用 if-else 语句判断数字的奇偶性 if number &amp;gt; 0: print(f&amp;#34;{number} 是正数&amp;#34;) elif number &amp;lt; 0: print(f&amp;#34;{number} 是负数&amp;#34;) else: print(f&amp;#34;{number} 是0&amp;#34;) # 使用 for 循环打印 1 到 5 的数字 print(&amp;#34;使用 for 循环打印 1 到 10 的奇数：&amp;#34;) for i in range(1, 10, 2): print(i) # 使用 while 循环计算 1 到 10 的数字之和 print(&amp;#34;使用 while 循环计算 1 到 10 的数字之和：&amp;#34;) sum = 0 i = 1 while i &amp;lt;= 10: sum += i i += 1 print(f&amp;#34;1 到 10 的数字之和为：{sum}&amp;#34;) &amp;#34;&amp;#34;&amp;#34; 在 for 循环中,else 子句会在循环成功结束最后一次迭代之后执行。 在 while 循环中,它会在循环条件变为假值后执行。 无论哪种循环,如果因为 break 而结束,那么 else 子句就 不会 执行。 &amp;#34;&amp;#34;&amp;#34; print(&amp;#39;计算2-10之间的质数: &amp;#39;) for i in range(2, 10): for j in range(2, i): if (i % j == 0): print(i, &amp;#39;equals&amp;#39;, j, &amp;#39;*&amp;#39;, i // j) break else: print(i, &amp;#39;is a prime number&amp;#39;)</description></item><item><title>字符串，元组和字典</title><link>https://wangy325.github.io/zh/docs/misc/py/2_data_str_tuple_dict/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/misc/py/2_data_str_tuple_dict/</guid><description>&amp;#39;&amp;#39;&amp;#39; python的基本数据结构 - 序列 1. 字符串 str 2. 列表 list (列表推导式) data_list.py 3. 元组 tuple - 集合 set - 字典 dict - 其他的编程技巧 &amp;#39;&amp;#39;&amp;#39; def __str(): &amp;#39;&amp;#39;&amp;#39; 字符串不可变(immutable) &amp;#39;&amp;#39;&amp;#39; print(&amp;#39;who are you&amp;#39;) # using \ to eacape. print(&amp;#39;I\&amp;#39;m robot&amp;#39;) # if u don&amp;#39;t want to escape a str, like file path, use &amp;#39;r&amp;#39; before quote. print(r&amp;#39;C:\file\path&amp;#39;) # dispite the + calculation, # python also support * calculation, cool print(&amp;#39;holy sh&amp;#39; + 7 * &amp;#39;i&amp;#39; + &amp;#39;t!</description></item><item><title>列表（list）</title><link>https://wangy325.github.io/zh/docs/misc/py/3_data_list/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/misc/py/3_data_list/</guid><description>&amp;#39;&amp;#39;&amp;#39; 和字符串一样, 列表支持索引访问. 列表是一个元素可重复, 可修改的序列. 列表的元素可以包括不同的类型, 甚至是None 但是, 一般也不要那么做. &amp;#39;&amp;#39;&amp;#39; def __list(): alist = [1, 1, 2, 3, 5, 8, 13, 21, 34] print(type(alist)) print(alist[4]) # Join 2 lists together blist = alist + [54, 89] print(blist) # List element can be changed blist[9] = 55 print(blist) # Also, list support slice clist = [&amp;#39;apple&amp;#39;, &amp;#39;orange&amp;#39;, &amp;#39;grapy&amp;#39;, &amp;#39;stawberry&amp;#39;] print(clist[2:3]) # grapy # Assigning a slice can also modify original list, even clear the list clist[2:3] = [&amp;#39;grape&amp;#39;] print(clist) # [&amp;#39;apple&amp;#39;, &amp;#39;orange&amp;#39;, &amp;#39;grape&amp;#39;, &amp;#39;stawberry&amp;#39;] clist[3:] = [] print(clist) # [&amp;#39;apple&amp;#39;, &amp;#39;orange&amp;#39;, &amp;#39;grape&amp;#39;] clist[:] = [] print(clist) # [] # List has many usful APIs clist.</description></item><item><title>函数</title><link>https://wangy325.github.io/zh/docs/misc/py/4_func/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/misc/py/4_func/</guid><description># author: wangy # date: 2024/7/9 # description: &amp;#34;&amp;#34;&amp;#34; python 函数的几个小🌰️ 1. 定义函数的关键字 `def` 2. 函数的返回值 `None`和return语句 斐波那契数 3. 解包赋值表达式 4. 函数的形参列表 - 位置参数 - 关键字参数 - 特殊参数（元组和字典） 5. 解包表达式作为实参 6. Lambda表达式作为实参 &amp;#34;&amp;#34;&amp;#34; def func(length, width): s = length * width print(f&amp;#39;Square of rectangle is {s}.&amp;#39;) # 函数可以直接赋值给变量 mf = func mf(5, 3) def __fib(limit): &amp;#39;&amp;#39;&amp;#39; - fibonacci斐波那契数列 - 形参: limit: 最大数限制 &amp;#39;&amp;#39;&amp;#39; a, b = 0, 1 while a &amp;lt; limit: print(a, end=&amp;#39; &amp;#39;) # python的解包赋值特性 a, b = b, a + b print(end=&amp;#39;\n&amp;#39;) __fib(100) print(__fib.</description></item><item><title>4个重要的内置函数</title><link>https://wangy325.github.io/zh/docs/misc/py/5_4_important_functions/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/misc/py/5_4_important_functions/</guid><description>&amp;#34;&amp;#34;&amp;#34; Author: wangy325 Date: 2024-07-22 16:57:01 Description: &amp;#34;&amp;#34;&amp;#34; # ############### # # 4个重要的函数 # # filter() # # map() # # reduce() # # zip() # # ############### # # Tips: 在命令行界面使用help()可以查看内置函数的帮助文档 # filter()函数 &amp;#39;&amp;#39;&amp;#39; class filter(object) | filter(function or None, iterable) --&amp;gt; filter object | | Return an iterator yielding those items of iterable for which function(item) | is true. If function is None, return the items that are true &amp;#39;&amp;#39;&amp;#39; l = [1, 2, 3, 4] f = filter(lambda x: x &amp;gt; 2, l) print(type(f)) # &amp;lt;class &amp;#39;filter&amp;#39;&amp;gt; for e in f: print(e, end=&amp;#39;, &amp;#39;) print() for p in filter(lambda e: e.</description></item><item><title>格式化输出与文件I/O</title><link>https://wangy325.github.io/zh/docs/misc/py/6_file_io/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/misc/py/6_file_io/</guid><description>from math import pi as pi import os &amp;#34;&amp;#34;&amp;#34; 输入输出与文件I/O 1. 格式化字符串 2. 读取文件 &amp;#34;&amp;#34;&amp;#34; &amp;#39;&amp;#39;&amp;#39; 使用占位符 &amp;#39;&amp;#39;&amp;#39; year = 2024 event = &amp;#39;Trump\&amp;#39;s Gun Shot&amp;#39; print(f&amp;#39;Big News of {event} in {year}&amp;#39;) ### 或者这样 print(f&amp;#39;Big News of {event=} in {year=}&amp;#39;) ### 占位符支持还格式化字符串输出 print(f&amp;#39;The value of pi is approximately {pi:.3f}&amp;#39;) ### 可以指定宽度 table = {&amp;#39;Sjoerd&amp;#39;: 4127, &amp;#39;Jack&amp;#39;: 4098, &amp;#39;Dcab&amp;#39;: 7678} for name, phone in table.items(): print(f&amp;#39;{name:10} ==&amp;gt; {phone:10d}&amp;#39;) &amp;#39;&amp;#39;&amp;#39; 使用format()方法 &amp;#39;&amp;#39;&amp;#39; yes_votes = 42_573_651 total_votes = 83_637_912 percentage = yes_votes / total_votes print(&amp;#39;{:-9} YES votes {:2.</description></item><item><title>异常处理</title><link>https://wangy325.github.io/zh/docs/misc/py/7_try_excep_finally/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/misc/py/7_try_excep_finally/</guid><description>&amp;#34;&amp;#34;&amp;#34; Author: wangy325 Date: 2024-07-16 21:07:13 Description: 异常的处理和抛出, else语句, finally语句, 异常组 &amp;#34;&amp;#34;&amp;#34; class B(Exception): pass class C(B): pass class D(C): pass for els in [B, C, D]: try: raise els except D: print(&amp;#39;D&amp;#39;) except C: print(&amp;#39;C&amp;#39;) except B: print(&amp;#39;B&amp;#39;) &amp;#39;&amp;#39;&amp;#39; 展示了异常的传递和匹配: 抛出的异常是exception捕获异常的子类可以匹配上, 反之不行 这很好理解啊 `raise`语句相当于主动抛出异常 `else`子句只有在try语句没有发生异常时才执行. 所以, `else`语句可以避免意外捕获一些非try块引发的异常. &amp;#39;&amp;#39;&amp;#39; a, b = 1, &amp;#39;2&amp;#39; try: c = a + b except TypeError as e: print(f&amp;#39;{e.__class__}: {e} &amp;#39;) else: print(f&amp;#39;else block: {c}&amp;#39;) # But, how about a exception occurs in else subsentence?</description></item><item><title>命名空间与作用域</title><link>https://wangy325.github.io/zh/docs/misc/py/8_scope/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/misc/py/8_scope/</guid><description>&amp;#34;&amp;#34;&amp;#34; Author: wangy325 Date: 2024-07-17 19:24:01 Description: 作用域 &amp;#34;&amp;#34;&amp;#34; def __scope_test(): def do_local(): # 内层局部作用域 spam = &amp;#39;local spam&amp;#39; def do_nonlocal(): # 使用nonlocal可以改变外层变量对spam的绑定 nonlocal spam spam = &amp;#39;nonlocal spam&amp;#39; def do_global(): # 使用global改变全局作用域对spam的绑定 global spam spam = &amp;#39;global spam&amp;#39; # 函数内局部作用域 spam = &amp;#39;spam&amp;#39; do_local() print(&amp;#39;After local assignment: &amp;#39;, spam) do_nonlocal() print(&amp;#39;After nonlocal assignment: &amp;#39;, spam) do_global() print(&amp;#39;After global assignment: &amp;#39;, spam) __scope_test() # 在当前模块的全局作用域访问 spam # 如果没有在局部使用global声明，你看这里打印spam报不报错就完了 print(&amp;#34;In global scope: &amp;#34;, spam)</description></item><item><title>类</title><link>https://wangy325.github.io/zh/docs/misc/py/9_class/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/misc/py/9_class/</guid><description>&amp;#34;&amp;#34;&amp;#34; Author: wangy325 Date: 2024-07-18 16:28:29 Description: 类 1) 作用域和命名空间 scope.py 2) Class对象 3) 实例对象 4) 方法对象 5) 类变量与实例变量 6) 继承 7) 多继承 8) 变量要&amp;#34;私有&amp;#34; 9) 迭代器与生成器 &amp;#34;&amp;#34;&amp;#34; class EmptyError(BaseException): pass class MyClass: # 类变量 (Java静态域) property = &amp;#39;MyClass\&amp;#39;s property&amp;#39; trick = [] # 构造器 def __init__(self, *args) -&amp;gt; None: # 实例变量(Java私有域) self.data = [] if args is not None and len(args) &amp;gt; 0: self.data.append(args) self.size = len(self.data) # 它既是&amp;#39;函数&amp;#39;, 也是&amp;#39;方法对象&amp;#39; def add(self, e): self.</description></item><item><title>闭包与装饰器</title><link>https://wangy325.github.io/zh/docs/misc/py/10_decoration/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/misc/py/10_decoration/</guid><description>&amp;#34;&amp;#34;&amp;#34; Author: wangy325 Date: 2024-07-22 00:25:10 Description: 闭包(closure)与装饰器(注解 decorator) &amp;#34;&amp;#34;&amp;#34; import datetime import time from contextlib import contextmanager # 闭包 closure # 闭包是一个特殊的函数 # 闭包有一个&amp;#39;内嵌&amp;#39;函数 # 闭包返回这个内嵌函数 # 内置函数可以访问外部的函数的变量 # 以下用闭包解一个一元一次方程 a*x + b = y def liner(a, b): def coordinate(x): return a * x + b return coordinate # 3x + 4 = ? f = liner(3, 4) # 3 * 2 + 4 = ? print(f(2)) # 所以闭包就等价于 g = (liner(3, 4)(x) for x in range(2, 3)) for e in g: print(e) # ############# # # 装饰器 # # ############# # &amp;#39;&amp;#39;&amp;#39; 装饰器是python的一种语法糖 使用@开头, 类似于Java的注解 装饰器的作用, 很强 可以改变方法的行为, 而不直接修改方法的代码 可以实现类似AOP的功能 &amp;#39;&amp;#39;&amp;#39; # 装饰器应用场景： # • 日志记录： 在函数执行之前和之后添加日志记录。 # • 计时器： 记录函数执行时间。 # • 权限控制： 检查用户权限，只有满足条件才能执行函数。 # • 缓存： 缓存函数的返回值，避免重复计算。 # • 异常处理： 在函数执行过程中捕获并处理异常。 # 装饰器的基本写法 def timer(func): def wrapper(*args, **kwargs): start = time.</description></item><item><title>装饰器2</title><link>https://wangy325.github.io/zh/docs/misc/py/11_decoration_2/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/misc/py/11_decoration_2/</guid><description>&amp;#34;&amp;#34;&amp;#34; Author: wangy325 Date: 2024-07-24 10:20:20 Description: 介绍python内建的装饰器和更多内容 &amp;#34;&amp;#34;&amp;#34; # 以下是python标准装饰器 # ########################################## # # @property 可以将方法转换为属性访问 # # @staticmethod 定义静态方法 # # @classmethod 定义类方法 # # @abstractmethod 定义抽象方法 # # @dataclass 定义数据类 # # ########################################## # class MyClass: __annotations__ = { &amp;#39;name&amp;#39;: str, &amp;#39;age&amp;#39;: int } def __init__(self, name: str, age: int): self._name = name self.age = age @property def name(self): return self._name @staticmethod def add(x, y): &amp;#34;&amp;#34;&amp;#34; 静态方法不包含隐式参数cls 所以可以处理任何业务 一般用来处理和类相关, 但是又不需要访问类的变量和方法的操作 :param x: int :param y: int :return: val of x plus y &amp;#34;&amp;#34;&amp;#34; return x + y @classmethod def get_instance(cls): &amp;#34;&amp;#34;&amp;#34; 类方法和普通方法不一样, 普通方法默认包含隐含参数self, 代表实例 类方法默认包含隐含参数cls, 代表类 :return: 一个实例 &amp;#34;&amp;#34;&amp;#34; return cls(&amp;#39;anna&amp;#39;, 18) @classmethod def from_dict(cls, data: dict): return cls(data[&amp;#39;name&amp;#39;], data[&amp;#39;age&amp;#39;]) # 直接访问类方法 instance = MyClass.</description></item><item><title>使用Pythonanywhere托管Telegram机器人</title><link>https://wangy325.github.io/zh/posts/15_%E4%BD%BF%E7%94%A8PythonAnywhere%E6%89%98%E7%AE%A1%E7%94%B5%E6%8A%A5%E6%9C%BA%E5%99%A8%E4%BA%BA/</link><pubDate>Mon, 08 Jul 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/15_%E4%BD%BF%E7%94%A8PythonAnywhere%E6%89%98%E7%AE%A1%E7%94%B5%E6%8A%A5%E6%9C%BA%E5%99%A8%E4%BA%BA/</guid><description>&lt;p>基于Coze的收费策略，在上面免费使用Gemini的可能性不大了(每日20次&lt;code>gemini-1.5-flash&lt;/code>请求)。于是尝试看看，是否可以自己接入并部署玩玩看。&lt;/p>
&lt;p>GitHub上有关Telegram机器人的项目不少，并且使用python并接入google Gemini AI的也不在少数。随即
 &lt;a href="https://github.com/H-T-H/Gemini-Telegram-Bot.git">clone&lt;/a>了一个，查看文档之后，便可上手。&lt;/p></description></item></channel></rss>