<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on Endless River</title><link>https://wangy325.github.io/zh/</link><description>Recent content in Home on Endless River</description><generator>Hugo</generator><language>zh</language><atom:link href="https://wangy325.github.io/zh/index.xml" rel="self" type="application/rss+xml"/><item><title>引论</title><link>https://wangy325.github.io/zh/docs/note/course/operating_system_peking/1_intro/</link><pubDate>Wed, 03 Jul 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/course/operating_system_peking/1_intro/</guid><description>&lt;h2 id="1-操作系统的定义和作用">
 1 操作系统的定义和作用
 &lt;a class="anchor" href="#1-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%ae%9a%e4%b9%89%e5%92%8c%e4%bd%9c%e7%94%a8">#&lt;/a>
&lt;/h2>
&lt;h3 id="11-操作系统定义">
 1.1 操作系统定义
 &lt;a class="anchor" href="#11-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%ae%9a%e4%b9%89">#&lt;/a>
&lt;/h3>
&lt;p>操作系统是计算机中的一个系统软件，是一系列程序模块的集合。&lt;/p>
&lt;ul>
&lt;li>它们能尽可能以&lt;strong>有效&lt;/strong> 、&lt;strong>合理&lt;/strong>的方式组织和管理计算机的软硬件资源；&lt;/li>
&lt;li>合理地组织计算机的工作流程，控制程序的执行并向用户提供各种服务功能；&lt;/li>
&lt;li>使得用户更加灵活、方便的使用计算机，使整个计算机系统高效运行；&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>有效：指系统效率，资源利用率。如cpu利用率是否充足，I/O设备是否忙碌等。&lt;/p>
&lt;p>合理：软硬件资源的管理是否公平合理。&lt;/p>
&lt;/blockquote></description></item><item><title>流程控制语句</title><link>https://wangy325.github.io/zh/docs/note/pys/1_flow_control/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/pys/1_flow_control/</guid><description/></item><item><title>命令模式</title><link>https://wangy325.github.io/zh/docs/craft/design_pattern/behaviour/1_command/</link><pubDate>Fri, 29 Mar 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/design_pattern/behaviour/1_command/</guid><description>&lt;h2 id="命令模式">
 命令模式
 &lt;a class="anchor" href="#%e5%91%bd%e4%bb%a4%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>命令模式将&amp;quot;请求&amp;quot;封装成（命令）对象，&lt;em>以便使用不同的请求、队列或者日志来参数化其他对象&lt;/em>。
命令模式也支持&lt;strong>撤销&lt;/strong>的操作。&lt;/p>
&lt;blockquote>
&lt;p>命令模式是一种行为设计模式，它可将请求转换为一个包含与请求相关的所有信息的独立对象。
该转换让你能根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，且能实现可撤销操作。&lt;/p>
&lt;/blockquote></description></item><item><title>单例模式</title><link>https://wangy325.github.io/zh/docs/craft/design_pattern/creation/1_singleton/</link><pubDate>Thu, 28 Mar 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/design_pattern/creation/1_singleton/</guid><description>&lt;h2 id="单例模式">
 单例模式
 &lt;a class="anchor" href="#%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>by Head First 设计模式&lt;/p>
&lt;blockquote>
&lt;p>单例模式确保一个类只有一个实例，并且提供一个全局访问点。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>by Dive into Design Patterns&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Singleton&lt;/strong> is a &lt;em>creational design pattern&lt;/em> that lets you ensure
that a class has only one instance, while providing a global
access point to this instance.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul></description></item><item><title>同余定理与二进制补码</title><link>https://wangy325.github.io/zh/docs/craft/algo/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/</link><pubDate>Fri, 14 Oct 2022 10:01:23 +0800</pubDate><guid>https://wangy325.github.io/zh/docs/craft/algo/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/</guid><description>&lt;p>我们知道，计算机使用2的补码（&lt;em>Two&amp;rsquo;s complements&lt;/em>）来表示负数。这样有一个好处：可以使用同一种运算规则来处理正负数的运算，否则，二进制的正数和负数相加，将会得到错误的结果。为了处理这个讹误，必须为负数设计一套“加法器”。关于这一部分的讨论，参照
 &lt;a href="https://ruanyifeng.com/blog/2009/08/twos_complement.html">关于2的补码&lt;/a>。&lt;/p>
&lt;p>而补码使正负数使用同一套“加法器/乘法器”规则，实际上利用了同余运算的性质。&lt;/p></description></item><item><title>Java内存区域详解(转)</title><link>https://wangy325.github.io/zh/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/</guid><description>&lt;blockquote>
&lt;p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;h1 id="1-概述">
 1 概述
 &lt;a class="anchor" href="#1-%e6%a6%82%e8%bf%b0">#&lt;/a>
&lt;/h1>
&lt;p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。&lt;/p></description></item><item><title>redis必知必会(转)</title><link>https://wangy325.github.io/zh/docs/craft/db/redis/redis-all/</link><pubDate>Tue, 24 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/redis/redis-all/</guid><description>&lt;p>简单来说 &lt;strong>Redis 就是一个使用 C 语言开发的数据库&lt;/strong>，不过与传统数据库不同的是 &lt;strong>Redis 的数据是存在内存中的&lt;/strong> ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。&lt;/p></description></item><item><title>线程与任务(一)</title><link>https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_1/</link><pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_1/</guid><description>&lt;p>&lt;strong>并发&lt;/strong>的本质是多个线程同时处理某个任务&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，&lt;del>不同于进程&lt;/del>，线程可以访问同一共享资源（临界资源），当程序不够健壮时，使用多线程就可能带来问题，这是要反复讨论并发的原因之一。&lt;/p>
&lt;p>在Java中，必须明白一点：线程由Thread类启动，但Thread类并不执行任何操作，&lt;strong>它只是驱动赋予它的任务&lt;/strong>。因此将&lt;strong>线程与任务&lt;/strong>的概念区分开，有利于理解并发。&lt;/p>
&lt;p>实际上，开发过程中线程与任务（的联系）被隔离的更加明显，往往不需要显式地声明(创建)线程，然后将任务（声明任务是必须的）分配给线程，并由线程负责驱动（ &lt;em>allocate task to thread to execute&lt;/em> ），这一过程通常由&lt;strong>线程池&lt;/strong>完成 。&lt;/p></description></item><item><title>ArrayList</title><link>https://wangy325.github.io/zh/docs/java/collections/1_List_arraylist/</link><pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/collections/1_List_arraylist/</guid><description>&lt;p>&lt;code>ArrayList&lt;/code>是Java集合框架中使用最为频繁的实现，其本质是一个&lt;strong>有序的&lt;/strong>可自由扩容的&lt;strong>对象数组&lt;/strong>。它实现了&lt;code>RandomAccess&lt;/code>这个&lt;strong>标记接口&lt;/strong>，意味着其在随机访问性能上有一定优势。&lt;/p></description></item><item><title>访问权限修饰符</title><link>https://wangy325.github.io/zh/docs/java/basic/1_%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/</link><pubDate>Mon, 13 Apr 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/basic/1_%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/</guid><description>&lt;h1 id="访问权限修饰符">
 访问权限修饰符
 &lt;a class="anchor" href="#%e8%ae%bf%e9%97%ae%e6%9d%83%e9%99%90%e4%bf%ae%e9%a5%b0%e7%ac%a6">#&lt;/a>
&lt;/h1>
&lt;blockquote>
&lt;p>本系列内容主要来自TIJ，Java核心技术卷以及Java SE 8 API&lt;/p>
&lt;/blockquote>
&lt;p>介绍了Java的public、default、protected、private四种访问权限修饰符。&lt;/p></description></item><item><title>SpringBoot使用AOP的简单示例</title><link>https://wangy325.github.io/zh/docs/java/spring/SpringBoot-aop-demo/</link><pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/spring/SpringBoot-aop-demo/</guid><description>&lt;p>有一个cd接口，其实体类用于播放歌曲，同时我们想在播放歌曲的时候记录每个曲目的播放次数。看起来，记录次数这个事和播放曲目是不相干的事情，当然，我们可以在每首歌曲播放完成之后记录，但是更好的办法是使用一个切面，切入到播放方法中，来完成这件事，这样可以减少无关逻辑对代码的侵入。&lt;/p></description></item><item><title>CentOS安装并配置MySQL</title><link>https://wangy325.github.io/zh/docs/craft/db/sql/1_%E5%9C%A8centOS%E4%B8%8A%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmysql%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/sql/1_%E5%9C%A8centOS%E4%B8%8A%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmysql%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>&lt;p>文章介绍了在centOS7上安装mysql数据库服务的配置及简单优化过程。在服务器上安装mysql服务网络上能够找到的资源很多了，因此本文没有作详细介绍，本文的重点在于后续的优化配置方面。&lt;/p></description></item><item><title>操作系统运行环境与机制</title><link>https://wangy325.github.io/zh/docs/note/course/operating_system_peking/2_env_and_logic/</link><pubDate>Wed, 03 Jul 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/course/operating_system_peking/2_env_and_logic/</guid><description>&lt;blockquote class="book-hint info">
 &lt;p>📖 回顾：操作系统的主要工作&lt;/p>
&lt;ul>
&lt;li>程序的执行
启动程序、执行程序以及程序结束的工作&lt;/li>
&lt;li>完成与体系结构相关的工作&lt;/li>
&lt;li>完成应用程序所需的共性服务（提供各种基本服务，读盘、申请内存等等）&lt;/li>
&lt;li>性能、安全、健壮等问题&lt;/li>
&lt;/ul>
&lt;p>应用程序&lt;/p>
&lt;p>———————— 虚拟机器界面 &amp;mdash;&amp;gt; 操作系统运行机制（系统调用）&lt;/p>
&lt;p>操作系统&lt;/p>
&lt;p>———————— 物理机器界面 &amp;mdash;&amp;gt; 操作系统运行环境（CPU状态、中断/异常机制）&lt;/p>

&lt;/blockquote>

&lt;hr></description></item><item><title>列表（list）</title><link>https://wangy325.github.io/zh/docs/note/pys/2_data_list/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/pys/2_data_list/</guid><description/></item><item><title>工厂模式</title><link>https://wangy325.github.io/zh/docs/craft/design_pattern/creation/2_factory/</link><pubDate>Tue, 26 Mar 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/design_pattern/creation/2_factory/</guid><description>&lt;h3 id="工厂模式">
 工厂模式
 &lt;a class="anchor" href="#%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>by Head First 设计模式&lt;/p>
&lt;blockquote>
&lt;p>工厂方法模式定义了一个创建对象的接口，但是由子类决定要创建的对象是哪一个。工厂方法把类的实例化推迟到
子类。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>by Dive into Design Patterns&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Factory Method&lt;/strong> is a creational design pattern that provides an interface for creating
objects in a superclass, but allows subclasses to alter the type of objects that will be
created.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>工厂模式指定工厂仅仅能创建特定类型的产品。&lt;/p>
&lt;/blockquote></description></item><item><title>装饰者模式</title><link>https://wangy325.github.io/zh/docs/craft/design_pattern/structure/3_decorator/</link><pubDate>Thu, 21 Mar 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/design_pattern/structure/3_decorator/</guid><description>&lt;h2 id="装饰者模式">
 装饰者模式
 &lt;a class="anchor" href="#%e8%a3%85%e9%a5%b0%e8%80%85%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>by Head First 设计模式:&lt;/p>
&lt;blockquote>
&lt;p>动态地将责任附加到对象上。若要拓展功能，装饰者模式提供了比继承更有弹性的替代方案。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>by Dive into Design Patterns:&lt;/p>
&lt;blockquote>
&lt;p>Also known as &lt;em>Wrapper&lt;/em>&lt;/p>
&lt;p>Decorator is a structural design pattern that lets you attach new behaviors
to objects by placing these objects inside special wrapper objects that
contain the behaviors.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul></description></item><item><title>观察者模式</title><link>https://wangy325.github.io/zh/docs/craft/design_pattern/behaviour/2_observer/</link><pubDate>Fri, 08 Mar 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/design_pattern/behaviour/2_observer/</guid><description>&lt;h2 id="观察者模式">
 观察者模式
 &lt;a class="anchor" href="#%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>by Head First 设计模式
&lt;blockquote>
&lt;p>在对象之间建立一对多的依赖，这样一来，当一个对象的状态改变，依赖它的对象都会收到通知，并且自动更新。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>by Dive into Design Patterns:
&lt;blockquote>
&lt;p>&lt;em>Also Known as: Event-Subscriber, Listener&lt;/em>&lt;/p>
&lt;p>Observer is a behavioral design pattern that lets you define a &lt;em>subscription mechanism&lt;/em>
to notify multiple objects about any events that happen to the object they’re observing.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul></description></item><item><title>策略模式</title><link>https://wangy325.github.io/zh/docs/craft/design_pattern/behaviour/3_strategy/</link><pubDate>Thu, 07 Mar 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/design_pattern/behaviour/3_strategy/</guid><description>&lt;h2 id="策略模式">
 策略模式
 &lt;a class="anchor" href="#%e7%ad%96%e7%95%a5%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>by Head First 设计模式:&lt;/p>
&lt;blockquote>
&lt;p>策略模式定义了算法族，分别封装起来，让他们之间可以互相替换。此模式让算法的&lt;strong>变化&lt;/strong>独立于使用算法的&amp;quot;客户&amp;quot;。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>by Dive into Design Patterns:&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Strategy&lt;/strong> is a behavioral design pattern that lets you define a family of algorithms,
put each of them into a separate class, and make their objects interchangeable.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul></description></item><item><title>移位运算</title><link>https://wangy325.github.io/zh/docs/craft/algo/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/</link><pubDate>Sat, 15 Oct 2022 09:01:23 +0800</pubDate><guid>https://wangy325.github.io/zh/docs/craft/algo/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/</guid><description>&lt;p>位运算是直接操作内存中的二进制数据。因此运算效率比常规的四则运算高出不少。&lt;/p></description></item><item><title>在SpringBoot中使用MessageSource</title><link>https://wangy325.github.io/zh/docs/note/translations/use-springboot-messagesource/</link><pubDate>Sat, 20 Feb 2021 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/translations/use-springboot-messagesource/</guid><description>&lt;blockquote>
&lt;p>&lt;span id="hook">几个说明&lt;/span>：&lt;/p>
&lt;ol>
&lt;li>&lt;del>properties配置文件中，&lt;code>spring.messages.basename&lt;/code>&lt;strong>必须&lt;/strong>要加classpath前缀。如 &lt;code>spring.messages.basename=classpath:i18n/messages&lt;/code>&lt;/del>；&lt;/li>
&lt;li>&lt;del>必须要手动配置&lt;code>MessageSource&lt;/code>，springboot不会自动配置之&lt;/del>；&lt;/li>
&lt;li>如果使用&lt;code>MessageSource.getMessage()&lt;/code>方法，第一个参数的引用形式为&lt;code>&amp;quot;code&amp;quot;&lt;/code>，而不是&lt;code>&amp;quot;{code}&amp;quot;&lt;/code>或者&lt;code>&amp;quot;${code}&amp;quot;&lt;/code>。如messageSource.getMessage(&amp;ldquo;test.msg&amp;rdquo;, null, &lt;del>Locale.getDefault()&lt;/del>)；&lt;/li>
&lt;li>在配置&lt;code>LocalValidatorFactoryBean&lt;/code>之后，才可以在&lt;code>javax.validation.constraints&lt;/code>包下的注解（&lt;code>@Size&lt;/code>，&lt;code>@NotNull&lt;/code>&amp;hellip;）下的&lt;em>&lt;strong>message&lt;/strong>&lt;/em>属性中使用&lt;code>&amp;quot;{code}&amp;quot;&lt;/code>的形式声明校验提示信息。如
&lt;code>@NotNull(message = &amp;quot;{leftTime.not.null}&amp;quot;)&lt;/code>；&lt;/li>
&lt;li>springMVC的locale配置和JVM的locale配置不一样，在application.properties中配置的&lt;code>spring.mvc.locale=zh_CN&lt;/code>实际上配置的是&lt;code>WebMvcProperties&lt;/code>，在获取消息时，locale信息应该使用&lt;code>webMvcProperties.getLocale()&lt;/code>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>获取&lt;strong>而不是&lt;/strong>使用&lt;code>Locale.getDefault()&lt;/code>获取。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;hr>
&lt;p>MessageSource is a powerful feature available in Spring applications. This helps application developers handle various complex scenarios with writing much extra code, such as environment-specific configuration, internationalization or configurable values.&lt;/p>
&lt;p>One more scenario could be modifying the default validation messages to more user-friendly/custom messages.&lt;/p>
&lt;p>In this tutorial, we&amp;rsquo;ll see how to configure and manage custom validation MessageSource in the application using Spring Boot.&lt;/p></description></item><item><title>JVM垃圾回收概要(转)</title><link>https://wangy325.github.io/zh/docs/java/jvm/java-gc/</link><pubDate>Wed, 25 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/jvm/java-gc/</guid><description>&lt;h2 id="本节常见面试题">
 本节常见面试题
 &lt;a class="anchor" href="#%e6%9c%ac%e8%8a%82%e5%b8%b8%e8%a7%81%e9%9d%a2%e8%af%95%e9%a2%98">#&lt;/a>
&lt;/h2>
&lt;p>问题答案在文中都有提到&lt;/p>
&lt;ul>
&lt;li>如何判断对象是否死亡（两种方法）。&lt;/li>
&lt;li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。&lt;/li>
&lt;li>如何判断一个常量是废弃常量&lt;/li>
&lt;li>如何判断一个类是无用的类&lt;/li>
&lt;li>垃圾收集有哪些算法，各自的特点？&lt;/li>
&lt;li>HotSpot 为什么要分为新生代和老年代？&lt;/li>
&lt;li>常见的垃圾回收器有哪些？&lt;/li>
&lt;li>介绍一下 CMS,G1 收集器。&lt;/li>
&lt;li>Minor Gc 和 Full GC 有什么不同呢？&lt;/li>
&lt;/ul></description></item><item><title>线程与任务(二)</title><link>https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/</link><pubDate>Fri, 15 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/</guid><description>&lt;p>
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_1/">第一篇文章&lt;/a>中，讨论了线程与任务的概念，以及利用任务（&lt;em>Runnable接口&lt;/em>）来创建线程。&lt;/p>
&lt;p>同时，讨论了线程的生命周期。此外，介绍了线程的优先级以及守护线程这两个实用性不高的概念。&lt;/p>
&lt;p>最后，讨论了线程的中断状态这个概念。线程的中断状态以及如何响应中断，对于理解线程的运行机制很重要。&lt;/p>
&lt;p>这一篇，继续讨论几个线程相关的概念，包括：&lt;/p>
&lt;ul>
&lt;li>线程的让步&lt;/li>
&lt;li>等待线程加入&lt;/li>
&lt;li>自管理线程&lt;/li>
&lt;li>处理线程的异常&lt;/li>
&lt;/ul></description></item><item><title>LinkedList</title><link>https://wangy325.github.io/zh/docs/java/collections/1_List_linkedlist/</link><pubDate>Wed, 29 Apr 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/collections/1_List_linkedlist/</guid><description>&lt;p>&lt;code>LinkedList&lt;/code>是基于&lt;strong>双向链表&lt;/strong>实现的有序集合，&lt;del>其不能像ArrayList一样通过索引(&lt;em>index&lt;/em>)访问元素&lt;/del>，同时&lt;code>LinkedList&lt;/code>还实现了&lt;code>Deque&lt;/code>接口，意味着&lt;code>LinkedList&lt;/code>可以&lt;strong>实现双端队列的操作&lt;/strong>。&lt;/p></description></item><item><title>static关键字</title><link>https://wangy325.github.io/zh/docs/java/basic/2_static%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/basic/2_static%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>&lt;h1 id="static关键字">
 static关键字
 &lt;a class="anchor" href="#static%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>
&lt;/h1>
&lt;p>static关键字意为“静态的”，其语义可以理解为“类的对象”(不要理解为Class对象)，即不需要对象实例，可以直接通过&lt;code>类名.字段名&lt;/code>的形式直接访问。&lt;/p></description></item><item><title>Redis Sentinel高可用实现</title><link>https://wangy325.github.io/zh/docs/craft/db/redis/build-redis-sentinel/</link><pubDate>Wed, 14 Aug 2019 16:01:23 +0800</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/redis/build-redis-sentinel/</guid><description>&lt;p>Redis 
 &lt;a href="https://raw.githubusercontent.com/antirez/redis/2.8/00-RELEASENOTES">v2.8&lt;/a> 之后提供了高可用实现&lt;code>Redis Sentinel&lt;/code>，实现了&lt;strong>主从复制&lt;/strong>以及&lt;del>被动&lt;/del>&lt;strong>主备切换&lt;/strong>。
 &lt;a href="https://raw.githubusercontent.com/antirez/redis/3.0/00-RELEASENOTES">v3.0&lt;/a> 之后提供了分布式实现&lt;code>Redis Cluster&lt;/code>。&lt;/p>
&lt;p>本文讨论的是使用Sentinel搭建Redis高可用服务。&lt;/p>
&lt;blockquote>
&lt;p>If all redis and sentinel instances were deployed in same host, you just build a fake redis-sentinel &lt;em>High-Availability&lt;/em> environment&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>.&lt;/p>
&lt;/blockquote></description></item><item><title>MySQL字符串处理函数</title><link>https://wangy325.github.io/zh/docs/craft/db/sql/2_MySQL%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/sql/2_MySQL%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/</guid><description>&lt;p>本文介绍了mysql的几个方便的字符串处理函数，通常用于简单的查询结果处理。适用在mapper.xml的语句标签中对数据库字段数据进行简单的处理。&lt;/p></description></item><item><title>进程和线程模型</title><link>https://wangy325.github.io/zh/docs/note/course/operating_system_peking/3_processes_and_threads/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/course/operating_system_peking/3_processes_and_threads/</guid><description>进程模型 # 多道程序设计 # MultiProgramming：多个程序同时进入内存并运行，提高操作系统效率。并发环境。
多个虚拟（逻辑）程序计数器 &amp;mdash;&amp;gt; 物理计数器
进程的概念以及进程控制块 # 进程 # Process：进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位。
是程序的一次执行过程 是正在运行的程序的抽象 将一个CPU变幻成多个虚拟的CPU （是CPU的抽象） 系统资源以进程为单位分配，如内存、文件、独立的地址空间&amp;hellip;&amp;hellip; 进程控制块(PCB) # PCB: Process Control Block
又称进程描述符、进程属性 操作系统用于管理控制进程的一一个专门数据结构 不同操作系统，对PCB的实现可能不同，但是其功能相同。
Linux中叫task_sturct
Windows中叫EPROCESS，KPROCESS，PEB
记录进程的各种属性，描述进程的动态变化过程 PCB是系统感知进程存在的唯一标志 &amp;gt;进程与PCB是一一 对应
进程表: 所有进程的PCB集合。在内存的固定区域，大小固定，所以存储的PCB信息也是有限的，这就是操作系统的并发度。
PCB存储了哪些信息？
1） 进程描述信息
进程标识符(process ID)，唯一，通常是一个整数 进程名，通常基于可执行文件名，不唯一 用户标识符(user ID) 进程组关系 2）进程控制信息
当前状态 优先级(priority) 代码执行入口地址 程序的磁盘地址 运行统计信息(执行时间、页面调度)进程间同步和通信 进程的队列指针 进程的消息队列指针 3）所拥有的资源和使用情况
虚拟地址空间的状况 打开文件列表 4）CPU现场信息
寄存器值（通用寄存器、程序计数器PC、程序状态字PSW、栈指针） 指向该进程页表的指针 还可以从下面三个维度来看看PCB存储的信息
进程管理 存储管理 文件管理 进程的状态及转换、进程队列 # 进程的三种基本状态 # 运行态（Running）：占有CPU，并在CPU上运行 就绪态（Ready）：已经具备运行的条件，但没有空闲CPU，故暂时不能运行 等待态（Waiting/Blocked）：因等待某一事件而暂时不能运行（如等待磁盘结果）。也叫做阻塞态、封锁态或睡眠态 进程的状态转换 # 进程3状态转换示意图 其他线程状态 # 1）创建（New）：</description></item><item><title>字符串，元组和字典</title><link>https://wangy325.github.io/zh/docs/note/pys/3_data_str/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/pys/3_data_str/</guid><description/></item><item><title>适配器模式</title><link>https://wangy325.github.io/zh/docs/craft/design_pattern/structure/2_adaptor/</link><pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/design_pattern/structure/2_adaptor/</guid><description>&lt;h2 id="适配器模式">
 适配器模式
 &lt;a class="anchor" href="#%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>适配器模式将一个类的接口，转换成客户期望的另一个接口。
适配器模式可以让原本接口不兼容的类可以合作无间。&lt;/p></description></item><item><title>抽象工厂模式</title><link>https://wangy325.github.io/zh/docs/craft/design_pattern/creation/3_abstract_factory/</link><pubDate>Tue, 26 Mar 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/design_pattern/creation/3_abstract_factory/</guid><description>&lt;h2 id="抽象工厂模式">
 抽象工厂模式
 &lt;a class="anchor" href="#%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>by Head First 设计模式&lt;/p>
&lt;blockquote>
&lt;p>抽象工厂模式提供了一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。
简而言之，抽象工厂可以创建一群对象，而不单单只创建一种对象。&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>by Dive into Design Patterns&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Abstract Factory&lt;/strong> is a creational design pattern that lets you
produce families of related objects without specifying their
concrete classes.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;/ul></description></item><item><title>异或运算</title><link>https://wangy325.github.io/zh/docs/craft/algo/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</link><pubDate>Fri, 14 Oct 2022 12:01:23 +0800</pubDate><guid>https://wangy325.github.io/zh/docs/craft/algo/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/</guid><description>&lt;p>异或运算(&lt;em>exclusive or&lt;/em>)又记作&lt;em>XOR&lt;/em>，一般用插入符号(&lt;em>caret&lt;/em>)&lt;code>^&lt;/code>表示，其可以看到是更加单纯的或运算(|)。我们知道，或运算的规则是：&lt;/p>
&lt;ul>
&lt;li>a=1，b=1，a|b=1 ①&lt;/li>
&lt;li>a，b任意一个为1，a|b=1 ②&lt;/li>
&lt;/ul>
&lt;p>异或运算则是去除了或运算中的规则①，即只有a、b相异时，结果才为真，其他情形都为假。因此异或运算的真值表为：&lt;/p>
&lt;pre tabindex="0">&lt;code>0^0 = 0
0^1 = 1
1^0 = 1
1^1 = 0
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>与0异或，其值不变；与1异或，相当于取反。&lt;/p>
&lt;/blockquote>
&lt;p>异或运算有一些特殊的性质，利用这些性质，可以解决特定的问题。这也是本文所要讨论的重点。&lt;/p></description></item><item><title>使用docker镜像快速搭建redis集群开发环境</title><link>https://wangy325.github.io/zh/docs/craft/db/redis/deploy-redis-cluster-with-docker/</link><pubDate>Thu, 25 Aug 2022 16:01:23 +0800</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/redis/deploy-redis-cluster-with-docker/</guid><description>&lt;h2 id="准备镜像">
 准备镜像
 &lt;a class="anchor" href="#%e5%87%86%e5%a4%87%e9%95%9c%e5%83%8f">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>docker&lt;/code>以及&lt;code>docker-compose&lt;/code>的安装以及加速镜像的配置不在此处说明。windows系统上直接安装客户端即可完成docker及docker-compose的安装。在centOS 8中安装docker服务以及docker-compose可以参考下面的文章：&lt;/p>
&lt;ul>
&lt;li>
 &lt;a href="https://zhuanlan.zhihu.com/p/286845061">在centOS 8中安装docker&lt;/a>&lt;/li>
&lt;li>
 &lt;a href="https://www.cnblogs.com/51ma/p/15641138.html">在contOS 8中安装docker-compose&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>运行如下命令检查docker和docker-compose的安装情况：&lt;/p></description></item><item><title>在SpringBoot项目中使用MockMvc进行接口测试</title><link>https://wangy325.github.io/zh/docs/java/spring/%E5%9C%A8SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8MockMvc%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/spring/%E5%9C%A8SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8MockMvc%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/</guid><description>&lt;p>现在流行在项目中使用
 &lt;a href="https://swagger.io">swagger&lt;/a>对接口进行测试，这确实很方便、直观。&lt;/p>
&lt;p>但是MockMvc作为spring-test包中指定的测试框架，在没有使用swagger的项目中，使用其进行测试是很好的选择。&lt;/p></description></item><item><title>资源访问受限--引论</title><link>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_1/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_1/</guid><description>&lt;p>在
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_1/">线程与任务&lt;/a>文中，虽然创建了多线程，并且线程之间出现了一些&lt;strong>不可预测&lt;/strong>的CPU调度，但是由于线程之间是&lt;strong>相互隔离&lt;/strong>的——&lt;strong>线程没有访问共同的资源&lt;/strong>，尽管在执行任务的过程可能被CPU剥夺运行权，但是当它们再次获得运行权时对运行结果并没有影响，它们是安全的。&lt;/p>
&lt;blockquote>
&lt;p>实际上，上篇文章通过&lt;code>join()&lt;/code>方法演示了
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/#%e7%ae%80%e5%8d%95%e7%9a%84%e6%97%a0%e9%94%81%e5%90%8c%e6%ad%a5">一种安全访问共享资源的方法&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;p>考虑一种情况，如果&lt;strong>多个线程访问同一资源&lt;/strong>，并对资源内容进行修改，会发生什么情况？&lt;/p>
&lt;p>对于&lt;strong>非原子性&lt;/strong>操作，多线程下会出现&lt;strong>竞争条件&lt;/strong>。例如，对于操作&lt;code>accounts[to] += amount&lt;/code>，可以被拆分为多个CPU指令：&lt;/p>
&lt;ol>
&lt;li>加载accounts[to]到寄存器&lt;/li>
&lt;li>增加amount&lt;/li>
&lt;li>将结果写回acounts[to]&lt;/li>
&lt;/ol>
&lt;p>上述3个步骤中，线程执行到&lt;strong>任一步骤&lt;/strong>时都可能被剥夺运行权。&lt;/p>
&lt;p>如此一来，最后的结果就变得不可预测。&lt;/p></description></item><item><title>Queue</title><link>https://wangy325.github.io/zh/docs/java/collections/2_Queue/</link><pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/collections/2_Queue/</guid><description>&lt;p>Queue（队列），实际开发过程中，&lt;del>在单线程环境下&lt;/del>使用的并不多，Queue作为集合框架中重要组成似乎习惯性被忽略。队列总是先持有元素，再处理元素&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>
 &lt;img src="https://wangy325.github.io/img//collections/Queue.png" alt="J7NBrQ.png" />&lt;/p>
&lt;p style="color:grey;text-align:center;font-size:.8rem;font-style:italic">Queue继承关系简图&lt;/p></description></item><item><title>传值还是传引用</title><link>https://wangy325.github.io/zh/docs/java/basic/3_%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/</link><pubDate>Wed, 15 Apr 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/basic/3_%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/</guid><description>&lt;h1 id="传值还是传引用">
 传值还是传引用
 &lt;a class="anchor" href="#%e4%bc%a0%e5%80%bc%e8%bf%98%e6%98%af%e4%bc%a0%e5%bc%95%e7%94%a8">#&lt;/a>
&lt;/h1>
&lt;p>Java语言设计总是&lt;strong>按值调用&lt;/strong>&lt;/p>
&lt;blockquote>
&lt;p>按值调用：方法接收的是调用者提供的值&lt;/p>
&lt;p>按引用调用：方法接收的是调用者提供的变量地址&lt;/p>
&lt;/blockquote>
&lt;p>一个方法可以修改传递引用所对应的变量值，但是不能修改传递值所对应的变量值。&lt;/p></description></item><item><title>函数式编程</title><link>https://wangy325.github.io/zh/docs/note/pys/4_func/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/pys/4_func/</guid><description/></item><item><title>模板方法模式</title><link>https://wangy325.github.io/zh/docs/craft/design_pattern/behaviour/4_template_method/</link><pubDate>Tue, 02 Apr 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/design_pattern/behaviour/4_template_method/</guid><description>&lt;h2 id="模板方法模式">
 模板方法模式
 &lt;a class="anchor" href="#%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤
延迟到子类中。模板方法可以使得子类在不改变算法结构的前提
下，重新 定义算法的某些步骤。&lt;/p></description></item><item><title>外观模式</title><link>https://wangy325.github.io/zh/docs/craft/design_pattern/structure/4_%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/design_pattern/structure/4_%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid><description>&lt;h2 id="外观模式facade">
 外观模式（Facade）
 &lt;a class="anchor" href="#%e5%a4%96%e8%a7%82%e6%a8%a1%e5%bc%8ffacade">#&lt;/a>
&lt;/h2>
&lt;p>外观模式提供了一个统一的（简单）接口，用来访问子
系统中的一群接口。外观定义了一个高层接口，让系统更
容易使用。&lt;/p></description></item><item><title>位运算的小技巧</title><link>https://wangy325.github.io/zh/docs/craft/algo/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</link><pubDate>Sun, 16 Oct 2022 09:01:23 +0800</pubDate><guid>https://wangy325.github.io/zh/docs/craft/algo/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid><description>&lt;p>在
 &lt;a href="https://wangy325.github.io/zh/docs/craft/algo/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/">移位运算&lt;/a>和
 &lt;a href="https://wangy325.github.io/zh/docs/craft/algo/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/">异或运算&lt;/a>中讨论了这两种位运算。计算机中还有一些其他的位运算，它们比较简单，但也还有一些巧妙的作用，本文将逐一介绍它们。&lt;/p></description></item><item><title>建造者模式</title><link>https://wangy325.github.io/zh/docs/craft/design_pattern/creation/4_builder/</link><pubDate>Sun, 13 Mar 2022 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/design_pattern/creation/4_builder/</guid><description>&lt;blockquote>
&lt;p>本文由Gemini AI生成。&lt;/p>
&lt;/blockquote>
&lt;h2 id="建造模式">
 建造模式
 &lt;a class="anchor" href="#%e5%bb%ba%e9%80%a0%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>建造模式是一种创建型设计模式，它将一个复杂对象的构建与其表示分离。它允许你通过一步一步地构建对象来创建不同的表示。&lt;/p></description></item><item><title>Spring声明式事务的使用</title><link>https://wangy325.github.io/zh/docs/java/spring/spring-transaction-propagation/</link><pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/spring/spring-transaction-propagation/</guid><description>&lt;h2 id="1-从transactional注解开始">
 1 从&lt;code>@Transactional&lt;/code>注解开始
 &lt;a class="anchor" href="#1-%e4%bb%8etransactional%e6%b3%a8%e8%a7%a3%e5%bc%80%e5%a7%8b">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>@Transactional&lt;/code>注解是使用spring-transaction的最便捷方式。也是使用Spring框架开发最先接触的内容。&lt;/p>
&lt;p>当你在一个服务的方法上使用&lt;code>@Transactional&lt;/code>注解时，意味着你希望为此方法开启事务支持。如果你的项目成功配置了&lt;strong>数据源&lt;/strong>和&lt;strong>事务管理器&lt;/strong>，Spring会为此方法使用如下默认设置开启事务：&lt;/p></description></item><item><title>事务隔离级别与MVCC</title><link>https://wangy325.github.io/zh/docs/craft/db/sql/4_MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</link><pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/sql/4_MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</guid><description>&lt;!--
~~MySQL事务属于老生常谈的内容了，并不指望这一篇文章将其搞透，本篇文章只是将MySQL事务的外衣扒了，让其看起来不再那么神秘与华丽。有时候，新手总是对“事务”这两个字怀有莫名的恐惧感，因为其藏在MySQL内部，偷偷地工作着，就好像你没有凝视深渊，而深渊却在凝视你。~~
-->
&lt;p>开发过程中，或多或少会碰到需要使用数据库事务的业务场景，而Spring框架提供的能力使得开发者无需过多地关注事务本身，这带来诸多便利，但也带来弊端：开发者只知其貌，而不知其理，一旦Spring框架抛出异常，便往往手足无措。本文简单地介绍了MySQL事务相关的基本概念，使用例证阐述了不同事务隔离级别下MySQL的数据可见性，简单讨论了MySQL如何保证数据一致性。有了这些基本的概念，遇到事务与数据库锁相关的问题时，开发者能够多一点思考。&lt;/p></description></item><item><title>布隆过滤器(转)</title><link>https://wangy325.github.io/zh/docs/craft/db/redis/bloom-filter/</link><pubDate>Mon, 23 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/redis/bloom-filter/</guid><description>&lt;p>海量数据处理以及缓存穿透这两个场景让我认识了 布隆过滤器 ，我查阅了一些资料来了解它，但是很多现成资料并不满足我的需求，所以就决定自己总结一篇关于布隆过滤器的文章。希望通过这篇文章让更多人了解布隆过滤器，并且会实际去使用它！&lt;/p>
&lt;p>下面我们将分为几个方面来介绍布隆过滤器：&lt;/p>
&lt;ol>
&lt;li>什么是布隆过滤器？&lt;/li>
&lt;li>布隆过滤器的原理介绍。&lt;/li>
&lt;li>布隆过滤器使用场景。&lt;/li>
&lt;li>通过 Java 编程手动实现布隆过滤器。&lt;/li>
&lt;li>利用Google开源的Guava中自带的布隆过滤器。&lt;/li>
&lt;li>Redis 中的布隆过滤器。&lt;/li>
&lt;/ol></description></item><item><title>锁和条件</title><link>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_2_%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_2_%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6/</guid><description>&lt;h2 id="可重入锁">
 可重入锁
 &lt;a class="anchor" href="#%e5%8f%af%e9%87%8d%e5%85%a5%e9%94%81">#&lt;/a>
&lt;/h2>
&lt;p>Java SE 5之后提供了位于&lt;code>java.util.concurrent.locks&lt;/code>包下的显式&lt;strong>互斥机制&lt;/strong>——Lock对象（显式锁），Lock对象必须被&lt;strong>显式的创建，锁定和释放&lt;/strong>。&lt;/p>
&lt;p>一般情况下 ，ReentrantLock保护代码块的基本结构是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>myLock.&lt;span style="color:#a6e22e">lock&lt;/span>(); &lt;span style="color:#75715e">// 可重入锁&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 临界区代码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;span style="color:#66d9ef">finally&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> myLock.&lt;span style="color:#a6e22e">unlock&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个结构可以确保同一时间只有&lt;strong>一个线程&lt;/strong>进入临界区( &lt;em>critical section&lt;/em> )，其他线程调用&lt;code>lock()&lt;/code>时会被阻塞，直到第一个线程释放锁。&lt;/p></description></item><item><title>Set</title><link>https://wangy325.github.io/zh/docs/java/collections/3_Set/</link><pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/collections/3_Set/</guid><description>&lt;p>&lt;code>Set&lt;/code>是&lt;strong>不含重复元素的集&lt;/strong>，严格来讲，&lt;code>Set&lt;/code>不允许当&lt;code>e1.equals(e2)&lt;/code>为真时， &lt;em>e1&lt;/em> 和 &lt;em>e2&lt;/em> 同时出现在集合中。&lt;code>Set&lt;/code>最多允许一个&lt;code>null&lt;/code>元素。&lt;/p>
&lt;p>将&lt;strong>可变对象&lt;/strong>置入&lt;code>Set&lt;/code>时需要特别小心，当对象的改动影响到了元素之间的&lt;code>equals()&lt;/code>比较的结果，那么&lt;code>Set&lt;/code>的行为就变得不确定了。因此，&lt;strong>不能将Set本身作为Set的元素&lt;/strong>。&lt;/p></description></item><item><title>final关键字</title><link>https://wangy325.github.io/zh/docs/java/basic/4_final%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/basic/4_final%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>&lt;h1 id="final关键字">
 final关键字
 &lt;a class="anchor" href="#final%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>
&lt;/h1>
&lt;p>不同的使用环境下，&lt;code>final&lt;/code>关键字的含义有细微差别，但通常它指“这是无法改变的”。&lt;/p></description></item><item><title>4个重要的内置函数</title><link>https://wangy325.github.io/zh/docs/note/pys/4_important_funcs/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/pys/4_important_funcs/</guid><description/></item><item><title>MySQL显式锁简单介绍</title><link>https://wangy325.github.io/zh/docs/craft/db/sql/5_%E4%BD%BF%E7%94%A8mysql%E7%9A%84%E8%A1%8C%E9%94%81/</link><pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/sql/5_%E4%BD%BF%E7%94%A8mysql%E7%9A%84%E8%A1%8C%E9%94%81/</guid><description>&lt;p>对于MySQL数据库而言，
 &lt;a href="https://wangy325.github.io/zh/docs/craft/db/sql/4_MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/">事务的隔离级别&lt;/a>在不同程度上保证了数据一致性。&lt;/p>
&lt;p>我们知道，&lt;strong>事务&lt;/strong>的四大特性：原子性、一致性、隔离性、持久性，其中&lt;strong>隔离性&lt;/strong>就是通过&lt;strong>锁机制&lt;/strong>来保证的。&lt;/p>
&lt;blockquote>
&lt;p>另外3个性质，通过MySQL的&lt;code>redo log&lt;/code> 和&lt;code>undo log&lt;/code>来保证。&lt;/p>
&lt;/blockquote>
&lt;p>MySQL对每条SQL语句的执行，都添加了一个隐式事务，言外之意，就是添加了隐式锁。&lt;/p>
&lt;p>除了隐式锁之外，MySQL还可以使用显式锁。&lt;/p>
&lt;p>这是从锁的可见性（或者使用方式）上来区分锁。本文不讨论MySQL的粒度锁（表锁，行锁，页锁）。&lt;/p>
&lt;!-- ~~我们知道，事务能读取到事务开始前就存在的数据，如果事务A需要对某条数据data1进行修改，在事务A还没有提交之前，事务B虽然不能读取到事务A对data1的修改（read committed隔离级别以上），但是能够读取data1原始的数据快照，并且能够再读取到的数据基础上对其进行修改（在事务A提交之后）。~~ --></description></item><item><title>背包问题2例</title><link>https://wangy325.github.io/zh/docs/craft/algo/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</link><pubDate>Fri, 04 Dec 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/algo/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</guid><description>&lt;p>背包问题其实属于&lt;strong>动态规划&lt;/strong>（ &lt;em>Dynamic Programming&lt;/em> ）问题的一种。动态规划的手段是将大问题拆解为多个小问题，小问题解决之后，大问题也就随之而解。&lt;/p></description></item><item><title>synchronized关键字</title><link>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_3_synchronized/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_3_synchronized/</guid><description>&lt;p>自Java 1.0开始，每一个对象都有一个隐式&lt;strong>内部锁&lt;/strong>（ &lt;em>intrinsic lock&lt;/em> ），在Java API Specification中通常被称为&lt;strong>监视器&lt;/strong>（ &lt;em>monitor&lt;/em> ）。这个内部锁由&lt;code>synchronized&lt;/code>关键字提供支持。&lt;code>synchronized&lt;/code>关键字的语义就是“同步的”，这意味着使用这个关键字可以处理共享资源的冲突。&lt;/p>
&lt;p>当访问被&lt;code>synchronized&lt;/code>关键字保护的方法或代码块时，它将检查锁能否获得——&lt;strong>这个锁可以是当前类对象的锁，也可以是一个临时锁&lt;/strong>( &lt;em>ad-hoc lock&lt;/em> )，取决你如何使用，任务执行完成之后会释放锁。&lt;/p>
&lt;p>和&lt;code>ReentrantLock&lt;/code>一样，&lt;code>synchronized&lt;/code>关键字获取的锁也是&lt;strong>独占锁&lt;/strong>，并且也是“可重入”的，某个任务可以多次获得对象的锁，并由计数器维护获得锁的次数，当退出一个方法时，计数器-1，完全退出时，才释放锁，这和可重入锁的机制是一样的。&lt;/p></description></item><item><title>HashMap和TreeMap</title><link>https://wangy325.github.io/zh/docs/java/collections/4_Map_hash_tree_map/</link><pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/collections/4_Map_hash_tree_map/</guid><description>&lt;p>由于&lt;code>Map&lt;/code>的键是&lt;code>Set&lt;/code>，因此使用可变对象作为&lt;code>Map&lt;/code>的key时，&lt;strong>需要覆盖 &lt;em>equals&lt;/em> 和 &lt;em>hashCode&lt;/em> 方法&lt;/strong>，&lt;strong>Map不能使用自身作为key&lt;/strong>。&lt;/p>
&lt;p>Java 8对&lt;code>Map&lt;/code>接口进行了优化，新增了主要是针对&lt;strong>函数式接口&lt;/strong>的 &lt;em>默认&lt;/em> 方法（方法体被省略）：&lt;/p>
&lt;pre>&lt;code>default V merge (K key, V value,
 BiFunction&amp;lt;? super V, ? super V, ? extends V&amp;gt; remappingFunction) {...}
default V compute (K key,
 BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; remappingFunction) {...}
default V computeIfPresent (K key,
 BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; remappingFunction) {...}
default V computeIfAbsent (K key,
 Function&amp;lt;? super K, ? extends V&amp;gt; mappingFunction) {...}
default V replace (K key, V value) {...}
default boolean replace(K key, V oldValue, V newValue) {...}
default boolean remove (Object key, Object value) {...}
default V putIfAbsent (K key, V value) {...}
default void replaceAll (
 BiFunction&amp;lt;? super K, ? super V, ? extends V&amp;gt; function) {...}
default V getOrDefault (Object key, V defaultValue) {...}
&lt;/code>&lt;/pre>
&lt;p>上述方法使用的不多，主要用来对Map键值进行更新，按需查阅API文档。&lt;/p></description></item><item><title>Object超类</title><link>https://wangy325.github.io/zh/docs/java/basic/5_Object%E8%B6%85%E7%B1%BB/</link><pubDate>Sun, 19 Apr 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/basic/5_Object%E8%B6%85%E7%B1%BB/</guid><description>&lt;h1 id="object超类">
 Object超类
 &lt;a class="anchor" href="#object%e8%b6%85%e7%b1%bb">#&lt;/a>
&lt;/h1>
&lt;p>在Java中，如果一个类没有明确地指出超类，那么Object就是这个类的超类。实际上，Object类是所有类超类，这个类定义了一些重要的方法。&lt;/p></description></item><item><title>动态绑定与静态绑定</title><link>https://wangy325.github.io/zh/docs/java/basic/5_%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A/</link><pubDate>Sat, 18 Apr 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/basic/5_%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A/</guid><description>&lt;h1 id="动态绑定与静态绑定">
 动态绑定与静态绑定
 &lt;a class="anchor" href="#%e5%8a%a8%e6%80%81%e7%bb%91%e5%ae%9a%e4%b8%8e%e9%9d%99%e6%80%81%e7%bb%91%e5%ae%9a">#&lt;/a>
&lt;/h1>
&lt;p>这是Java方法调用的2个术语，用来描述Java虚拟机方法调用的2种机制。&lt;/p></description></item><item><title>MySQL死锁</title><link>https://wangy325.github.io/zh/docs/craft/db/sql/6_mysql%E6%AD%BB%E9%94%81/</link><pubDate>Mon, 05 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/sql/6_mysql%E6%AD%BB%E9%94%81/</guid><description>&lt;p>MySQL死锁是指多个事务之间，由于每个事务持有另一个事务所需的锁而无法继续执行的情况。因所有事务都在等待相同的资源变得可用，而没有一个事务释放它所持有的锁。&lt;/p>
&lt;p>多个事务以相反的顺序锁定多个表中的行（通过诸如UPDATE或SELECT &amp;hellip; FOR UPDATE之类的语句），就可能发生死锁。&lt;/p>
&lt;p>死锁也可能发生在这些语句锁定索引记录和间隙范围时，每个事务获取一些锁但由于时间问题而没有获取其他锁。&lt;/p></description></item><item><title>格式化输出与文件I/O</title><link>https://wangy325.github.io/zh/docs/note/pys/5_file_io/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/pys/5_file_io/</guid><description/></item><item><title>原子性和可见性</title><link>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_4_%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_4_%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB/</guid><description>&lt;p>原子性一般指&lt;strong>原子操作&lt;/strong>，原子操作不能&lt;strong>被线程调度机制中断&lt;/strong>，一旦操作开始，那么它一定可以在可能发生的上下文切换之前完成。Java语言规范规定了对基本对象(long和double除外)的读写操作是原子的。&lt;/p>
&lt;p>&lt;strong>不能将原子性和同步划等号&lt;/strong>！更不能使用原子性来代替同步，当你想使用原子性代替同步写出无锁代码时，思考 
 &lt;a href="https://inside.java/u/BrianGoetz/">&lt;em>Brain Goetz&lt;/em>&lt;/a> 的建议：&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>&lt;strong>If you can write a high-performance JVM for a modern microprocessor, then you are qualified to think about whether you can avoid synchronizing.&lt;/strong>&lt;/em>&lt;/p>
&lt;/blockquote></description></item><item><title>LinkedHashMap</title><link>https://wangy325.github.io/zh/docs/java/collections/4_Map_linkedhashmap/</link><pubDate>Sun, 10 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/collections/4_Map_linkedhashmap/</guid><description>&lt;p>&lt;code>LinkedHashMap&lt;/code>(链表散列映射)是&lt;code>HashMap&lt;/code>的导出类，像&lt;code>LinkedHashSet&lt;/code>与&lt;code>HashSet&lt;/code>的关系一样。&lt;/p>
&lt;p>其与&lt;code>HashMap&lt;/code>的差别在于其使用&lt;code>LinkedList&lt;/code>来维护键值对插入的顺序，其插入机制和&lt;code>HashMap&lt;/code>是一致的。&lt;/p>
&lt;p>&lt;code>LinkedHashMap&lt;/code>和&lt;code>HashMap&lt;/code>的性能相差不大，与&lt;code>HashSet&lt;/code>和&lt;code>LinkedHashSet&lt;/code>
 &lt;a href="https://wangy325.github.io/zh/docs/java/collections/3_Set/#linkedhashset">一致&lt;/a>：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">集合&lt;/th>
&lt;th style="text-align:center">特征&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">&lt;code>HashMap&lt;/code>&lt;/td>
&lt;td style="text-align:center">&lt;code>HashMap&lt;/code>基于散列表，插入和查询键值对的开销是固定的&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;code>LinkedHashMap&lt;/code>&lt;/td>
&lt;td style="text-align:center">和&lt;code>HashMap&lt;/code>类似，不过其使用&lt;code>LinkedList&lt;/code>维护内部次序，因此其迭代顺序是插入顺序或者LRU（最近最少使用）次序，性能稍差于&lt;code>HashMap&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>抽象类与接口</title><link>https://wangy325.github.io/zh/docs/java/basic/6_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</link><pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/basic/6_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</guid><description>&lt;h1 id="抽象类与接口">
 抽象类与接口
 &lt;a class="anchor" href="#%e6%8a%bd%e8%b1%a1%e7%b1%bb%e4%b8%8e%e6%8e%a5%e5%8f%a3">#&lt;/a>
&lt;/h1>
&lt;p>抽象类是由&lt;code>abstract&lt;/code>关键字修饰的类。将一个普通类用&lt;code>abstract&lt;/code>修饰，它就是抽象类。&lt;/p>
&lt;p>若使用&lt;code>abstract&lt;/code>修饰方法，那么称该方法为&lt;strong>抽象方法&lt;/strong>，抽象方法没有方法体。&lt;/p></description></item><item><title>异常处理</title><link>https://wangy325.github.io/zh/docs/note/pys/6_try_excep/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/pys/6_try_excep/</guid><description/></item><item><title>HashMap的源码分析</title><link>https://wangy325.github.io/zh/docs/java/collections/5_HashMap%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/collections/5_HashMap%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid><description>&lt;p>&lt;code>HashMap&lt;/code>基于散列表，散列表中每一个Node节点（桶）是链表，当两个条目（entry）的key的hash值对桶数（capacity）取模的值相等时，这两个entry会存储在同一个链表中。但当链表中元素达到一定数目时，链表结构会转变为&lt;strong>树结构&lt;/strong>。&lt;/p>
&lt;p>本文从初始化，扩容，插入，获取，删除这几个方面深入讨论了&lt;code>HashMap&lt;/code>的实现细节。&lt;/p>
&lt;blockquote>
&lt;p>此文中没有讨论&lt;code>HashMap&lt;/code>中涉及到树结构的源码。&lt;/p>
&lt;/blockquote></description></item><item><title>线程本地存储</title><link>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_5_%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</link><pubDate>Wed, 20 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_5_%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</guid><description>&lt;p>使用&lt;code>synchronized&lt;/code>关键字对整个方法加锁（防止其他线程访问整个方法）往往会带来更大的性能开销，如果你只想保护某些代码块，可以使用&lt;strong>同步代码块&lt;/strong>，这一段被锁保护的代码块就称为&lt;strong>临界区&lt;/strong>（ &lt;em>critical section&lt;/em> ），前面的&lt;strong>显式锁&lt;/strong>所保护的区域以及使用&lt;strong>synchronized&lt;/strong>保护的代码块都是临界区。&lt;/p></description></item><item><title>Lambda与函数式接口</title><link>https://wangy325.github.io/zh/docs/java/basic/7_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link><pubDate>Wed, 22 Apr 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/basic/7_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid><description>&lt;blockquote>
&lt;p>Java 函数式接口和Lambda表达式是 Java 8 中引入的一个重要概念，它允许你将行为作为参数传递给方法，从而实现更简洁、更灵活的代码。&lt;/p>
&lt;/blockquote>
&lt;h2 id="lambda表达式">
 Lambda表达式
 &lt;a class="anchor" href="#lambda%e8%a1%a8%e8%be%be%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>Lambda表达式是一个&lt;strong>可传递的代码块&lt;/strong>，可以在以后执行&lt;strong>一次或多次&lt;/strong>。&lt;/p></description></item><item><title>命名空间与作用域</title><link>https://wangy325.github.io/zh/docs/note/pys/7_scope/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/pys/7_scope/</guid><description/></item><item><title>获取任务的返回值</title><link>https://wangy325.github.io/zh/docs/java/concurrency/3%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</link><pubDate>Mon, 25 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/3%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</guid><description>&lt;h1 id="获取任务的返回值">
 获取任务的返回值
 &lt;a class="anchor" href="#%e8%8e%b7%e5%8f%96%e4%bb%bb%e5%8a%a1%e7%9a%84%e8%bf%94%e5%9b%9e%e5%80%bc">#&lt;/a>
&lt;/h1>
&lt;p>要创建一个任务，通常实现&lt;code>Runnable&lt;/code>接口。不幸的是，&lt;code>Runnable&lt;/code>接口的&lt;code>run()&lt;/code>方法返回&lt;code>void&lt;/code>，因此，其并不适合处理计算任务。&lt;/p>
&lt;p>考虑一个经典的问题：用多线程分段计算0-100的加和，我们需要把每个线程计算的值汇总，然后再求和，那么应该怎样获取每个任务返回值呢？&lt;/p>
&lt;p>Java提供了&lt;code>Callable&lt;/code>和&lt;code>Future&lt;/code>接口，使任务有提供返回值的能力。&lt;/p></description></item><item><title>Collections工具类</title><link>https://wangy325.github.io/zh/docs/java/collections/6_Collections/</link><pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/collections/6_Collections/</guid><description>&lt;p>集合框架中一个重要的类，其实是Collection接口的&lt;strong>伴随类&lt;/strong>，其中定义了许多实用方法，用来获取&lt;strong>集合视图&lt;/strong>，或提供一些方便的操作集合元素的&lt;strong>算法&lt;/strong>。&lt;/p>
&lt;p>由于视图是直接封装的Collection接口，&lt;strong>因此其方法有些局限&lt;/strong>，并且由于特殊的设计，部分操作是不允许的（会抛出 &lt;em>UnsupportedOperationExceptin&lt;/em> ）。&lt;/p></description></item><item><title>内部类</title><link>https://wangy325.github.io/zh/docs/java/basic/8_%E5%86%85%E9%83%A8%E7%B1%BB/</link><pubDate>Thu, 23 Apr 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/basic/8_%E5%86%85%E9%83%A8%E7%B1%BB/</guid><description>&lt;h1 id="内部类">
 内部类
 &lt;a class="anchor" href="#%e5%86%85%e9%83%a8%e7%b1%bb">#&lt;/a>
&lt;/h1>
&lt;p>将一个类定义在另一个类的内部，这就是内部类。&lt;/p>
&lt;blockquote>
&lt;p>定义言简意赅 ，内涵丰富多彩。&lt;/p>
&lt;/blockquote></description></item><item><title>类与对象</title><link>https://wangy325.github.io/zh/docs/note/pys/8_class_type/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/pys/8_class_type/</guid><description/></item><item><title>死锁问题2例</title><link>https://wangy325.github.io/zh/docs/java/concurrency/4%E6%AD%BB%E9%94%81/</link><pubDate>Sat, 30 May 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/4%E6%AD%BB%E9%94%81/</guid><description>&lt;p>Java有能力使任务为等待某些条件成立而进入阻塞状态，所以就有可能出现这样一种情况：某个任务在等待另一个任务，而后者又在等待其他的任务，这样一直等待下去，直到等待链上的最后一个任务又在等待第一个任务释放锁，这样就出现了任务之间相互等待的连续循环现象，这种情况出现之后，没有哪个任务能够执行，于是 &lt;strong>死锁&lt;/strong> 出现。&lt;/p>
&lt;p>死锁之所以难以规避，其重要的原因就在于其不确定性，可能程序运行良好，但是有潜在的死锁风险，这个风险在&lt;strong>某些域的初始条件&lt;/strong>变化时，变得特别大，导致程序很快死锁。同时，死锁难以复现，当程序出现死锁时，往往只能通过jvm的堆栈日志来探究原因。&lt;/p></description></item><item><title>闭包与装饰器</title><link>https://wangy325.github.io/zh/docs/note/pys/9_decoration/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/pys/9_decoration/</guid><description/></item><item><title>终结任务</title><link>https://wangy325.github.io/zh/docs/java/concurrency/5%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1/</link><pubDate>Fri, 23 Oct 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/5%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1/</guid><description>&lt;h2 id="终结任务">
 终结任务
 &lt;a class="anchor" href="#%e7%bb%88%e7%bb%93%e4%bb%bb%e5%8a%a1">#&lt;/a>
&lt;/h2>
&lt;p>一般地，如果程序运行良好，任务执行完所需操作后自然结束，任务终结。&lt;/p>
&lt;p>如果任务执行时出现异常，任务也会终结。&lt;/p>
&lt;p>在设计多个线程协同工作的任务时，需要判断&lt;strong>任务终结的条件&lt;/strong>，以便合适地终结任务，这点尤为重要。&lt;/p>
&lt;p>在本节中主要讨论在多线程协同工作的情况下，如何合适的终结任务。&lt;/p></description></item><item><title>装饰器2</title><link>https://wangy325.github.io/zh/docs/note/pys/10_decoration_2/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/pys/10_decoration_2/</guid><description/></item><item><title>Java8日期和时间API</title><link>https://wangy325.github.io/zh/docs/java/basic/11_java-new-time-api/</link><pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/basic/11_java-new-time-api/</guid><description>&lt;h1 id="java8日期和时间api">
 Java8日期和时间API
 &lt;a class="anchor" href="#java8%e6%97%a5%e6%9c%9f%e5%92%8c%e6%97%b6%e9%97%b4api">#&lt;/a>
&lt;/h1>
&lt;blockquote>
&lt;p>mybatis自 3.4.5 开始，已经支持使用&lt;code>LocaldateTime&lt;/code>作为时间查询入参，映射类型为&lt;code>TimeStamp&lt;/code>，参考地址: 
 &lt;a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h1 id="1-前言">
 1 前言
 &lt;a class="anchor" href="#1-%e5%89%8d%e8%a8%80">#&lt;/a>
&lt;/h1>
&lt;p>在介绍Java SE 8中新的日期时间库前，先了解下Java 8之前的日期时间工具的诟病。&lt;/p>
&lt;p>在Java SE 8前，日期时间工具库在&lt;code>java.util&lt;/code>包中，包括：&lt;/p>
&lt;ul>
&lt;li>&lt;code>java.util.Date&lt;/code>：表示日期和时间&lt;/li>
&lt;li>&lt;code>java.util.Calendar&lt;/code>以及其实现子类：表示各种日历系统，常用的是格林威治日历&lt;code>java.util.GregorianCalendar&lt;/code>&lt;/li>
&lt;li>&lt;code>java.util.TimeZone&lt;/code>以及其实现子类：表示时区偏移量和夏令时&lt;/li>
&lt;/ul>
&lt;p>以及辅助其进行格式化和解析的工具库在java.text包中，包括：&lt;/p>
&lt;ul>
&lt;li>&lt;code>java.text.DateFormat&lt;/code>：格式化日期时间和解析日期时间的工具抽象类&lt;/li>
&lt;li>&lt;code>java.text.SimpleDateFormat&lt;/code>：DateDateFormat的实现&lt;/li>
&lt;/ul></description></item><item><title>生产者-消费者与阻塞队列</title><link>https://wangy325.github.io/zh/docs/java/concurrency/6%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</link><pubDate>Mon, 26 Oct 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/6%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/</guid><description>&lt;p>在讨论线程协作的时候，已经讨论了生产者与消费者雏形，比如录音是生产者，而播放则是消费者；同样的，在汽车打蜡的模型中，打蜡可看作生产者，抛光可看作消费者；只是它们的关系是简单的生产-消费关系。&lt;/p>
&lt;p>除了简单的线程协同之外，Java提供了&lt;strong>同步队列&lt;/strong>来解决线程的协同问题，本节重点讨论这部分的内容。&lt;/p></description></item><item><title>线程模型</title><link>https://wangy325.github.io/zh/docs/note/pys/11_threading/</link><pubDate>Tue, 06 Aug 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/pys/11_threading/</guid><description/></item><item><title>阻塞队列的使用2例</title><link>https://wangy325.github.io/zh/docs/java/concurrency/6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A82%E4%BE%8B/</link><pubDate>Mon, 26 Oct 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A82%E4%BE%8B/</guid><description>&lt;p>
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/6%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/">上一篇文章&lt;/a>介绍了juc的几种主要阻塞队列。&lt;/p>
&lt;p>本文使用2个例子，演示了阻塞队列在Java中的应用。&lt;/p></description></item><item><title>Executors与Executor框架</title><link>https://wangy325.github.io/zh/docs/java/concurrency/7_1_Executors_and_ExecutorService/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/7_1_Executors_and_ExecutorService/</guid><description>&lt;p>&lt;code>Executors&lt;/code>可以称作执行器。Java并发系列的文章到目前为止，虽然没有特别说明，但是使用执行器(Executor(s))的次数已经难以计数了，&lt;code>Executors&lt;/code>提供了一些非常方便的静态方法，可以根据需要创建不同的&lt;code>ExecutorService&lt;/code>，然后调用其&lt;code>execute(Runnable)&lt;/code>或&lt;code>submit(Callable&amp;lt;T&amp;gt;)&lt;/code>方法。&lt;/p>
&lt;p>在并发条件下，执行器还有一个非常明显的优势，它使用&lt;strong>线程池&lt;/strong>管理线程，减少了系统创建和销毁线程的开销。在一般的Java并发过程中，也建议使用执行器完成任务而非显式地创建线程。&lt;/p>
&lt;p>本文将从执行器开始，阐述Java中的线程池。&lt;/p></description></item><item><title>ThreadPoolExecutor-1</title><link>https://wangy325.github.io/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/</guid><description>&lt;p>
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/7_1_Executors_and_ExecutorService/">前文&lt;/a>就已经提过，&lt;code>Executors&lt;/code>执行器创建的线程池包括不同实现，可以应对不同的场景，那么Java中包含哪些实现呢？&lt;/p>
&lt;p>本问就来讨论这些实现。&lt;/p></description></item><item><title>ThreadPoolExecutor-2</title><link>https://wangy325.github.io/zh/docs/java/concurrency/7_3_ThreadPoolExecutor2/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/7_3_ThreadPoolExecutor2/</guid><description>&lt;p>
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/#threadpoolexecutor">前文&lt;/a>说过，&lt;code>ThreadPoolExecutor&lt;/code>实例代表了Java线程池，前面我们介绍了&lt;code>ThreadPoolExecutor&lt;/code>的构造器和几个核心概念，在本节中，我们着重介绍线程池的执行过程以及线程池的关闭。&lt;/p></description></item><item><title>CompletionService</title><link>https://wangy325.github.io/zh/docs/java/concurrency/7_4_CompletionService/</link><pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/7_4_CompletionService/</guid><description>在提交单个任务时，使用submit()或者execute()方法或许能够满足要求，但如果需要控制多个任务时，依次提交的操作看起来“有些繁琐”，此时我们可以使用ExecutorService提供的invokeAny/invokeAll方法，在介绍CompletionService接口时，我们不妨先看看这两个方法。
之前介绍AbstractExecutorService时提到，这两个方法是在这个抽象类中实现的，其中前者在获取到一个任务的返回值时便取消其他（未执行或正在执行的任务）任务，而后者需要等待所有的任务执行完成之后才能对任务的返回进行处理，接下来我们分别来看：
invokeAll会阻塞等待所有的任务执行完成。
public &amp;lt;T&amp;gt; List&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; invokeAll(Collection&amp;lt;? extends Callable&amp;lt;T&amp;gt;&amp;gt; tasks) throws InterruptedException { if (tasks == null) throw new NullPointerException(); ArrayList&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt; futures = new ArrayList&amp;lt;Future&amp;lt;T&amp;gt;&amp;gt;(tasks.size()); boolean done = false; try { for (Callable&amp;lt;T&amp;gt; t : tasks) { RunnableFuture&amp;lt;T&amp;gt; f = newTaskFor(t); futures.add(f); execute(f); } // 有序迭代 for (int i = 0, size = futures.size(); i &amp;lt; size; i++) { Future&amp;lt;T&amp;gt; f = futures.get(i); if (!f.isDone()) { try { // 阻塞等待任务执行完成 f.</description></item><item><title>ScheduledExecutorService-1</title><link>https://wangy325.github.io/zh/docs/java/concurrency/8_1_ScheduledExecutorService1/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/8_1_ScheduledExecutorService1/</guid><description>&lt;p>除了&lt;code>ThreadPoolExecutor&lt;/code>之外，Java执行器（Executor）框架还提供了可以在指定延迟之后执行一次或周期执行任务的接口&lt;code>ScheduledExecutorService&lt;/code>，较
 &lt;a href="https://docs.oracle.com/javase/8/docs/api/java/util/Timer.html">java.util.Timer&lt;/a>而言，它是更好的选择。&lt;/p>
&lt;p>与
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/#threadpoolexecutor">线程池&lt;/a>不同的是，用于计划执行的&lt;code>ScheduledThreadPoolExecutor&lt;/code>使用&lt;code>ScheduledFutureTask&lt;/code>作为任务，使用&lt;code>DelayedWorkQueue&lt;/code>作为任务队列，以实现计划（周期）执行的目的。&lt;/p></description></item><item><title>ScheduledExecutorService-2</title><link>https://wangy325.github.io/zh/docs/java/concurrency/8_2_ScheduledExecutorService2/</link><pubDate>Tue, 10 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/8_2_ScheduledExecutorService2/</guid><description>&lt;h2 id="引例">
 引例
 &lt;a class="anchor" href="#%e5%bc%95%e4%be%8b">#&lt;/a>
&lt;/h2>
&lt;p>
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/8_1_ScheduledExecutorService1/#scheduledfuturetask">前文&lt;/a>介绍了&lt;code>ScheduledFutureTask&lt;/code>和&lt;code>DeleyedWorkQueue&lt;/code>这么多，都是为了更好地理解任务执行的流程，在这之前，我们不妨先看如下示例：&lt;/p></description></item><item><title>并发组件-CountDownLatch</title><link>https://wangy325.github.io/zh/docs/java/concurrency/9_1_countdownlatch/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/9_1_countdownlatch/</guid><description>&lt;h2 id="countdownlatch">
 CountDownLatch
 &lt;a class="anchor" href="#countdownlatch">#&lt;/a>
&lt;/h2>
&lt;p>在讨论线程的基本概念时，我们说过&lt;code>join()&lt;/code>方法可使当前线程等待调用join方法的线程执行完，可以实现简单的
 &lt;a href="https://wangy325.github.io/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/#%e5%8a%a0%e5%85%a5%e7%ba%bf%e7%a8%8bjoin">无锁同步&lt;/a>，使用&lt;code>CountDownLatch&lt;/code>可以更加简单的实现这一目的。毕竟，&lt;code>join()&lt;/code>方法的语义“加入一个线程”不是很容易就能让人理解。相较于&lt;code>join()&lt;/code>方法，&lt;code>CountDownLatch&lt;/code>的语义就明确多了。&lt;/p></description></item><item><title>并发组件-CyclicBarrier</title><link>https://wangy325.github.io/zh/docs/java/concurrency/9_2_cyclicbarrier/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/9_2_cyclicbarrier/</guid><description>&lt;h2 id="cyclicbarrier">
 CyclicBarrier
 &lt;a class="anchor" href="#cyclicbarrier">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>CyclicBarrier&lt;/code>被称为“同步屏障”，事实上就可以把它理解为一个屏障，多个任务调用屏障的&lt;code>await()&lt;/code>方法将被阻塞，直到所有的任务都进入阻塞，那么屏障开启，所有任务继续执行。这看起来和&lt;code>CountDownLatch&lt;/code>非常像，不过&lt;code>CountDownLatch&lt;/code>只能触发一次，而&lt;code>CyclicBarrier&lt;/code>可以多次重用，这是它们的主要区别之一。&lt;/p>
&lt;p>和&lt;code>CountDownLatch&lt;/code>一样，&lt;code>CyclicBarrier&lt;/code>接受一个整型参数，表示可限制的线程数。除此之外，&lt;code>CyclicBarrier&lt;/code>还可以接受一个&lt;code>Runnable&lt;/code>作为参数，这个参数称作&lt;code>barrierAction&lt;/code>，&lt;code>barrierAction&lt;/code>在所有线程到达屏障之后即开始执行，其他任务&lt;strong>只能等待&lt;/strong>&lt;code>barrierAction&lt;/code>执行完毕之后才能继续执行，这是&lt;code>CyclicBarrier&lt;/code>和&lt;code>CountDownLatch&lt;/code>的区别之二。&lt;/p></description></item><item><title>并发组件-Semaphore</title><link>https://wangy325.github.io/zh/docs/java/concurrency/9_3_semaphore/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/9_3_semaphore/</guid><description>Semaphore # 无论是显式锁还是通过synchronized关键字获取的隐式锁，其在任一时刻都只能让一个任务访问资源，而Semaphore（计数信号量）允许多个任务同时访问资源。可以把Semaphore看作是持有对象访问许可（permits）的“security”。访问对象时，须先通过acquire()获取许可，若此时没有许可可用，那么acquire()将阻塞，否则获取许可，可用许可数-1；使用完资源后，通过release()方法返还许可。事实上，并没有实际上的许可证对象，Semaphore通过协同各个线程工作，来达到目的。
Semaphore的构造器接受一个“公平性参数”。不传入此参数或传入false时，线程获取许可的顺序无法保证，即使线程阻塞了很久，其仍然可能被刚调用acquire()方法的线程“抢走”许可，这可能会导致线程“饿死”。当传入true时，Semaphore保证线程获取许可的顺序和其调用acquire()方法之后被执行的顺序一致1，也就是先执行的任务先获取许可（FIFO）。需要说明的是，tryAcquire()方法不遵循公平性原则，如果有许可可用，它直接获取之。在使用Semaphore时，一般将其设置为公平的
Semaphore通常用于限制访问资源的线程数量，典型的例子就是控制“池”的并发访问量。下例中使用Semaphore控制池中的对象方法，当需要使用时，可以将它们“签出”（checkout），使用完毕之后再将其“签入”（checkin），使用泛型类封装功能2。
class Pool&amp;lt;T&amp;gt; { private final int size; final List&amp;lt;T&amp;gt; items = new ArrayList&amp;lt;&amp;gt;(); private final boolean[] checkedOut; private final Semaphore available; public Pool(Class&amp;lt;T&amp;gt; classObject, int size) { this.size = size; checkedOut = new boolean[size]; available = new Semaphore(size, true); // Load pool with objects that can be checked out: for (int i = 0; i &amp;lt; size; ++i) { try { // Assumes a default constructor: items.</description></item><item><title>并发组件-Exchanger</title><link>https://wangy325.github.io/zh/docs/java/concurrency/9_4_exchanger/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/9_4_exchanger/</guid><description>&lt;h2 id="exchanger">
 Exchanger
 &lt;a class="anchor" href="#exchanger">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>Exchanger&lt;/code>是在两个任务之间交换对象的栅栏。当这些任务进入栅栏时，各自拥有一个对象，离开时交换它们拥有的对象。栅栏可以用来设计缓存对象，2个任务分别来使用和清空缓存，当缓存空间满时，则在Exchanger上交换缓存，缓存得以重复使用&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。&lt;/p></description></item><item><title>并发组件-PBQ/DQ</title><link>https://wangy325.github.io/zh/docs/java/concurrency/9_5_priorityblockqueue_delayqueue/</link><pubDate>Mon, 16 Nov 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/9_5_priorityblockqueue_delayqueue/</guid><description>PriorityBlockingQueue # PriorityBlockingQueue就是一个基础的可阻塞的 优先级队列，当队列为空时，从队列中获取元素时被阻塞。其余特性和优先级队列是一致的。
下例展示了如何构建一个可以放入优先级队列的任务：
public class PrioritizedTask implements Runnable, Comparable&amp;lt;PrioritizedTask&amp;gt; { protected static List&amp;lt;PrioritizedTask&amp;gt; sequence = new ArrayList&amp;lt;&amp;gt;(); private Random rand = new Random(47); private static int counter = 0; private final int id = counter++; private final int priority; public PrioritizedTask(int priority) { this.priority = priority; sequence.add(this); } @Override public int compareTo(PrioritizedTask arg) { return priority &amp;lt; arg.priority ? 1 : (priority &amp;gt; arg.priority ? -1 : 0); } @Override public void run() { try { TimeUnit.</description></item><item><title>JMM与volatile关键字(转)</title><link>https://wangy325.github.io/zh/docs/java/concurrency/10_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/</link><pubDate>Tue, 27 Oct 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/concurrency/10_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/</guid><description>&lt;h1 id="java内存模型与volatile关键字">
 Java内存模型与volatile关键字
 &lt;a class="anchor" href="#java%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8b%e4%b8%8evolatile%e5%85%b3%e9%94%ae%e5%ad%97">#&lt;/a>
&lt;/h1>
&lt;p>本文转自
 &lt;a href="http://www.cnblogs.com/dolphin0520/p/3920373.html">Matrix海子&lt;/a>，是描述&lt;code>volatile&lt;/code>关键字非常好的一篇文章，从Java的内存模型开始，归本溯源的阐述了&lt;code>volatile&lt;/code>关键字在并发中的作用与局限&lt;/p>
&lt;p>此文部分内容参照了《深入理解Java虚拟机》&lt;/p></description></item><item><title>macOS12 Monterey更新</title><link>https://wangy325.github.io/zh/posts/18_macOS12%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/</link><pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/18_macOS12%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95/</guid><description>&lt;p>原本计划MBP2018就在BigSur 11.7 养老算了，实际上已经苟了3年，并且计划一直苟下去的😂&amp;hellip;但是有几个征兆，最终还是在7月份，更新了12。以下为主要原因:&lt;/p>
&lt;ul>
&lt;li>自带的应用商店出现了最低支持12的应用——削弱了老11用户的使用体验&lt;/li>
&lt;li>oneDrive自动更新之后不支持老版本，但是旧版本又不好找。（最后只能删除plist阻止其自动更新）&lt;/li>
&lt;li>部分破解软件的旧版本也不好找了&lt;/li>
&lt;li>docker竟然也&amp;hellip;😅&lt;/li>
&lt;li>brew也&amp;hellip;太慢了(升级之后好多了)&lt;/li>
&lt;/ul></description></item><item><title>更新使用Homebrew安装的软件包</title><link>https://wangy325.github.io/zh/posts/16_update-homebrew-packages/</link><pubDate>Wed, 17 Jul 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/16_update-homebrew-packages/</guid><description>&lt;p>使用&lt;code>Homebrew&lt;/code>安装的软件包，安装完成之后，可能几年都不会去管一眼。不过么，等到几年后要升级的时候，还是会有点麻烦。主要是&lt;code>Homebrew&lt;/code>慢（:&amp;ndash;汗😓️。&lt;/p></description></item><item><title>使用Pythonanywhere托管Telegram机器人</title><link>https://wangy325.github.io/zh/posts/15_%E4%BD%BF%E7%94%A8PythonAnywhere%E6%89%98%E7%AE%A1%E7%94%B5%E6%8A%A5%E6%9C%BA%E5%99%A8%E4%BA%BA/</link><pubDate>Mon, 08 Jul 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/15_%E4%BD%BF%E7%94%A8PythonAnywhere%E6%89%98%E7%AE%A1%E7%94%B5%E6%8A%A5%E6%9C%BA%E5%99%A8%E4%BA%BA/</guid><description>&lt;p>基于Coze的收费策略，在上面免费使用Gemini的可能性不大了(每日20次&lt;code>gemini-1.5-flash&lt;/code>请求)。于是尝试看看，是否可以自己接入并部署玩玩看。&lt;/p>
&lt;p>GitHub上有关Telegram机器人的项目不少，并且使用python并接入google Gemini AI的也不在少数。随即
 &lt;a href="https://github.com/H-T-H/Gemini-Telegram-Bot.git">clone&lt;/a>了一个，查看文档之后，便可上手。&lt;/p></description></item><item><title> 获取JetBrains IDE的永久回退授权</title><link>https://wangy325.github.io/zh/posts/14_get-perpetual-fallback-license-for-jetbrains-ides/</link><pubDate>Mon, 01 Jul 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/14_get-perpetual-fallback-license-for-jetbrains-ides/</guid><description>&lt;p>⚠️本人并不鼓励使用破解软件！&lt;/p>
&lt;p>⚠️如果经济允许，请购买正版软件，以支持开发者并体验最新的功能。&lt;/p>
&lt;p>⚠️此文仅作记录，请勿转载。&lt;/p>
&lt;hr></description></item><item><title>使用Coze的插件和工作流创建自定义AI工具</title><link>https://wangy325.github.io/zh/posts/13_use-coze-plugin-and-workflow/</link><pubDate>Fri, 21 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/13_use-coze-plugin-and-workflow/</guid><description>&lt;p>
 &lt;a href="https://www.coze.com/docs/guides/welcome?_lang=zh">Coze&lt;/a>是一个提供AI机器人的HUB，利用它市场上提供的Bot，可以很方便地使用AI机器人工作或娱乐。除了市场上五花八门的AI机器人之外，Bot还提供了自定义工作流，插件等功能，用来创建自己的AI工具。&lt;/p>
&lt;blockquote>
&lt;p>⚠️2024年07月03日起，创建的Coze机器人需要
 &lt;a href="https://www.coze.com/docs/guides/subscription?_lang=zh">购买套餐&lt;/a>才能继续使用了，最便宜需要$9/M，看来字节也被薅羊毛薅到顶不住了😭️。&lt;/p>
&lt;p>目前免费用户有每日免费使用GPT-3.5-turbo模型100次的限制，其他的模型免费次数太少，基本不能碰了。&lt;/p>
&lt;p>这个改动对于免费用户来说，使用复杂工作流基本上属于流产，工作流一次调用可能需要使用多次LLM😅。&lt;/p>
&lt;/blockquote></description></item><item><title>主动管理Clash的代理配置</title><link>https://wangy325.github.io/zh/posts/12_%E4%B8%BB%E5%8A%A8%E6%89%98%E7%AE%A1Clash%E9%85%8D%E7%BD%AE/</link><pubDate>Sat, 15 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/12_%E4%B8%BB%E5%8A%A8%E6%89%98%E7%AE%A1Clash%E9%85%8D%E7%BD%AE/</guid><description>&lt;p>自己搭建了这么多年的shadowsocks服务，经历了2次续年费后服务器ip被加黑名单之后，算是彻底放弃了（心痛100刀😭），说的就是帮瓦工。vultr的服务器虽然稳定，但是延迟比较高，糟糕的时候甚至连油管的高清视频都卡顿，不过大部分时间都是轻度搜索场景，也就还能使用。那时候也知道“机场”的概念，不过自己搭的服务用着放心么不是，机场随时跑路的，就一直没用。而且vultr的服务器，5刀/月，价格也在可接受的范围内。&lt;/p></description></item><item><title>更换个人博客主题</title><link>https://wangy325.github.io/zh/posts/11_%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/</link><pubDate>Wed, 12 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/11_%E6%9B%B4%E6%8D%A2%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/</guid><description>&lt;p>想换一个更加简洁的博客主题，也是觉得原来的
 &lt;a href="https://github.com/zzossig/hugo-theme-zzo.git">Zzo主题&lt;/a>两侧的留白过于浪费空间，且配色，有些腻了。&lt;/p>
&lt;p>不过，这主题用了很久了，且hugo版本也更新得不像样子了，新主题与旧版本的hugo并不兼容，故一并更新了hugo和主题的版本，这一顿折腾，应该又能撑2年吧。&lt;/p></description></item><item><title>Rime中州韻輸入引擎安裝與輸入方案定製指北</title><link>https://wangy325.github.io/zh/posts/10_Rime%E4%B8%AD%E5%B7%9E%E9%9F%BB%E8%BC%B8%E5%85%A5%E5%BC%95%E6%93%8E%E5%AE%89%E8%A3%9D%E8%88%87%E7%B0%A1%E5%96%AE%E8%AA%BF%E6%95%99/</link><pubDate>Thu, 06 Jun 2024 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/10_Rime%E4%B8%AD%E5%B7%9E%E9%9F%BB%E8%BC%B8%E5%85%A5%E5%BC%95%E6%93%8E%E5%AE%89%E8%A3%9D%E8%88%87%E7%B0%A1%E5%96%AE%E8%AA%BF%E6%95%99/</guid><description>&lt;p>&lt;del>由于未知的原因&lt;/del>&lt;sup>很有可能是配置文件错误&lt;/sup>，使用几年多的Rime（squirrel）输入法发生异常。主要表现为小鹤双拼的键位映射异常（如键入‘budv’的候选词是‘病毒’而不是‘不对’。），检查了许久的配置文件，并没有发现明显异常。距离上次配置Rime已许久，很多细节都已经丢失。一番纠结后，决定再重新调试一下Rime，并作此记录。&lt;/p></description></item><item><title>一次服务器OOM故障</title><link>https://wangy325.github.io/zh/posts/2_%E6%9C%8D%E5%8A%A1%E5%99%A8OOM%E6%95%85%E9%9A%9C/</link><pubDate>Sat, 20 Feb 2021 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/2_%E6%9C%8D%E5%8A%A1%E5%99%A8OOM%E6%95%85%E9%9A%9C/</guid><description>&lt;p>使用&lt;code>idm&lt;/code>下载y2b视频导致服务器内存溢出，内核强制关闭了服务进程。&lt;/p>
&lt;p>通过系统日志定位原因，并介绍了服务器维护的几个相关命令。&lt;/p></description></item><item><title>使用Logback记录日志</title><link>https://wangy325.github.io/zh/docs/note/translations/guide-to-logback-cn/</link><pubDate>Wed, 10 Feb 2021 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/translations/guide-to-logback-cn/</guid><description>&lt;p>
 &lt;a href="https://logback.qos.ch/">Logback&lt;/a>是Java应用中使用最广的日志框架之一，它是
 &lt;a href="https://logback.qos.ch/reasonsToSwitch.html">其前辈框架Log4j的替代者&lt;/a>。相比Log4j，Logback在日志处理速度、配置多样性、对旧日志文件的处理灵活性上均要优于Log4j。&lt;/p>
&lt;p>这篇文章将介绍Logback的主要组成结构并指导你使用Logback构建更好的程序。&lt;/p></description></item><item><title>在xxl-job中使用分片任务</title><link>https://wangy325.github.io/zh/posts/17_xxl-sharding-job/</link><pubDate>Mon, 25 Jan 2021 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/17_xxl-sharding-job/</guid><description>&lt;p>本文介绍在如何在
 &lt;a href="https://www.xuxueli.com/xxl-job/#%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB%E3%80%8B">xxl-job&lt;/a>中使用创建并使用分片任务。&lt;/p>
&lt;p>&lt;code>xxl-job&lt;/code>是国内开源的一款轻量级分布式任务调度平台，开发者是大众点评的工程师，其目前维护一个
 &lt;a href="https://www.xuxueli.com/">开源社区&lt;/a>，里面还有很多已经发布或尚在孵化的开源项目。&lt;/p></description></item><item><title>使用printf格式化输出</title><link>https://wangy325.github.io/zh/docs/note/translations/how2use-printf/</link><pubDate>Thu, 10 Dec 2020 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/note/translations/how2use-printf/</guid><description>&lt;p>这篇文章介绍了几种常见的使用&lt;code>printf()&lt;/code>方法进行格式化输出的方法。&lt;/p>
&lt;p>&lt;code>printf()&lt;/code>方法隶属于&lt;code>java.io.PrintStream&lt;/code>类，提供了和C语言中相似的格式化字符串输出的方法。&lt;/p></description></item><item><title>单机版fdfs服务遇到的问题</title><link>https://wangy325.github.io/zh/posts/0_%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BA%E7%89%88fdfs%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/0_%E5%AE%89%E8%A3%85%E5%8D%95%E6%9C%BA%E7%89%88fdfs%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;blockquote class="book-hint danger">
 此文章记录的内容已经过时，现在有更好的文件存储方案，如
 &lt;a href="https://min.io/docs/minio/linux/index.html">minIO&lt;/a>。
&lt;/blockquote>

&lt;hr>
&lt;p>简单记录了2个在安装单机版fdfs服务遇到的问题，虽然报错信息不同，但是问题出在同一个地方：&lt;/p></description></item><item><title>关于forever启动node服务的问题</title><link>https://wangy325.github.io/zh/posts/3_%E5%85%B3%E4%BA%8Eforever%E5%90%AF%E5%8A%A8node%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98/</link><pubDate>Wed, 28 Aug 2019 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/3_%E5%85%B3%E4%BA%8Eforever%E5%90%AF%E5%8A%A8node%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98/</guid><description>&lt;p>在使用jenkins自动构建node.js项目的时候，由于对forever的不熟悉，构建脚本一直存在一点小问题。&lt;/p></description></item><item><title>比较器的「退化」</title><link>https://wangy325.github.io/zh/posts/5_%E6%AF%94%E8%BE%83%E5%99%A8%E7%9A%84%E9%80%80%E5%8C%96/</link><pubDate>Tue, 27 Aug 2019 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/5_%E6%AF%94%E8%BE%83%E5%99%A8%E7%9A%84%E9%80%80%E5%8C%96/</guid><description>&lt;hr>
&lt;p>Java「语法糖」越来越牛逼了哈。&lt;/p>
&lt;p>在使用匿名内部类比较器的时候，idea提供了几个层次的比较器代码优化，给👴整懵逼了。&lt;/p></description></item><item><title>Java Script中的构造函数</title><link>https://wangy325.github.io/zh/posts/4_Java-Script%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link><pubDate>Thu, 25 Jul 2019 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/4_Java-Script%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid><description>&lt;p>函数作为JavaScript中的一个特殊数据类型（特殊对象的一种，另一种是数组），有一些特性值得思考与讨论。&lt;/p></description></item><item><title>cron表达式速查</title><link>https://wangy325.github.io/zh/posts/%E5%B8%B8%E8%A7%81cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B/</link><pubDate>Thu, 13 Dec 2018 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/%E5%B8%B8%E8%A7%81cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B/</guid><description>&lt;p>cron表达式常用于配置定时任务。cron表达式实际上是由七个子表达式组成。这些表达式之间用空格分隔：&lt;/p>
&lt;ol>
&lt;li>Seconds （秒）&lt;/li>
&lt;li>Minutes（分）&lt;/li>
&lt;li>Hours（小时）&lt;/li>
&lt;li>Day-of-Month （天）&lt;/li>
&lt;li>Month（月）&lt;/li>
&lt;li>Day-of-Week （周）&lt;/li>
&lt;li>Year（年）&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>例：表达式&lt;code>0 0 12 ? \* WED&lt;/code> 意思是：每个星期三的中午12点执行。&lt;/p>
&lt;/blockquote></description></item><item><title>代理模式</title><link>https://wangy325.github.io/zh/docs/craft/design_pattern/structure/proxy/</link><pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/design_pattern/structure/proxy/</guid><description>&lt;p>代理可以简单理解为，B类托管A类的功能，并根据需求，对A类的访问作&lt;font color=red>&lt;strong>控制&lt;/strong>&lt;/font>，这里的&lt;font color=red>&lt;strong>控制&lt;/strong>&lt;/font>可以理解为对A类方法执行的流程的影响，包括但不限于：&lt;/p></description></item><item><title>一个简单的sql优化示例</title><link>https://wangy325.github.io/zh/posts/3_%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SQL%E4%BC%98%E5%8C%96%E7%9A%84%E4%BE%8B%E5%AD%90/</link><pubDate>Wed, 14 Nov 2018 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/3_%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84SQL%E4%BC%98%E5%8C%96%E7%9A%84%E4%BE%8B%E5%AD%90/</guid><description>&lt;p>例如，我在执行以下sql语句的时候&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> projectId &lt;span style="color:#66d9ef">FROM&lt;/span> lywl_equip_package &lt;span style="color:#66d9ef">WHERE&lt;/span> salesId &lt;span style="color:#66d9ef">in&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">SELECT&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		t1.id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">FROM&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			cmp_datapackage_user t1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">LEFT&lt;/span> &lt;span style="color:#66d9ef">JOIN&lt;/span> cmp_datapackage t2 &lt;span style="color:#66d9ef">ON&lt;/span> t1.datapackage_id &lt;span style="color:#f92672">=&lt;/span> t2.id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">WHERE&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			t1.sales_cycle &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">AND&lt;/span> t1.is_valid &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">AND&lt;/span> t1.is_share &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">AND&lt;/span> t1.sales_price &lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">9999&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">AND&lt;/span> t1.sales_name REGEXP &lt;span style="color:#e6db74">&amp;#39;移动.*/(季度|半年|年)&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">AND&lt;/span> t2.&lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">AND&lt;/span> t2.is_share &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">AND&lt;/span> t2.datapackage_cycle &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Java接口回调</title><link>https://wangy325.github.io/zh/posts/Java%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83/</link><pubDate>Tue, 16 Oct 2018 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/Java%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83/</guid><description>&lt;p>回调模式在web开发中用的较多，本文简单介绍了Java的回调机制，理解此文可以在生产中写出适应业务的回调模型。&lt;/p></description></item><item><title>MyBatis的trim标签</title><link>https://wangy325.github.io/zh/posts/1_mybatis%E4%B8%ADtrim%E6%A0%87%E7%AD%BE%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5SQL/</link><pubDate>Fri, 21 Sep 2018 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/1_mybatis%E4%B8%ADtrim%E6%A0%87%E7%AD%BE%E5%8A%A8%E6%80%81%E6%8B%BC%E6%8E%A5SQL/</guid><description>&lt;p>&lt;code>trim&lt;/code>标记是一个格式化的标记，可以完成&lt;code>set&lt;/code>或者是&lt;code>where&lt;/code>标记的功能。&lt;/p></description></item><item><title>Git合并与分支管理</title><link>https://wangy325.github.io/zh/posts/Git%E5%85%A5%E9%97%A82/</link><pubDate>Thu, 20 Sep 2018 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/Git%E5%85%A5%E9%97%A82/</guid><description>&lt;blockquote>
&lt;p>此文的操作背景在本次工作空间的master分支下, 并且追踪远程master分支
部分内容参考自
 &lt;a href="https://www.yiibai.com/git/git_pull.html">yibai.com&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>
 &lt;a href="https://wangy325.github.io/zh/posts/Git%E5%85%A5%E9%97%A81/">常用操作速查&lt;/a>说到, git版本控制的基本原型与操作逻辑. 如果出现两台机器(比如公司和家)上同时更改&amp;rsquo;本地仓库&amp;rsquo;内容并且&lt;code>push&lt;/code>到远程库中,那么必然会导致另一个版本库中的文件低于远程库,如果是有效的改动, 必然涉及到本地库和远程库同步的问题, 这涉及到3个关键词: &lt;code>fetch&lt;/code>, &lt;code>merge&lt;/code>, &lt;code>pull&lt;/code>&lt;/p></description></item><item><title>Git常用命令速查</title><link>https://wangy325.github.io/zh/posts/Git%E5%85%A5%E9%97%A81/</link><pubDate>Wed, 19 Sep 2018 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/posts/Git%E5%85%A5%E9%97%A81/</guid><description>&lt;p>本文简单介绍了Git本地仓库的构建，与远程仓库的关联。&lt;/p>
&lt;h2 id="安装git">
 安装Git
 &lt;a class="anchor" href="#%e5%ae%89%e8%a3%85git">#&lt;/a>
&lt;/h2>
&lt;p>ubuntu下安装：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-console" data-lang="console">&lt;span style="display:flex;">&lt;span>sudo apt install git
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>windows 下安装，需
 &lt;a href="https://git-scm.com/downloads">下载&lt;/a>安装包&lt;/p></description></item><item><title>关于...</title><link>https://wangy325.github.io/zh/posts/100_index/</link><pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate><guid>https://wangy325.github.io/zh/posts/100_index/</guid><description>&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
 &lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/UeeuEplH3D0?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
 >&lt;/iframe>
 &lt;/div>

&lt;p>这首&lt;code>Things left unsaid&lt;/code>出自 
 &lt;a href="https://en.wikipedia.org/wiki/Pink_Floyd">&lt;em>Pink Floyd&lt;/em>&lt;/a> 2014年的专辑&lt;code>endless river&lt;/code>，自私地用作博客名字。那时想找点摇滚来听，恰逢&lt;strong>Pink Floyd&lt;/strong>这张专辑发行，也是我第一次接触计算机&amp;quot;技术&amp;quot;，准确点说，是接触Ubuntu。我想，Pink Floyd我想我会一直听，技术之路，也会一直走。&lt;/p></description></item><item><title/><link>https://wangy325.github.io/zh/docs/craft/db/sql/7_mysql_redo_log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/sql/7_mysql_redo_log/</guid><description/></item><item><title/><link>https://wangy325.github.io/zh/docs/craft/db/sql/8_mysql_undo_log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/sql/8_mysql_undo_log/</guid><description/></item><item><title/><link>https://wangy325.github.io/zh/docs/craft/db/sql/9_mysql_bin_log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/craft/db/sql/9_mysql_bin_log/</guid><description/></item><item><title/><link>https://wangy325.github.io/zh/docs/java/spring/list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wangy325.github.io/zh/docs/java/spring/list/</guid><description># spring-amqp
spring-web-flux
spring-cloud-open-feign
spring-cloud-hystrix
spring-data-redis/ spring-data-redis-reactive
spring-websocket/ stomp
spring-logging
spring-security</description></item></channel></rss>