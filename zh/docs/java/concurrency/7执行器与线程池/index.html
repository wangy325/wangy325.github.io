<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  执行器和线程池
  #

Java并发系列的文章到目前为止，虽然没有特别说明，但是使用执行器(Executor(s))的次数已经难以计数了，Executors提供了一些非常方便的静态方法，可以根据需要创建不同的ExecutorService，然后调用其execute(Runnable)或submit(Callable<T>)方法。在多线程的条件下，执行器还有一个非常明显的优势，它使用线程池管理线程，减少了系统创建和销毁线程的开销。在一般的Java并发过程中，也建议使用执行器完成任务而非显式地创建线程。
本文将从执行器开始，阐述Java中的线程池。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://wangy325.github.io/zh/docs/java/concurrency/7%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/"><meta property="og:site_name" content="Endless River"><meta property="og:title" content="执行器与线程池"><meta property="og:description" content=" 执行器和线程池 # Java并发系列的文章到目前为止，虽然没有特别说明，但是使用执行器(Executor(s))的次数已经难以计数了，Executors提供了一些非常方便的静态方法，可以根据需要创建不同的ExecutorService，然后调用其execute(Runnable)或submit(Callable<T>)方法。在多线程的条件下，执行器还有一个非常明显的优势，它使用线程池管理线程，减少了系统创建和销毁线程的开销。在一般的Java并发过程中，也建议使用执行器完成任务而非显式地创建线程。
本文将从执行器开始，阐述Java中的线程池。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2020-11-03T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-03T00:00:00+00:00"><meta property="article:tag" content="Concurrency"><title>执行器与线程池 | Endless River</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://wangy325.github.io/zh/docs/java/concurrency/7%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.2d78e2d410e66cd9935b6d57ed5a67482828e0dd33b99fd1bda8ffd0df8c83b0.js integrity="sha256-LXji1BDmbNmTW21X7VpnSCgo4N0zuZ/Rvaj/0N+Mg7A=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-HHNKR5H8KN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-HHNKR5H8KN")}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>Endless River</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><a href=/zh/docs/java/>Java核心</a><ul><li><input type=checkbox id=section-287084f81620420b7ed7e40a42c44d2f class=toggle>
<label for=section-287084f81620420b7ed7e40a42c44d2f class="flex justify-between"><a role=button>必知必会</a></label><ul><li><a href=/zh/docs/java/basic/1_%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/>访问权限修饰符</a></li><li><a href=/zh/docs/java/basic/2_static%E5%85%B3%E9%94%AE%E5%AD%97/>static关键字</a></li><li><a href=/zh/docs/java/basic/3_%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/>传值还是传引用</a></li><li><a href=/zh/docs/java/basic/4_final%E5%85%B3%E9%94%AE%E5%AD%97/>final关键字</a></li><li><a href=/zh/docs/java/basic/5_Object%E8%B6%85%E7%B1%BB/>Object超类</a></li><li><a href=/zh/docs/java/basic/5_%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A/>动态绑定与静态绑定</a></li><li><a href=/zh/docs/java/basic/6_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/>抽象类与接口</a></li><li><a href=/zh/docs/java/basic/7_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/>lambda表达式</a></li><li><a href=/zh/docs/java/basic/8_%E5%86%85%E9%83%A8%E7%B1%BB/>内部类</a></li><li><a href=/zh/docs/java/basic/11_java-new-time-api/>Java8日期和时间API</a></li><li><a href=/zh/docs/java/basic/Java%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83/>Java接口回调</a></li></ul></li><li><input type=checkbox id=section-3d2f820e49b3d97a7a712be90f9fd6ad class=toggle>
<label for=section-3d2f820e49b3d97a7a712be90f9fd6ad class="flex justify-between"><a role=button>集合框架</a></label><ul><li><a href=/zh/docs/java/collections/1_List/>List列表</a></li><li><a href=/zh/docs/java/collections/2_Queue/>Queue</a></li><li><a href=/zh/docs/java/collections/3_Set/>Set</a></li><li><a href=/zh/docs/java/collections/4_Map/>Java集合框架之Map</a></li><li><a href=/zh/docs/java/collections/5_Collections/>Collections工具类</a></li><li><a href=/zh/docs/java/collections/6_HashMap%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>HashMap的源码分析</a></li></ul></li><li><input type=checkbox id=section-6d6d0626deeb0ce0f9826f9dabe58c16 class=toggle checked>
<label for=section-6d6d0626deeb0ce0f9826f9dabe58c16 class="flex justify-between"><a role=button>并发</a></label><ul><li><a href=/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1/>线程与任务</a></li><li><a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90/>资源访问受限</a></li><li><a href=/zh/docs/java/concurrency/3%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/>获取任务的返回值</a></li><li><a href=/zh/docs/java/concurrency/4%E6%AD%BB%E9%94%81/>死锁</a></li><li><a href=/zh/docs/java/concurrency/5%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1/>终结任务</a></li><li><a href=/zh/docs/java/concurrency/6%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/>生产者-消费者与阻塞队列</a></li><li><a href=/zh/docs/java/concurrency/7%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/ class=active>执行器与线程池</a></li><li><a href=/zh/docs/java/concurrency/8%E8%AE%A1%E5%88%92%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1/>计划执行任务</a></li><li><a href=/zh/docs/java/concurrency/9%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/>一些重要的并发组件</a></li><li><a href=/zh/docs/java/concurrency/10_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/>Java内存模型与volatile关键字(转)</a></li></ul></li><li><input type=checkbox id=section-1fe137527ef46393c946fbc7cb576209 class=toggle>
<label for=section-1fe137527ef46393c946fbc7cb576209 class="flex justify-between"><a role=button>JVM</a></label><ul><li><a href=/zh/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/>Java内存区域详解(转)</a></li><li><a href=/zh/docs/java/jvm/java-gc/>JVM垃圾回收概要(转)</a></li></ul></li></ul></li><li class=book-section-flat><span>所谓开发</span><ul><li><input type=checkbox id=section-e45ae315fd63ae771fd5cd0bb732cd6a class=toggle>
<label for=section-e45ae315fd63ae771fd5cd0bb732cd6a class="flex justify-between"><a role=button>Spring</a></label><ul><li><a href=/zh/docs/utility/spring/SpringBoot-aop-demo/>SpringBoot使用AOP的简单示例</a></li><li><a href=/zh/docs/utility/spring/%E5%9C%A8SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8MockMvc%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/>在SpringBoot项目中使用MockMvc进行接口测试</a></li><li><a href=/zh/docs/utility/spring/spring-transaction-propagation/>spring声明式事务的使用</a></li></ul></li><li><input type=checkbox id=section-94c876711ff851f5a564bef513938730 class=toggle>
<label for=section-94c876711ff851f5a564bef513938730 class="flex justify-between"><a role=button>数据库</a></label><ul><li><input type=checkbox id=section-95d6c3eb8d9a1cf6b58bd1aaaeba338b class=toggle>
<label for=section-95d6c3eb8d9a1cf6b58bd1aaaeba338b class="flex justify-between"><a role=button>mysql</a></label><ul><li><a href=/zh/docs/utility/db/sql/1_%E5%9C%A8centOS%E4%B8%8A%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmysql%E6%95%B0%E6%8D%AE%E5%BA%93/>在centOS上安装并配置mysql数据库</a></li><li><a href=/zh/docs/utility/db/sql/2_MySQL%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/>MySQL中的几个字符串处理函数</a></li><li><a href=/zh/docs/utility/db/sql/4_MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/>MySQL事务与隔离级别</a></li><li><a href=/zh/docs/utility/db/sql/5_%E4%BD%BF%E7%94%A8mysql%E7%9A%84%E8%A1%8C%E9%94%81/>MySQL锁的简单使用</a></li></ul></li><li><input type=checkbox id=section-63fe101f19994c0885fcb00347eb6cc3 class=toggle>
<label for=section-63fe101f19994c0885fcb00347eb6cc3 class="flex justify-between"><a role=button>redis</a></label><ul><li><a href=/zh/docs/utility/db/redis/redis-all/>redis必知必会(转)</a></li><li><a href=/zh/docs/utility/db/redis/build-redis-sentinel/>Redis Sentinel高可用实现</a></li><li><a href=/zh/docs/utility/db/redis/deploy-redis-cluster-with-docker/>使用docker镜像快速搭建redis集群开发环境</a></li><li><a href=/zh/docs/utility/db/redis/bloom-filter/>布隆过滤器(转)</a></li></ul></li></ul></li><li><input type=checkbox id=section-6b3913c766697bc2d56c09ab1e4448be class=toggle>
<label for=section-6b3913c766697bc2d56c09ab1e4448be class="flex justify-between"><a href=/zh/docs/utility/algo/>算法讨论</a></label><ul><li><a href=/zh/docs/utility/algo/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/>同余定理与二进制补码</a></li><li><a href=/zh/docs/utility/algo/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/>移位运算</a></li><li><a href=/zh/docs/utility/algo/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/>异或运算</a></li><li><a href=/zh/docs/utility/algo/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/>位运算的小技巧</a></li><li><a href=/zh/docs/utility/algo/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/>背包问题2例</a></li></ul></li><li><input type=checkbox id=section-a0746926d02d10d842b9d0d7599deab2 class=toggle>
<label for=section-a0746926d02d10d842b9d0d7599deab2 class="flex justify-between"><a role=button>设计模式</a></label><ul><li><input type=checkbox id=section-7081c8a81314efcce430f0f34c6571eb class=toggle>
<label for=section-7081c8a81314efcce430f0f34c6571eb class="flex justify-between"><a role=button>创建型</a></label><ul><li><a href=/zh/docs/utility/design_pattern/creation/1_singleton/>单例模式</a></li><li><a href=/zh/docs/utility/design_pattern/creation/2_factory/>工厂模式</a></li><li><a href=/zh/docs/utility/design_pattern/creation/3_abstract_factory/>抽象工厂模式</a></li><li><a href=/zh/docs/utility/design_pattern/creation/4_builder/>建造者模式</a></li></ul></li><li><input type=checkbox id=section-1adf78989f86ee1fe83f52eacf19986b class=toggle>
<label for=section-1adf78989f86ee1fe83f52eacf19986b class="flex justify-between"><a role=button>行为型</a></label><ul><li><a href=/zh/docs/utility/design_pattern/behaviour/1_command/>命令模式</a></li><li><a href=/zh/docs/utility/design_pattern/behaviour/2_observer/>观察者模式</a></li><li><a href=/zh/docs/utility/design_pattern/behaviour/3_strategy/>策略模式</a></li><li><a href=/zh/docs/utility/design_pattern/behaviour/4_template_method/>模板方法模式</a></li></ul></li><li><input type=checkbox id=section-33da1b959d076efbdb019217cc6e3f10 class=toggle>
<label for=section-33da1b959d076efbdb019217cc6e3f10 class="flex justify-between"><a role=button>结构型</a></label><ul><li><a href=/zh/docs/utility/design_pattern/structure/3_decorator/>装饰者模式</a></li><li><a href=/zh/docs/utility/design_pattern/structure/2_adaptor/>适配器模式</a></li><li><a href=/zh/docs/utility/design_pattern/structure/4_%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/>外观模式</a></li><li><a href=/zh/docs/utility/design_pattern/structure/proxy/>代理模式</a></li></ul></li></ul></li></ul></li><li class=book-section-flat><span>实用主义</span><ul><li><input type=checkbox id=section-e0ec0d59ffd2b577bbabd60a51de9e11 class=toggle>
<label for=section-e0ec0d59ffd2b577bbabd60a51de9e11 class="flex justify-between"><a role=button>定时任务</a></label><ul><li><a href=/zh/docs/misc/job/xxl-sharding-job/>在xxl-job中使用分片任务</a></li><li><a href=/zh/docs/misc/job/%E5%B8%B8%E8%A7%81cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B/>cron表达式速查</a></li></ul></li><li><input type=checkbox id=section-064c88e55046be49abd31400cc335650 class=toggle>
<label for=section-064c88e55046be49abd31400cc335650 class="flex justify-between"><a role=button>版本控制</a></label><ul><li><a href=/zh/docs/misc/vc/Git%E5%85%A5%E9%97%A82/>Git入门2</a></li><li><a href=/zh/docs/misc/vc/Git%E5%85%A5%E9%97%A81/>Git入门1</a></li></ul></li><li><input type=checkbox id=section-2310d269d19e5e48d57d2c9fd6bf08f5 class=toggle>
<label for=section-2310d269d19e5e48d57d2c9fd6bf08f5 class="flex justify-between"><a role=button>翻译文章</a></label><ul><li><a href=/zh/docs/misc/translations/use-springboot-messagesource/>在SpringBoot中使用MessageSource</a></li><li><a href=/zh/docs/misc/translations/guide-to-logback-cn/>使用Logback记录日志</a></li><li><a href=/zh/docs/misc/translations/how2use-printf/>使用printf格式化输出</a></li></ul></li></ul></li></ul><ul><li><a href=/zh/posts/>Blog</a></li><li><a href=/zh/friend/>Links</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>执行器与线程池</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#执行器和线程池>执行器和线程池</a></li><li><a href=#1-executors>1 Executors</a></li><li><a href=#2-executor-框架>2 Executor 框架</a><ul><li><a href=#21-executorservice>2.1 ExecutorService</a></li><li><a href=#22-threadpoolexecutor>2.2 ThreadPoolExecutor</a><ul><li><a href=#221-构造器>2.2.1 构造器</a></li><li><a href=#222-核心概念>2.2.2 核心概念</a><ul><li><a href=#核心线程池与最大线程池><strong>核心线程池与最大线程池</strong></a></li><li><a href=#创建新线程><strong>创建新线程</strong></a></li><li><a href=#存活时间><strong>存活时间</strong></a></li><li><a href=#任务队列><strong>任务队列</strong></a></li><li><a href=#拒绝策略><strong>拒绝策略</strong></a></li></ul></li><li><a href=#223-工厂方法构建的实例>2.2.3 工厂方法构建的实例</a></li></ul></li><li><a href=#24-completionservice>2.4 CompletionService</a></li></ul></li><li><a href=#3-线程池>3 线程池</a><ul><li><a href=#31-线程池的运行状态>3.1 线程池的运行状态</a></li><li><a href=#32-线程池中任务的执行过程>3.2 线程池中任务的执行过程</a><ul><li><a href=#321-提交任务>3.2.1 提交任务</a></li><li><a href=#322-创建空线程>3.2.2 创建空线程</a></li><li><a href=#323-执行任务>3.2.3 执行任务</a></li></ul></li><li><a href=#33-如何合理地关闭线程池>3.3 如何合理地关闭线程池</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=执行器和线程池>执行器和线程池
<a class=anchor href=#%e6%89%a7%e8%a1%8c%e5%99%a8%e5%92%8c%e7%ba%bf%e7%a8%8b%e6%b1%a0>#</a></h1><p>Java并发系列的文章到目前为止，虽然没有特别说明，但是使用执行器(Executor(s))的次数已经难以计数了，<code>Executors</code>提供了一些非常方便的静态方法，可以根据需要创建不同的<code>ExecutorService</code>，然后调用其<code>execute(Runnable)</code>或<code>submit(Callable&lt;T>)</code>方法。在多线程的条件下，执行器还有一个非常明显的优势，它使用线程池管理线程，减少了系统创建和销毁线程的开销。在一般的Java并发过程中，也建议使用执行器完成任务而非显式地创建线程。</p><p>本文将从执行器开始，阐述Java中的线程池。</p><h1 id=1-executors>1 Executors
<a class=anchor href=#1-executors>#</a></h1><p><code>java.util.concurrent.Executors</code>类提供了许多静态方法来获取不同类型的 <strong>线程池</strong>，下表列出其常用方法<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>：</p><table><thead><tr><th style=text-align:left>方法</th><th style=text-align:left>概要</th></tr></thead><tbody><tr><td style=text-align:left>newFixedThreadPool</td><td style=text-align:left>创建固定大小的线程池，线程会一直保留</td></tr><tr><td style=text-align:left>newCachedThreadPool</td><td style=text-align:left>创建线程池，该线程池在必要时创建新线程，旧线程也会被重用，线程空闲60s被销毁</td></tr><tr><td style=text-align:left>newSingleThreadExecutor</td><td style=text-align:left>相当于newFixedThreadPool(1)，其能保证任务顺序执行</td></tr><tr><td style=text-align:left>newScheduledThreadPool</td><td style=text-align:left>创建计划执行一次或周期执行的线程池</td></tr><tr><td style=text-align:left>newSingleThreadScheduledExecutor</td><td style=text-align:left>创建计划执行一次或周期执行的单线程池</td></tr></tbody></table><p style=text-align:center;font-size:.9rem;font-style:italic>Executors用于构造线程池的部分方法</p><p>上表中的前3个方法返回<code>ThreadPoolExecutor</code>实例，后面2个方法返回<code>ScheduledExecutorService</code>实例，不管是ThreadPoolExecutor或是ScheduledExecutorService，都是<code>ExecutorService</code>的实现，<code>ExecutorService</code>接口是设计用来处理任务的接口，其顶层接口是<code>java.util.concurrent.Executor</code>，该接口简单地定义了一个执行任务的方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Executor</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * Executes the given command at some time in the future.  The command
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * may execute in a new thread, in a pooled thread, or in the calling
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * thread, at the discretion of the {@code Executor} implementation.
</span></span></span><span style=display:flex><span><span style=color:#75715e>     *
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @param command the runnable task
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @throws RejectedExecutionException if this task cannot be
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * accepted for execution
</span></span></span><span style=display:flex><span><span style=color:#75715e>     * @throws NullPointerException if command is null
</span></span></span><span style=display:flex><span><span style=color:#75715e>     */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>(Runnable command);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>因此对执行器的讨论最终要回到对<code>Executor</code>及其实现上来。</p><h1 id=2-executor-框架>2 Executor 框架
<a class=anchor href=#2-executor-%e6%a1%86%e6%9e%b6>#</a></h1><p>前文就已经提过，<code>Executors</code>构建的线程池包括不同实现，可以应对不同的场景，那么Java中包含哪些实现呢？</p><img src=/img/juc/executor.png alt=Executor框架组成 width=600px position=center><p>从上面的框架组成图中，可以清晰的看到使用<code>Executors</code>能够构建所有线程池实例，<code>ExecutorService</code>接口定义了一系列和线程池以及任务相关的基本方法，用于检查关闭/关闭线程池，提交任务，执行任务等。</p><p><code>AbstractExecutorService</code>直接实现了<code>ExecutorService</code>的invokeAny/invokeAll方法。此外，从该类的源码可以清晰地看到，所有的任务都是通过转化为<code>RunnableFuture</code>(FutureTask)而后通过<code>execute(Runnable)</code>方法执行的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> RunnableFuture<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>newTaskFor</span>(Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> callable) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> FutureTask<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(callable);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>submit</span>(Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> task) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (task <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException();
</span></span><span style=display:flex><span>    RunnableFuture<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> ftask <span style=color:#f92672>=</span> newTaskFor(task);
</span></span><span style=display:flex><span>    execute(ftask);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ftask;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>protected</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> RunnableFuture<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>newTaskFor</span>(Runnable runnable, T value) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> FutureTask<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(runnable, value);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> Future<span style=color:#f92672>&lt;?&gt;</span> submit(Runnable task) {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>if</span> (task <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException();
</span></span><span style=display:flex><span>   RunnableFuture<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> ftask <span style=color:#f92672>=</span> newTaskFor(task, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>   execute(ftask);
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> ftask;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>submit</span>(Runnable task, T result) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (task <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException();
</span></span><span style=display:flex><span>    RunnableFuture<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> ftask <span style=color:#f92672>=</span> newTaskFor(task, result);
</span></span><span style=display:flex><span>    execute(ftask);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ftask;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>ScheduledExecutorService</code>接口继承自<code>ExecutorService</code>，定义了用于计划执行或周期执行的线程池方法。</p><p><code>ThreadPoolExecutor</code>继承自<code>AbstractExecutorService</code>，是线程池重要的实现之一。</p><p><code>ScheduledThreadPoolExecutor</code>继承自<code>ScheduledExecutorService</code>，是线程池重要的实现之二。</p><p><code>ForkJoinPool</code>继承自<code>AbstractExecutorService</code>，是线程池的重要实现之三，关于它的内容将单独展开。</p><p><code>DelegatedExecutorService</code>继承自<code>AbstractExecutorService</code>，它是<code>Executors</code>的内部类，是一个仅仅实现了<code>ExecutorService</code>方法的包装类，其有两个子类分别是<code>DelegatedScheduledExecutorServide</code>和<code>FinalizableDelegatedExecutorService</code>。</p><p><code>CompletionService</code>接口有一个子类<code>ExecutorCompletionService</code>，该类由执行器实例化，用来管理执行器执行的任务的结果。</p><h2 id=21-executorservice>2.1 ExecutorService
<a class=anchor href=#21-executorservice>#</a></h2><p>ExecutorService是次顶层接口，定义了线程池操作任务的基本方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 继承自Executor的方法</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>(Runnable command);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*有序地关闭线程池，已经提交（在运行或已经在队列中）的任务不会受到影响，将继续执行，
</span></span></span><span style=display:flex><span><span style=color:#75715e>    但线程池不接受新任务的提交
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    此法不会在当前线程上等待线程池后台任务的执行结果（或者任务执行后的作用），换言之，
</span></span></span><span style=display:flex><span><span style=color:#75715e>    如果想要获取任务执行之后的结果，调用此法无法达到目的*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>List<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>shutdownNow</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*尝试去停止(stop)所有活动的任务，已提交且队列中的中的任务将取消执行，并返回取消的任务队列。
</span></span></span><span style=display:flex><span><span style=color:#75715e>    向正在执行的任务发送中断命令，那些无法响应中断命令的任务将无法中止
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    和shutdown()方法一样，此法不会等待正在执行的任务终止*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isShutdown</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果线程池已经关闭，返回true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isTerminated</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*如果所有的任务都完成（中止运行或正常运行完成），则返回true
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    注意，若没有先调用shutdown()或shutdownNow()，此方法不可能返回true*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>awaitTermination</span>(<span style=color:#66d9ef>long</span> timeout, TimeUnit unit) <span style=color:#66d9ef>throws</span> InterruptedException;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*线程池shutdown请求之后，阻塞当前线程，等待任务执行。当超时，任务执行完毕，或当前线程被中断
</span></span></span><span style=display:flex><span><span style=color:#75715e>    任一情况发生时，终止阻塞*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>submit</span>(Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> task);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 提交一个有返回结果的Callable任务</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>submit</span>(Runnable task, T result);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 提交一个Runnable并指定其返回result</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Future<span style=color:#f92672>&lt;?&gt;</span> submit(Runnable task);
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*提交一个Runnable，返回的Future&lt;?&gt;的get方法将返回null，其主要目的是利用Future的其他
</span></span></span><span style=display:flex><span><span style=color:#75715e>    方法控制任务的执行*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> List<span style=color:#f92672>&lt;</span>Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>invokeAll</span>(Collection<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> tasks)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> InterruptedException;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*执行集合中包含的任务，并返回一个Future&lt;T&gt;集合，Future&lt;T&gt;集合包含各个任务的执行状态及结果
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    Future&lt;T&gt;集合中的的顺序和任务集合中的迭代顺序是一致的
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    这个方法会等待所有的任务执行完成（正常执行或抛出异常），如果任务集合在执行过程中被修改，那么
</span></span></span><span style=display:flex><span><span style=color:#75715e>    任务的结果将会变为undefined*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> List<span style=color:#f92672>&lt;</span>Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>invokeAll</span>(Collection<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> tasks,
</span></span><span style=display:flex><span>                                  <span style=color:#66d9ef>long</span> timeout, TimeUnit unit)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> InterruptedException;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 执行集合中包含的任务，在所有任务执行完成或超时之前返回一个Future&lt;T&gt;集合。在返回之前，
</span></span></span><span style=display:flex><span><span style=color:#75715e>    未能执行的任务将被取消
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    其他的特征和重载方法一致*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> T <span style=color:#a6e22e>invokeAny</span>(Collection<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> tasks)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> InterruptedException, ExecutionException;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 执行给定的任务集合中的任务，返回任何一个成功执行的任务的结果，其他未完成的任务被取消
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    如果任务集合在执行过程中被修改，那么任务的结果将会变为undefined*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> T <span style=color:#a6e22e>invokeAny</span>(Collection<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> tasks,
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>long</span> timeout, TimeUnit unit)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> InterruptedException, ExecutionException, TimeoutException;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* 执行给定的任务集合中的任务，在超时之前返回任何一个成功执行的任务的结果，
</span></span></span><span style=display:flex><span><span style=color:#75715e>    其他未完成的任务被取消
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>    如果任务集合在执行过程中被修改，那么任务的结果将会变为undefined*/</span>
</span></span></code></pre></div><p>如上所示，ExecutorService定义了线程池的基本方法，其中<code>invokeAny</code>和<code>invokeAll</code>方法在<code>AbstractExecutorService</code>中实现。</p><h2 id=22-threadpoolexecutor>2.2 ThreadPoolExecutor
<a class=anchor href=#22-threadpoolexecutor>#</a></h2><p>该类是执行器(线程池)的核心类，一般来讲，Java的线程池，指的就是ThreadPoolExecutor实例。</p><h3 id=221-构造器>2.2.1 构造器
<a class=anchor href=#221-%e6%9e%84%e9%80%a0%e5%99%a8>#</a></h3><p>ThreadPoolExecutor提供了4个构造器用来构造线程池实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ThreadPoolExecutor</span>(<span style=color:#66d9ef>int</span> corePoolSize,
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>int</span> maximumPoolSize,
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>long</span> keepAliveTime,
</span></span><span style=display:flex><span>                          TimeUnit unit,
</span></span><span style=display:flex><span>                          BlockingQueue<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> workQueue) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
</span></span><span style=display:flex><span>         Executors.<span style=color:#a6e22e>defaultThreadFactory</span>(), defaultHandler);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ThreadPoolExecutor</span>(<span style=color:#66d9ef>int</span> corePoolSize,
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>int</span> maximumPoolSize,
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>long</span> keepAliveTime,
</span></span><span style=display:flex><span>                          TimeUnit unit,
</span></span><span style=display:flex><span>                          BlockingQueue<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> workQueue,
</span></span><span style=display:flex><span>                          ThreadFactory threadFactory) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
</span></span><span style=display:flex><span>        threadFactory, defaultHandler);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ThreadPoolExecutor</span>(<span style=color:#66d9ef>int</span> corePoolSize,
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>int</span> maximumPoolSize,
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>long</span> keepAliveTime,
</span></span><span style=display:flex><span>                          TimeUnit unit,
</span></span><span style=display:flex><span>                          BlockingQueue<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> workQueue,
</span></span><span style=display:flex><span>                          RejectedExecutionHandler handler) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
</span></span><span style=display:flex><span>         Executors.<span style=color:#a6e22e>defaultThreadFactory</span>(), handler);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#a6e22e>ThreadPoolExecutor</span>(<span style=color:#66d9ef>int</span> corePoolSize,
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>int</span> maximumPoolSize,
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>long</span> keepAliveTime,
</span></span><span style=display:flex><span>                          TimeUnit unit,
</span></span><span style=display:flex><span>                          BlockingQueue<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> workQueue,
</span></span><span style=display:flex><span>                          ThreadFactory threadFactory,
</span></span><span style=display:flex><span>                          RejectedExecutionHandler handler) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (corePoolSize <span style=color:#f92672>&lt;</span> 0 <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        maximumPoolSize <span style=color:#f92672>&lt;=</span> 0 <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        maximumPoolSize <span style=color:#f92672>&lt;</span> corePoolSize <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>        keepAliveTime <span style=color:#f92672>&lt;</span> 0)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (workQueue <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> threadFactory <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> handler <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>acc</span> <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>getSecurityManager</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>null</span> : AccessController.<span style=color:#a6e22e>getContext</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>corePoolSize</span> <span style=color:#f92672>=</span> corePoolSize;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>maximumPoolSize</span> <span style=color:#f92672>=</span> maximumPoolSize;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>workQueue</span> <span style=color:#f92672>=</span> workQueue;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>keepAliveTime</span> <span style=color:#f92672>=</span> unit.<span style=color:#a6e22e>toNanos</span>(keepAliveTime);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>threadFactory</span> <span style=color:#f92672>=</span> threadFactory;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>handler</span> <span style=color:#f92672>=</span> handler;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从构造器来看呢，要构建一个线程池实例，至少需要提供5个参数，另外2个参数不提供则可以使用默认配置<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，这些参数分别是：</p><table><thead><tr><th style=text-align:left>参数</th><th style=text-align:left>描述</th></tr></thead><tbody><tr><td style=text-align:left>corePoolSize</td><td style=text-align:left>核心线程池大小</td></tr><tr><td style=text-align:left>maximumPoolSize</td><td style=text-align:left>最大线程池大小</td></tr><tr><td style=text-align:left>keepAliveTime</td><td style=text-align:left>非核心线程执行完任务后最长的空间等待时间，超时则销毁线程</td></tr><tr><td style=text-align:left>unit</td><td style=text-align:left>keepAliveTime的单位</td></tr><tr><td style=text-align:left>workQueue</td><td style=text-align:left>用于保存待执行任务的队列</td></tr><tr><td style=text-align:left>threadFactory</td><td style=text-align:left>用于创建线程的线程工厂</td></tr><tr><td style=text-align:left>handler</td><td style=text-align:left>线程池满载（队列无空间，且不能新建线程）后，处理新提交任务的拒绝策略</td></tr></tbody></table><p>这些构造器参数就是线程池的核心概念，理解这几个参数在线程池运行过程中的意义便理解了线程池的大半。</p><h3 id=222-核心概念>2.2.2 核心概念
<a class=anchor href=#222-%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5>#</a></h3><h4 id=核心线程池与最大线程池><strong>核心线程池与最大线程池</strong>
<a class=anchor href=#%e6%a0%b8%e5%bf%83%e7%ba%bf%e7%a8%8b%e6%b1%a0%e4%b8%8e%e6%9c%80%e5%a4%a7%e7%ba%bf%e7%a8%8b%e6%b1%a0>#</a></h4><p>线程池的<code>getPoolSize()</code>方法返回的线程数不应该超过线程池的核心线程池大小（corePoolSize）<strong>或</strong> 最大线程池大小（maximumPoolSize）。线程池中的工作线程数不可能超过最大线程池大小。若想获得当前的正在执行任务的线程数，需使用<code>getActiveCount()</code>方法。</p><p>当一个任务被提交至线程池后<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>，若：</p><ul><li>当前工作线程数 &lt; corePoolSize，新建一个线程来完成任务——尽管可能有空闲核心线程。
(当工作线程数 &lt; corePoolSize时，任务队列一定是空的)</li><li>corePoolSize &lt; 当前工作线程数 &lt; maximumPoolSize，并且任务队列已满，那么新建一个<strong>非核心线</strong>程来完成任务。</li></ul><p>当设置corePoolSize=maximumPoolSize时，你将获得一个固定容量的线程池；当将maxPoolSize设置为Integer.MAX_VALUE时，线程数没有限制，这有可能造成<strong>内存泄漏</strong>。</p><p>尽管在构建线程池实例时要指定corePoolSize和maximumPoolSize，在获得实例之后还可以通过<code>setCorePoolSize(int)</code>和<code>setMaximumPoolSize(int)</code>来对其进行修改<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>。</p><p>默认情况下，当线程池初始化成功之后，池中是<strong>没有任何线程的</strong>。不过，可以调用<code>prestartCoreThread()</code>和<code>prestartAllCoreThreads()</code>来向线程池中添加一个或所有核心线程。如果你使用一个非空的任务队列初始化线程池，这样做是有用的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>initPoolWithNonEmptyQueue</span>() {
</span></span><span style=display:flex><span>    BlockingQueue<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> queue <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayBlockingQueue<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span>(2) {{
</span></span><span style=display:flex><span>        add(() <span style=color:#f92672>-&gt;</span> {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;1st task done&#34;</span>);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        add(()<span style=color:#f92672>-&gt;</span>{
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;2nd task done&#34;</span>);
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ThreadPoolExecutor.<span style=color:#a6e22e>AbortPolicy</span> abortPolicy <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor.<span style=color:#a6e22e>AbortPolicy</span>();
</span></span><span style=display:flex><span>    ThreadPoolExecutor poolExecutor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor(1, 1,
</span></span><span style=display:flex><span>        0, TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>, queue, abortPolicy);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    poolExecutor.<span style=color:#a6e22e>prestartCoreThread</span>();
</span></span><span style=display:flex><span>    poolExecutor.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* output
</span></span></span><span style=display:flex><span><span style=color:#75715e>1st task done
</span></span></span><span style=display:flex><span><span style=color:#75715e>2nd task done
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span><span style=color:#75715e>//:~</span>
</span></span></code></pre></div><p>使用<code>prestartCoreThread()</code>还有一个好处，它可以保证队列中的任务顺序执行。</p><h4 id=创建新线程><strong>创建新线程</strong>
<a class=anchor href=#%e5%88%9b%e5%bb%ba%e6%96%b0%e7%ba%bf%e7%a8%8b>#</a></h4><p>线程池中的线程使用线程工厂<code>ThreadFactory</code>创建，如果没有指定，将使用<code>Executors.defaultThreadFactory</code>。如果线程工厂在创建线程时失败而返回null，那么线程池将无法执行任何任务。</p><h4 id=存活时间><strong>存活时间</strong>
<a class=anchor href=#%e5%ad%98%e6%b4%bb%e6%97%b6%e9%97%b4>#</a></h4><p>keepAliveTime针对的是非核心线程，非核心线程处理完任务后，若在keepAliveTime内没有新任务添加到队列并被其获取并运行，其将被销毁。这是一种资源保护策略，如果线程池的任务突然增多，可能又会创建非核心线程来完成任务。当corePoolSize = maximumPoolSize时，线程池无法创建非核心线程，此时keepAliveTime参数可能没有意义，一般将其设置为0。</p><p>但凡事并非绝对，<code>ThreadPoolExecutor</code>维护一个布尔型变量<code>allowCoreThreadTimeOut</code>，其默认值是false，用来控制核心线程池的“生命”：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If false (default), core threads stay alive even when idle.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If true, core threads use keepAliveTime to time out waiting
</span></span></span><span style=display:flex><span><span style=color:#75715e> * for work.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>boolean</span> allowCoreThreadTimeOut;
</span></span></code></pre></div><p>这个变量的值由<code>allowCoreThreadTimeOut(boolean value)</code>方法修改</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>allowCoreThreadTimeOut</span>(<span style=color:#66d9ef>boolean</span> value) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (value <span style=color:#f92672>&amp;&amp;</span> keepAliveTime <span style=color:#f92672>&lt;=</span> 0)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(<span style=color:#e6db74>&#34;Core threads must have nonzero keep alive times&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (value <span style=color:#f92672>!=</span> allowCoreThreadTimeOut) {
</span></span><span style=display:flex><span>        allowCoreThreadTimeOut <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (value)
</span></span><span style=display:flex><span>            interruptIdleWorkers();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，如果将变量<code>allowCoreThreadTimeOut</code>的值设置为true，那么空闲的核心线程池也将会在keepAliveTime超时之后被销毁(如果没有任务让其执行)。</p><h4 id=任务队列><strong>任务队列</strong>
<a class=anchor href=#%e4%bb%bb%e5%8a%a1%e9%98%9f%e5%88%97>#</a></h4><p>任务队列是一个阻塞队列，一个线程池中只有一个任务队列。任务队列用于缓存当前尚没有线程可执行之的任务，其和线程池之间存在如下的交互关系：</p><ul><li>如果当前工作线程 &lt; corePoolSize，线程池将创建新线程执行任务而非将任务放入队列</li><li>如果当前工作线程 > corePoolSize，线程池倾向于将任务放入队列而非创建新线程执行之</li><li>如果任务无法放入队列（满），并且当前工作线程 &lt; maximumPoolSize，将创建新线程执行之，否则任务将<strong>被拒绝</strong></li></ul><p>任务队列有3种常见实现：</p><ol><li><p>直接运行(direct handoffs)，这种情形的任务队列一般由
<a href=../%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e4%b8%8e%e9%98%bb%e5%a1%9e%e9%98%9f%e5%88%97/#2-3-synchronousqueue>SynchronousQueue</a>实现，这种队列的实现对线程池的要求严苛，如果没有可用的线程即刻执行任务，那么将任务放入队列将失败。在此情形下，一般将maximumPoolSize设置为Integer.MAX_
VALUE以防止线程池拒绝任务。这种实现可能会导致内存泄漏。</p></li><li><p>无界任务队列， 一般由
<a href=../%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e4%b8%8e%e9%98%bb%e5%a1%9e%e9%98%9f%e5%88%97/#2-2-linkedblockingqueue>LinkedBlockingQueue</a>实现，这种情形下，当当前工作线程达到corePoolSize之后，所有新提交的任务都会放入队列中，由于队列无界，就<strong>不会</strong>再创建新线程了，也不会拒绝任务。因此maximumPoolSize这一设置将无意义。如果任务源源不断地提交，有可能任务积压导致内存泄漏。</p></li><li><p>有界队列，一般由
<a href=../%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e4%b8%8e%e9%98%bb%e5%a1%9e%e9%98%9f%e5%88%97/#2-1-arrayblockingqueue>ArrayBlockingQueue</a>实现，使用有界队列可以避免资源耗尽，但是也增加了配置的难度，是应该配置更多的线程数更小的队列还是应该配置更大的队列更少的线程数，往往需要根据具体的任务来考量。</p></li></ol><h4 id=拒绝策略><strong>拒绝策略</strong>
<a class=anchor href=#%e6%8b%92%e7%bb%9d%e7%ad%96%e7%95%a5>#</a></h4><p>前面提到，如果线程池满载，新提交的任务就会被线程池拒绝执行；同样的，如果线程池关闭了，提交任务也会被拒绝。线程池通过调用<code>RejectedExecutionHandler.rejectedExecution(Runnable, ThreadPoolExecutor)</code>来拒绝任务，<code>ThreadPoolExecutor</code>内建了4种不同的拒绝策略：</p><p>1） <code>ThreadPoolExecutor.AbortPolicy</code>，也是默认的拒绝策略，该策略直接抛出<code>RejectedExecutionException</code>的运行时异常</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rejectedExecution</span>(Runnable r, ThreadPoolExecutor e) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RejectedExecutionException(<span style=color:#e6db74>&#34;Task &#34;</span> <span style=color:#f92672>+</span> r.<span style=color:#a6e22e>toString</span>() <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                                         <span style=color:#e6db74>&#34; rejected from &#34;</span> <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                                         e.<span style=color:#a6e22e>toString</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>2） <code>ThreadPoolExecutor.CallerRunsPolicy</code>，如果线程池未关闭，该策略直接在执行<code>execute()</code>方法的线程上运行任务，否则该任务被丢弃</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rejectedExecution</span>(Runnable r, ThreadPoolExecutor e) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>e.<span style=color:#a6e22e>isShutdown</span>()) {
</span></span><span style=display:flex><span>        r.<span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>3）<code>ThreadPoolExecutor.DiscardPolicy</code>，该策略直接丢弃不能被执行的任务</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rejectedExecution</span>(Runnable r, ThreadPoolExecutor e) {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>4）<code>ThreadPoolExecutor.DiscardOldestPolicy</code>，如果线程池未关闭，则将队列头部的任务丢弃，然后继续执行<code>execute(Runnable)</code>方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rejectedExecution</span>(Runnable r, ThreadPoolExecutor e) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>e.<span style=color:#a6e22e>isShutdown</span>()) {
</span></span><span style=display:flex><span>        e.<span style=color:#a6e22e>getQueue</span>().<span style=color:#a6e22e>poll</span>();
</span></span><span style=display:flex><span>        e.<span style=color:#a6e22e>execute</span>(r);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=223-工厂方法构建的实例>2.2.3 工厂方法构建的实例
<a class=anchor href=#223-%e5%b7%a5%e5%8e%82%e6%96%b9%e6%b3%95%e6%9e%84%e5%bb%ba%e7%9a%84%e5%ae%9e%e4%be%8b>#</a></h3><p><code>Executors</code>的三个方法(没有包含重载方法)返回该类的实例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ExecutorService <span style=color:#a6e22e>newFixedThreadPool</span>(<span style=color:#66d9ef>int</span> nThreads) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor(nThreads, nThreads,
</span></span><span style=display:flex><span>                                      0L, TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>,
</span></span><span style=display:flex><span>                                      <span style=color:#66d9ef>new</span> LinkedBlockingQueue<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* 构建一个固定容量的线程池，该线程池的线程都是核心线程，任务队列使用无界队列；当线程数达到
</span></span></span><span style=display:flex><span><span style=color:#75715e>corePoolSize时，新提交的任务都将放入队列，这个线程池不会拒绝任务*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ExecutorService <span style=color:#a6e22e>newCachedThreadPool</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> ThreadPoolExecutor(0, Integer.<span style=color:#a6e22e>MAX_VALUE</span>,
</span></span><span style=display:flex><span>                                      60L, TimeUnit.<span style=color:#a6e22e>SECONDS</span>,
</span></span><span style=display:flex><span>                                      <span style=color:#66d9ef>new</span> SynchronousQueue<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* 构建一个corePoolSize为0，maximumPoolSize无限制的线程池，线程池中的线程都是非核心线程，
</span></span></span><span style=display:flex><span><span style=color:#75715e>当线程空闲超过60s后即被销毁，这个线程池的任务队列使用的是SynchronousQueue，因此一旦提交任务，
</span></span></span><span style=display:flex><span><span style=color:#75715e>即会创建一个线程去执行之*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> ExecutorService <span style=color:#a6e22e>newSingleThreadExecutor</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> FinalizableDelegatedExecutorService
</span></span><span style=display:flex><span>            (<span style=color:#66d9ef>new</span> ThreadPoolExecutor(1, 1,
</span></span><span style=display:flex><span>                                    0L, TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>,
</span></span><span style=display:flex><span>                                    <span style=color:#66d9ef>new</span> LinkedBlockingQueue<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span>()));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* 构建一个corePoolSize = maximumPoolSize = 1的线程池，该线程池只有一个核心线程，任务
</span></span></span><span style=display:flex><span><span style=color:#75715e>队列为无界队列，因此当核心线程已被创建后，所有提交的任务都放入队列，这个线程池不会拒绝任务。与
</span></span></span><span style=display:flex><span><span style=color:#75715e>第一个静态方法不同的是，由于其使用FinalizableDelegatedExecutorService包装
</span></span></span><span style=display:flex><span><span style=color:#75715e>ThreadPoolExecutor，这个线程池一旦初始化，不允许再进行动态配置*/</span>
</span></span></code></pre></div><p>如上所示，前2个静态方法构造的都是特殊的<code>ThreadPoolExecutor实例</code>，初始化成功之后，都是可以通过<code>ThreadPoolExecutor</code>的实例方法进行动态配置的。</p><p>第3个静态方法有所不同，其生成了一个容量为1且不可改变的线程池，严格来说，它返回的不是<code>ThreadPoolExecutor</code>实例，而是由<code>ThreadPoolExecutor</code>包装的<code>FinalizableDelegatedExecutorService</code>实例，<code>FinalizableDelegatedExecutorService</code>是Executors类（仅具有包访问权限）的内部类，<code>FinalizableDelegatedExecutorService</code>类继自<code>DelegatedExecutorService</code>，这是一个仅仅有<code>ExecutorService</code>接口方法的包装类，因此，当我们调用<code>newSingleThreadExecutor()</code>方法时，仅可以将其声明为<code>ExecutorService</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>ExecutorService service <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newSingleThreadExecutor</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ！非法，不能强制类型转换</span>
</span></span><span style=display:flex><span>ThreadPoolExecutor pool <span style=color:#f92672>=</span> (ThreadPoolExecutor)Executors.<span style=color:#a6e22e>newSingleThreadExecutor</span>();
</span></span></code></pre></div><p>正因为其是一个仅仅可以执行<code>ExecutorService</code>接口方法的包装类，其无法在线程池初始化之后再动态配置。</p><p>扩展阅读:
<a href=/file/ThreadPoolExecutor_doc.pdf>ThreadPoolExecutor jdk1.8 Javadoc</a></p><h2 id=24-completionservice>2.4 CompletionService
<a class=anchor href=#24-completionservice>#</a></h2><p>在提交单个任务时，使用<code>submit()</code>或者<code>execute()</code>方法或许能够满足要求，但如果需要控制多个任务时，依次提交的操作看起来“有些繁琐”，此时我们可以使用ExecutorService提供的invokeAny/invokeAll方法，在介绍CompletionService接口时，我们不妨先看看这两个方法。</p><p>之前介绍<code>AbstractExecutorService</code>时提到，这两个方法是在这个抽象类中实现的，其中前者在获取到一个任务的返回值时便取消其他（未执行或正在执行的任务）任务，而后者需要等待所有的任务执行完成之后才能对任务的返回进行处理，接下来我们分别来看：</p><p>invokeAll会阻塞等待所有的任务执行完成。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> List<span style=color:#f92672>&lt;</span>Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>invokeAll</span>(Collection<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> tasks)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tasks <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException();
</span></span><span style=display:flex><span>    ArrayList<span style=color:#f92672>&lt;</span>Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> futures <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span>(tasks.<span style=color:#a6e22e>size</span>());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> done <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> t : tasks) {
</span></span><span style=display:flex><span>            RunnableFuture<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> f <span style=color:#f92672>=</span> newTaskFor(t);
</span></span><span style=display:flex><span>            futures.<span style=color:#a6e22e>add</span>(f);
</span></span><span style=display:flex><span>            execute(f);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 有序迭代</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, size <span style=color:#f92672>=</span> futures.<span style=color:#a6e22e>size</span>(); i <span style=color:#f92672>&lt;</span> size; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> f <span style=color:#f92672>=</span> futures.<span style=color:#a6e22e>get</span>(i);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>f.<span style=color:#a6e22e>isDone</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 阻塞等待任务执行完成</span>
</span></span><span style=display:flex><span>                    f.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (CancellationException ignore) {
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (ExecutionException ignore) {
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        done <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> futures;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>done)
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 处理因异常而未正常执行的任务</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, size <span style=color:#f92672>=</span> futures.<span style=color:#a6e22e>size</span>(); i <span style=color:#f92672>&lt;</span> size; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                futures.<span style=color:#a6e22e>get</span>(i).<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// invokeAny</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> T <span style=color:#a6e22e>invokeAny</span>(Collection<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> tasks)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throws</span> InterruptedException, ExecutionException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> doInvokeAny(tasks, <span style=color:#66d9ef>false</span>, 0);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (TimeoutException cannotHappen) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>assert</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> T <span style=color:#a6e22e>doInvokeAny</span>(Collection<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> tasks,
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>boolean</span> timed, <span style=color:#66d9ef>long</span> nanos)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throws</span> InterruptedException, ExecutionException, TimeoutException {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tasks <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ntasks <span style=color:#f92672>=</span> tasks.<span style=color:#a6e22e>size</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (ntasks <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException();
</span></span><span style=display:flex><span>    ArrayList<span style=color:#f92672>&lt;</span>Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> futures <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span>(ntasks);
</span></span><span style=display:flex><span>    ExecutorCompletionService<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> ecs <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> ExecutorCompletionService<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Record exceptions so that if we fail to obtain any</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// result, we can throw the last exception we got.</span>
</span></span><span style=display:flex><span>        ExecutionException ee <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>long</span> deadline <span style=color:#f92672>=</span> timed <span style=color:#f92672>?</span> System.<span style=color:#a6e22e>nanoTime</span>() <span style=color:#f92672>+</span> nanos : 0L;
</span></span><span style=display:flex><span>        Iterator<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&gt;</span> it <span style=color:#f92672>=</span> tasks.<span style=color:#a6e22e>iterator</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Start one task for sure; the rest incrementally</span>
</span></span><span style=display:flex><span>        futures.<span style=color:#a6e22e>add</span>(ecs.<span style=color:#a6e22e>submit</span>(it.<span style=color:#a6e22e>next</span>()));
</span></span><span style=display:flex><span>        <span style=color:#f92672>--</span>ntasks;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> active <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 并没阻塞第一个任务，此时可能第一个任务还未执行完</span>
</span></span><span style=display:flex><span>            Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> f <span style=color:#f92672>=</span> ecs.<span style=color:#a6e22e>poll</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (f <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (ntasks <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>                    <span style=color:#f92672>--</span>ntasks;
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 不等待上一个任务的结果，直接新执行一个任务</span>
</span></span><span style=display:flex><span>                    futures.<span style=color:#a6e22e>add</span>(ecs.<span style=color:#a6e22e>submit</span>(it.<span style=color:#a6e22e>next</span>()));
</span></span><span style=display:flex><span>                    <span style=color:#f92672>++</span>active;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (active <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (timed) {
</span></span><span style=display:flex><span>                    f <span style=color:#f92672>=</span> ecs.<span style=color:#a6e22e>poll</span>(nanos, TimeUnit.<span style=color:#a6e22e>NANOSECONDS</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (f <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> TimeoutException();
</span></span><span style=display:flex><span>                    nanos <span style=color:#f92672>=</span> deadline <span style=color:#f92672>-</span> System.<span style=color:#a6e22e>nanoTime</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 没有可执行的任务了，则等待一个结果</span>
</span></span><span style=display:flex><span>                    f <span style=color:#f92672>=</span> ecs.<span style=color:#a6e22e>take</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 有结果则返回</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (f <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#f92672>--</span>active;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> f.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (ExecutionException eex) {
</span></span><span style=display:flex><span>                    ee <span style=color:#f92672>=</span> eex;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (RuntimeException rex) {
</span></span><span style=display:flex><span>                    ee <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ExecutionException(rex);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ee <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>            ee <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ExecutionException();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> ee;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0, size <span style=color:#f92672>=</span> futures.<span style=color:#a6e22e>size</span>(); i <span style=color:#f92672>&lt;</span> size; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 取消还未执行或者执行中的任务</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 中断任务</span>
</span></span><span style=display:flex><span>            futures.<span style=color:#a6e22e>get</span>(i).<span style=color:#a6e22e>cancel</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，与invokeAll不同的是，invokeAny方法是在循环的启动任务，直到获取到任一任务的返回值为止，而未执行或正在执行的任务则会被中断。</p><p>下面的示例中，我们修改了
<a href=../%e7%94%9f%e4%ba%a7%e8%80%85-%e6%b6%88%e8%b4%b9%e8%80%85%e4%b8%8e%e9%98%bb%e5%a1%9e%e9%98%9f%e5%88%97/#3-1-%e6%9f%a5%e6%89%be%e5%85%b3%e9%94%ae%e5%ad%97>阻塞队列-查找关键字</a>应用，让任务在成功搜寻到含有关键字的文件时就视为任务完成，取消其他任务的执行，这样一种场景之下，我们可以使用invokeAny方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Search1Keyword</span> <span style=color:#66d9ef>extends</span> SearchKeyword {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    String empty <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        Search1Keyword s1k <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Search1Keyword();
</span></span><span style=display:flex><span>        s1k.<span style=color:#a6e22e>find</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>find</span>() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 带资源的try块</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (Scanner in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(System.<span style=color:#a6e22e>in</span>)) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>print</span>(<span style=color:#e6db74>&#34;Enter keyword (e.g. volatile): &#34;</span>);
</span></span><span style=display:flex><span>            keyword <span style=color:#f92672>=</span> in.<span style=color:#a6e22e>nextLine</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Producer p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Producer();
</span></span><span style=display:flex><span>            List<span style=color:#f92672>&lt;</span>Callable<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;&gt;</span> tasks <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            ExecutorService pool <span style=color:#f92672>=</span> Executors.<span style=color:#a6e22e>newCachedThreadPool</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 1; i <span style=color:#f92672>&lt;=</span> 10; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// run consumer</span>
</span></span><span style=display:flex><span>                tasks.<span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>new</span> Consumer1());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            pool.<span style=color:#a6e22e>execute</span>(p);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 此方法并不那么单纯，其结果只取一个，但是任务可能执行了多个</span>
</span></span><span style=display:flex><span>            String res <span style=color:#f92672>=</span> pool.<span style=color:#a6e22e>invokeAny</span>(tasks);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(res);
</span></span><span style=display:flex><span>            pool.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Consumer1</span> <span style=color:#66d9ef>implements</span> Callable<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>call</span>() <span style=color:#66d9ef>throws</span> Exception {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>done) {
</span></span><span style=display:flex><span>                    File file <span style=color:#f92672>=</span> queue.<span style=color:#a6e22e>take</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (file <span style=color:#f92672>==</span> DUMMY) {
</span></span><span style=display:flex><span>                        done <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        String s <span style=color:#f92672>=</span> search1(file, keyword);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (s.<span style=color:#a6e22e>length</span>() <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>return</span> s;
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// ignore</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> empty;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>search1</span>(File file, String keyword) <span style=color:#66d9ef>throws</span> FileNotFoundException {
</span></span><span style=display:flex><span>        StringBuilder sb <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringBuilder(<span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (Scanner in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Scanner(file, <span style=color:#e6db74>&#34;UTF-8&#34;</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> lineNumber <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (in.<span style=color:#a6e22e>hasNextLine</span>()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Thread.<span style=color:#a6e22e>interrupted</span>()) {
</span></span><span style=display:flex><span>                    lineNumber<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                    String line <span style=color:#f92672>=</span> in.<span style=color:#a6e22e>nextLine</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (line.<span style=color:#a6e22e>contains</span>(keyword)) {
</span></span><span style=display:flex><span>                        sb.<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34;[&#34;</span>).<span style=color:#a6e22e>append</span>(Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>()).<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34;]: &#34;</span>)
</span></span><span style=display:flex><span>                            .<span style=color:#a6e22e>append</span>(file.<span style=color:#a6e22e>getPath</span>()).<span style=color:#a6e22e>append</span>(lineNumber).<span style=color:#a6e22e>append</span>(line).<span style=color:#a6e22e>append</span>(<span style=color:#e6db74>&#34;\n&#34;</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// thread interrupted by future.cancel()</span>
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[%s] %s%n&#34;</span>, Thread.<span style=color:#a6e22e>currentThread</span>().<span style=color:#a6e22e>getName</span>(), <span style=color:#e6db74>&#34; interrupted&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>return</span> empty;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sb.<span style=color:#a6e22e>toString</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* output (sample1)
</span></span></span><span style=display:flex><span><span style=color:#75715e>Enter keyword (e.g. volatile): take
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-5]: TestBlockingQueue.java39    LiftOff take() throws InterruptedException {
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-5]: TestBlockingQueue.java40        return rockets.take();
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-5]: TestBlockingQueue.java65                    LiftOff rocket = take();
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-5]: TestBlockingQueue.java78                System.out.println(&#34;Interrupted during take()&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-11]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-10]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-6]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-4]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-9]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-3]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-7]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-8]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>(sample2)
</span></span></span><span style=display:flex><span><span style=color:#75715e>Enter keyword (e.g. volatile): take
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-4]: Search1Keyword.java66                    File file = queue.take();
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-2]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-10]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-8]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-5]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-11]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-7]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>[pool-1-thread-9]  interrupted
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span></code></pre></div><p>我们将对一个包含关键字的文件进行的完整搜寻视为任务结束，虽然还可能有其他文件还有关键字，但是搜寻任务不再执行。从输出可以看到，输出的只包含一个文件的关键字信息。另外，我们使用10个任务，其中sample1中其他9个任务都被中断，而sample2中只有7个任务被interrupt，说明情况1中，所有的任务都开始执行了，而情况2中，还有未开始执行的任务(其永远不能执行了)。</p><p>试着思考一个问题，既然invokeAny只需要获取一个任务的返回值即可，那为什么不直接启动第一个任务然后阻塞获取其返回值，而要启动（那么）多任务呢？启动一个任务不是更加简单么？</p><p>我们分析源码时，发现invokeAny使用了<code>ExecutorCompletionService</code>，这个类继承自接口<code>CompletionService</code>，可以用来管理任务提交之后的<code>Future&lt;T></code>对象——将已经完成的Future其放在一个阻塞队列中取用，这样我们就可以回答上面的问题了：</p><p>invokeAny利用<code>ExecutorCompletionService</code>提交任务，并管理任务的返回，这样可以避免单独启动一个任务而需要阻塞很长时间的弊端，启动的多个任务只要有一个任务完成，其放置已完成Future的阻塞队列将变得可用而使invokeAny快速结束。</p><p><code>ExecutorCompletionService</code>的快速用法为:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ExecutorCompletionService<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> ecs <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ExecutorCompletionService<span style=color:#f92672>&lt;&gt;</span>(executor) ;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span>(Callable<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> task : tasks){
</span></span><span style=display:flex><span>    ecs.<span style=color:#a6e22e>submit</span>(task);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> tasks.<span style=color:#a6e22e>size</span>() ; i<span style=color:#f92672>++</span> ) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// get return value</span>
</span></span><span style=display:flex><span>    ecs.<span style=color:#a6e22e>take</span>().<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=3-线程池>3 线程池
<a class=anchor href=#3-%e7%ba%bf%e7%a8%8b%e6%b1%a0>#</a></h1><p>前文说过，<code>ThreadPoolExecutor</code>实例代表了Java线程池，前面我们介绍了<code>ThreadPoolExecutor</code>的构造器和几个核心概念，在本节中，我们着重介绍线程池的执行过程以及线程池的关闭。</p><h2 id=31-线程池的运行状态>3.1 线程池的运行状态
<a class=anchor href=#31-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e8%bf%90%e8%a1%8c%e7%8a%b6%e6%80%81>#</a></h2><p>线程池的运行状态表示了线程池的生命周期，在代码实现中它们使用用一个整数表示：</p><table><thead><tr><th style=text-align:center>状态</th><th style=text-align:center>描述</th></tr></thead><tbody><tr><td style=text-align:center><em><strong>RUNNING</strong></em></td><td style=text-align:center>接受新任务的提交，执行队列中的任务</td></tr><tr><td style=text-align:center><em><strong>SHUTDOWN</strong></em></td><td style=text-align:center>不接受新任务的提交，执行队列中的任务</td></tr><tr><td style=text-align:center><em><strong>STOP</strong></em></td><td style=text-align:center>不接受新任务的提交，不执行队列中的任务，中断正在执行的任务</td></tr><tr><td style=text-align:center><em><strong>TIDYING</strong></em></td><td style=text-align:center>所有任务终止，workerCount = 0 ，执行terminated()方法</td></tr><tr><td style=text-align:center><em><strong>TERMINATED</strong></em></td><td style=text-align:center>terminated()方法执行完毕</td></tr></tbody></table><p>为了方便地判断线程池的运行状态，给上述线程池状态约定了单调的演化关系：</p><table><thead><tr><th style=text-align:center>状态变化</th><th style=text-align:center>条件</th></tr></thead><tbody><tr><td style=text-align:center><em><strong>RUNNING</strong></em> -> <em><strong>SHUTDOWN</strong></em></td><td style=text-align:center>调用<code>shutdown()</code>方法，或者隐式调用了<code>finalize()</code><sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></td></tr><tr><td style=text-align:center>(<em><strong>RUNNING</strong></em>或<em><strong>SHUTDOWN</strong></em>) -> <em><strong>STOP</strong></em></td><td style=text-align:center>调用<code>shutdownNow()</code>方法</td></tr><tr><td style=text-align:center><em><strong>SHUTDOWN</strong></em> -> <em><strong>TIDYING</strong></em></td><td style=text-align:center>当线程池和任务队列都为空时</td></tr><tr><td style=text-align:center><em><strong>STOP</strong></em> -> <em><strong>TIDYING</strong></em></td><td style=text-align:center>线程池为空</td></tr><tr><td style=text-align:center><em><strong>TIDYING</strong></em> -> <em><strong>TERMINATED</strong></em></td><td style=text-align:center>当<code>terminated()</code>方法执行完成</td></tr></tbody></table><p>可以看到，线程池的状态是单调演化的，除了RUNNING状态可以接受任务并执行外，其他的状态都将导致线程池资源关闭。<code>ThreadPoolExecutor</code>类中有几个获取线程池状态的方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** 若线程池的状态不是RUNNING，那么该方法就返回true*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isShutdown</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span> isRunning(ctl.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** 若线程池的状态不是RUNNING，并且状态没有还没有切换到TERMINATED，该方法就返回true
</span></span></span><span style=display:flex><span><span style=color:#75715e>这个方法返回true说明线程池正处于terminae的过程中*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isTerminating</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span> isRunning(c) <span style=color:#f92672>&amp;&amp;</span> runStateLessThan(c, TERMINATED);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** 若线程的状态为TERMINATED，该方法返回true*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isTerminated</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> runStateAtLeast(ctl.<span style=color:#a6e22e>get</span>(), TERMINATED);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=32-线程池中任务的执行过程>3.2 线程池中任务的执行过程
<a class=anchor href=#32-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e4%b8%ad%e4%bb%bb%e5%8a%a1%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b>#</a></h2><p>了解了线程池的工作状态，接下来我们尝试去深入任务是如何在线程池中被执行的，以及线程池中核心线程，任务队列以及非核心线程之间是如何协同工作的。</p><p>在
<a href=/zh/#%e4%bb%bb%e5%8a%a1%e9%98%9f%e5%88%97>任务队列</a>中，我们阐述了任务队列与线程池之间存在交互关系，这种交互关系体现了线程池执行任务的重要过程。</p><img src=/img/executor_flow.svg alt=线程池执行流程图 width=600px position=center><p>上面的流程图展示了任务提交到线程池到执行或被拒绝的过程，和在任务队列中的描述相当，接下来我们从源码的角度阐述这一过程。</p><h3 id=321-提交任务>3.2.1 提交任务
<a class=anchor href=#321-%e6%8f%90%e4%ba%a4%e4%bb%bb%e5%8a%a1>#</a></h3><p>在介绍
<a href=/zh/#executorService>ExecutorService</a>时我们提到了AbstractExecutorService基类，它有两个重要的作用：</p><ol><li>将所有的任务提交转变为执行一个FutureTask</li><li>实现了invokeAny/invokeAll方法</li></ol><p>了解到这一点之后，我们将线程池的任务执行重心放在<code>ThreadPoolExecutor</code>的<code>execute(Runnable)</code>方法上：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>(Runnable command) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (command <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当前工作线程数 &lt; corePoolSize</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (workerCountOf(c) <span style=color:#f92672>&lt;</span> corePoolSize) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 直接添加新的工作线程执行之</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (addWorker(command, <span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 若新建失败，则表示rs &gt;= shutdown，任务将会被拒绝</span>
</span></span><span style=display:flex><span>        c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 否则将任务放入队列</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (isRunning(c) <span style=color:#f92672>&amp;&amp;</span> workQueue.<span style=color:#a6e22e>offer</span>(command)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 线程状态RUNNING，任务已放入队列</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// double check</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> recheck <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里double-check的原因是：</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span> isRunning(recheck) <span style=color:#f92672>&amp;&amp;</span> remove(command))
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 1. 线程池可能被shutdown了，这时候直接从队列移除任务并拒绝之</span>
</span></span><span style=display:flex><span>            reject(command);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (workerCountOf(recheck) <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 2. 若corePoolSize = 0，而非核心线程都完成了任务</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 空闲线程超时被销毁之后，就可能出现workerCount = 0 的情况</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 此时添加一个非核心线程去执行队列中的任务</span>
</span></span><span style=display:flex><span>            addWorker(<span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 队列满了，则尝试新建一个非核心线程执行任务，否则拒绝之</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>addWorker(command, <span style=color:#66d9ef>false</span>))
</span></span><span style=display:flex><span>        reject(command);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**使用Worker包装线程来执行任务*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>addWorker</span>(Runnable firstTask, <span style=color:#66d9ef>boolean</span> core) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 循环判断，直到满足新建Worker的条件为止</span>
</span></span><span style=display:flex><span>    retry:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> rs <span style=color:#f92672>=</span> runStateOf(c);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check if queue empty only if necessary.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 解释一下这个return false的逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 1. 若rs = runnning，继续添加worker
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 2. 若rs &gt;= shutdown
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *      2.1 rs &gt;= stop 不新建worker(return false)
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *      2.2 rs = shutdown，firstTask != null，不新建worker (shutdown之后不接受新任务提交)
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *      2.3 rs = shutdown，firstTask = null，workQueue为空，不新建worker
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (rs <span style=color:#f92672>&gt;=</span> SHUTDOWN <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>!</span> (rs <span style=color:#f92672>==</span> SHUTDOWN <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>               firstTask <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>               <span style=color:#f92672>!</span> workQueue.<span style=color:#a6e22e>isEmpty</span>()))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> wc <span style=color:#f92672>=</span> workerCountOf(c);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (wc <span style=color:#f92672>&gt;=</span> CAPACITY <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                wc <span style=color:#f92672>&gt;=</span> (core <span style=color:#f92672>?</span> corePoolSize : maximumPoolSize))
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 线程数量超限</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (compareAndIncrementWorkerCount(c))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span> retry;
</span></span><span style=display:flex><span>            c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();  <span style=color:#75715e>// Re-read ctl</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (runStateOf(c) <span style=color:#f92672>!=</span> rs)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span> retry;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// else CAS failed due to workerCount change; retry inner loop</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> workerStarted <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> workerAdded <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    Worker w <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        w <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Worker(firstTask);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>        Worker(Runnable firstTask) {
</span></span></span><span style=display:flex><span><span style=color:#75715e>            setState(-1); // inhibit interrupts until runWorker
</span></span></span><span style=display:flex><span><span style=color:#75715e>            this.firstTask = firstTask;
</span></span></span><span style=display:flex><span><span style=color:#75715e>            this.thread = getThreadFactory().newThread(this);
</span></span></span><span style=display:flex><span><span style=color:#75715e>        }
</span></span></span><span style=display:flex><span><span style=color:#75715e>        */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> Thread t <span style=color:#f92672>=</span> w.<span style=color:#a6e22e>thread</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (t <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>final</span> ReentrantLock mainLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mainLock</span>;
</span></span><span style=display:flex><span>            mainLock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Recheck while holding lock.</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Back out on ThreadFactory failure or if</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// shut down before lock acquired.</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> rs <span style=color:#f92672>=</span> runStateOf(ctl.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 状态为RUNNING时可以新建Worker执行任务</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 状态为SHUTDOWN时，任务必须为空(不可提交任务)</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (rs <span style=color:#f92672>&lt;</span> SHUTDOWN <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                    (rs <span style=color:#f92672>==</span> SHUTDOWN <span style=color:#f92672>&amp;&amp;</span> firstTask <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (t.<span style=color:#a6e22e>isAlive</span>()) <span style=color:#75715e>// precheck that t is startable</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalThreadStateException();
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 调整字段值</span>
</span></span><span style=display:flex><span>                    workers.<span style=color:#a6e22e>add</span>(w);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> s <span style=color:#f92672>=</span> workers.<span style=color:#a6e22e>size</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>&gt;</span> largestPoolSize)
</span></span><span style=display:flex><span>                        largestPoolSize <span style=color:#f92672>=</span> s;
</span></span><span style=display:flex><span>                    workerAdded <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                mainLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 运行任务</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (workerAdded) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 从Worker的构造器来看，线程t的构造器参数是Worker</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 因此start()实际上执行的是Worker的run()方法</span>
</span></span><span style=display:flex><span>                t.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>                workerStarted <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 线程池创建线程失败，清理资源</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span> workerStarted)
</span></span><span style=display:flex><span>            addWorkerFailed(w);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 返回true表示线程已创建并启动</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据调用参数的不同，启动的线程可能直接执行任务</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 也可能从队列中获取任务执行</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> workerStarted;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><img src=/img/thread_pool_add_worker.jpg alt=线程池添加worker的流程 width=600px position=center><h3 id=322-创建空线程>3.2.2 创建空线程
<a class=anchor href=#322-%e5%88%9b%e5%bb%ba%e7%a9%ba%e7%ba%bf%e7%a8%8b>#</a></h3><p>前面介绍
<a href=/zh/#%e6%a0%b8%e5%bf%83%e7%ba%bf%e7%a8%8b%e6%b1%a0%e4%b8%8e%e6%9c%80%e5%a4%a7%e7%ba%bf%e7%a8%8b%e6%b1%a0>核心概念</a>的时候说到，线程池初始化成功之后，池中是没有活动线程的，不过线程池具有很好的灵活性，可以进行动态配置。使用<code>prestartCoreThread()</code>和<code>prestartAllCoreThreads()</code>方法可以向线程池中添加<strong>核心</strong>线程，这些线程并没有使用任务初始化，不过其会尝试去队列中获取任务执行，若队列为空，这些线程就会挂起(waiting)<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** 创建一个核心线程*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>prestartCoreThread</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> workerCountOf(ctl.<span style=color:#a6e22e>get</span>()) <span style=color:#f92672>&lt;</span> corePoolSize <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>        addWorker(<span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/** 创建所有核心线程*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>prestartAllCoreThreads</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (addWorker(<span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>        <span style=color:#f92672>++</span>n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> n;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=323-执行任务>3.2.3 执行任务
<a class=anchor href=#323-%e6%89%a7%e8%a1%8c%e4%bb%bb%e5%8a%a1>#</a></h3><p>线程池创建线程是为了执行任务，<code>addWorker()</code>方法成功时会启动线程，线程则会调用Worker的<code>run()</code>方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>    runWorker(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**该方法会循环进行，并且在getTask()方法处阻塞*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>runWorker</span>(Worker w) {
</span></span><span style=display:flex><span>    Thread wt <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>currentThread</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 任务即为创建Worker的入参</span>
</span></span><span style=display:flex><span>    Runnable task <span style=color:#f92672>=</span> w.<span style=color:#a6e22e>firstTask</span>;
</span></span><span style=display:flex><span>    w.<span style=color:#a6e22e>firstTask</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    w.<span style=color:#a6e22e>unlock</span>(); <span style=color:#75715e>// allow interrupts</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> completedAbruptly <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 只要有任务提交或队列不为空，则一直执行</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (task <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> (task <span style=color:#f92672>=</span> getTask()) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            w.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If pool is stopping, ensure thread is interrupted;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// if not, ensure thread is not interrupted.  This</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// requires a recheck in second case to deal with</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// shutdownNow race while clearing interrupt</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果线程池状态为STOP（调用shutdownNow()），则中断线程</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ((runStateAtLeast(ctl.<span style=color:#a6e22e>get</span>(), STOP) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                 (Thread.<span style=color:#a6e22e>interrupted</span>() <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                  runStateAtLeast(ctl.<span style=color:#a6e22e>get</span>(), STOP))) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>!</span>wt.<span style=color:#a6e22e>isInterrupted</span>())
</span></span><span style=display:flex><span>                wt.<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 可扩展方法</span>
</span></span><span style=display:flex><span>                beforeExecute(wt, task);
</span></span><span style=display:flex><span>                Throwable thrown <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    task.<span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (RuntimeException x) {
</span></span><span style=display:flex><span>                    thrown <span style=color:#f92672>=</span> x; <span style=color:#66d9ef>throw</span> x;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (Error x) {
</span></span><span style=display:flex><span>                    thrown <span style=color:#f92672>=</span> x; <span style=color:#66d9ef>throw</span> x;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (Throwable x) {
</span></span><span style=display:flex><span>                    thrown <span style=color:#f92672>=</span> x; <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(x);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 可扩展方法</span>
</span></span><span style=display:flex><span>                    afterExecute(task, thrown);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                task <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                w.<span style=color:#a6e22e>completedTasks</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                w.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        completedAbruptly <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// while循环结束后的动作</span>
</span></span><span style=display:flex><span>        processWorkerExit(w, completedAbruptly);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** 该方法从队列中获取任务，方法会被阻塞(核心线程)或超时阻塞（非核心线程）*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> Runnable <span style=color:#a6e22e>getTask</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> timedOut <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// Did the last poll() time out?</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> rs <span style=color:#f92672>=</span> runStateOf(c);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check if queue empty only if necessary.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果状态为SHUTDOWN，但队列不为空，仍从队列中执行任务</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果状态为STOP，则直接return null</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (rs <span style=color:#f92672>&gt;=</span> SHUTDOWN <span style=color:#f92672>&amp;&amp;</span> (rs <span style=color:#f92672>&gt;=</span> STOP <span style=color:#f92672>||</span> workQueue.<span style=color:#a6e22e>isEmpty</span>())) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// workerCount - 1</span>
</span></span><span style=display:flex><span>            decrementWorkerCount();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> wc <span style=color:#f92672>=</span> workerCountOf(c);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Are workers subject to culling?</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当allowCoreThreadTimeOut被设置时，核心线程超时阻塞</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> timed <span style=color:#f92672>=</span> allowCoreThreadTimeOut <span style=color:#f92672>||</span> wc <span style=color:#f92672>&gt;</span> corePoolSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((wc <span style=color:#f92672>&gt;</span> maximumPoolSize <span style=color:#f92672>||</span> (timed <span style=color:#f92672>&amp;&amp;</span> timedOut))
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> (wc <span style=color:#f92672>&gt;</span> 1 <span style=color:#f92672>||</span> workQueue.<span style=color:#a6e22e>isEmpty</span>())) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (compareAndDecrementWorkerCount(c))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 阻塞队列获取队头任务</span>
</span></span><span style=display:flex><span>            Runnable r <span style=color:#f92672>=</span> timed <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                workQueue.<span style=color:#a6e22e>poll</span>(keepAliveTime, TimeUnit.<span style=color:#a6e22e>NANOSECONDS</span>) :
</span></span><span style=display:flex><span>                workQueue.<span style=color:#a6e22e>take</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 超时未获取到任务 --&gt; line 79 --&gt; return null</span>
</span></span><span style=display:flex><span>            timedOut <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (InterruptedException retry) {
</span></span><span style=display:flex><span>            timedOut <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><img src=/img/thread_pool_run_task.jpg alt=线程池执行任务的流程 width=600px position=center><p>可以看到，线程池中的线程初始化之后，其执行任务的过程是阻塞的，也就是说，线程池中的线程一直处于“stand by”状态，除此之外，我们还可以得到以下信息：</p><ul><li>如果没有设置<code>allowCoreThreadTimeOut</code>，核心线程执行任务的过程将一直进行</li><li>非核心线程的执行任务的过程将在超时之后，方法不返回，循环再次进行，将在try块之前的if语句块中返回null</li><li>当线程池状态为SHUTDOWN时，若队列不为空，仍会去队列中获取任务执行；若状态为STOP，将不会从队列中获取任务</li></ul><p>当出现下列任一情况时，<code>getTask()</code>会返回null结束线程运行：</p><ol><li>workerCount > maximumPoolSize，一般在动配置maximumPoolSize之后出现</li><li>线程池状态为STOP</li><li>线程池状态为SHUTDOWN，且队列为空</li><li>当线程获取队列中的任务超时，且该线程不是队列中的唯一线程或队列为空</li></ol><p>前面3点都比较好理解，第4点有点难以理解，我们使用一个corePoolSize=0的线程池特例加以说明：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cachedPool</span>(){
</span></span><span style=display:flex><span>    ThreadPoolExecutor service <span style=color:#f92672>=</span> (ThreadPoolExecutor) Executors.<span style=color:#a6e22e>newCachedThreadPool</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// service 5秒之后即关闭</span>
</span></span><span style=display:flex><span>    service.<span style=color:#a6e22e>setKeepAliveTime</span>(5,TimeUnit.<span style=color:#a6e22e>SECONDS</span>);
</span></span><span style=display:flex><span>    service.<span style=color:#a6e22e>submit</span>(()<span style=color:#f92672>-&gt;</span>{
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;task done&#34;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们知道，<code>newCachedThreadPool</code>构建一个corePoolSize=0的线程池，因此池中所有的任务在空闲超时都会被超时销毁，我们不妨来看看这一过程是如何发生的；我们将<code>keepAliveTime</code>重新设置为5s，并且向线程池中提交一个任务。</p><blockquote><p>线程池首先会新建一个线程执行任务，调用的是addWorker(firstTask, false)方法；</p><p>在runWorker的第二次循环时，由于firstTask已经被执行，将调用<code>getTask()</code>方法去队列中获取任务。我们知道队列中没有任务，超时时间为5s，5s之后getTask()方法将<code>timeout</code>置为true后进入第二次循环；</p><p>注意此次循环：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>if</span> ((wc <span style=color:#f92672>&gt;</span> maximumPoolSize <span style=color:#f92672>||</span> (timed <span style=color:#f92672>&amp;&amp;</span> timedOut))
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;&amp;</span> (wc <span style=color:#f92672>&gt;</span> 1 <span style=color:#f92672>||</span> workQueue.<span style=color:#a6e22e>isEmpty</span>())) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (compareAndDecrementWorkerCount(c))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不难看出来，第一次wc =1 并且timeout=false，显然是不满足if的条件；第二次则不同，timeout此时为true，workQueue.isEmpty为true，if条件满足；</p><p>此时将 wc-1，并且返回null</p></blockquote><p>返回null之后，runWorker()方法的while循环也会结束，接下来会执行<code>processWorkerExit(w, completedAbruptly)</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**while循环正常结束，completedAbruptly为false*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processWorkerExit</span>(Worker w, <span style=color:#66d9ef>boolean</span> completedAbruptly) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (completedAbruptly) <span style=color:#75715e>// If abrupt, then workerCount wasn&#39;t adjusted</span>
</span></span><span style=display:flex><span>        decrementWorkerCount();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ReentrantLock mainLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mainLock</span>;
</span></span><span style=display:flex><span>    mainLock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 统计已经完成的任务数</span>
</span></span><span style=display:flex><span>        completedTaskCount <span style=color:#f92672>+=</span> w.<span style=color:#a6e22e>completedTasks</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将Worker从HashSet中移除</span>
</span></span><span style=display:flex><span>        workers.<span style=color:#a6e22e>remove</span>(w);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        mainLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 正如其名，「尝试」终止线程池</span>
</span></span><span style=display:flex><span>    tryTerminate();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 若线程池状态为RUNNING or SHUTDOWN</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (runStateLessThan(c, STOP)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>completedAbruptly) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 线程池中的最小线程数</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> min <span style=color:#f92672>=</span> allowCoreThreadTimeOut <span style=color:#f92672>?</span> 0 : corePoolSize;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (min <span style=color:#f92672>==</span> 0 <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span> workQueue.<span style=color:#a6e22e>isEmpty</span>())
</span></span><span style=display:flex><span>                <span style=color:#75715e>//队列非空时，要保证池中有线程运行任务</span>
</span></span><span style=display:flex><span>                min <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (workerCountOf(c) <span style=color:#f92672>&gt;=</span> min)
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 池中还有线程，可以安心返回</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>; <span style=color:#75715e>// replacement not needed</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 否则，向池中加入一个线程</span>
</span></span><span style=display:flex><span>        addWorker(<span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上面方法的最后if条件中，wc=min=0，池中没有线程并且任务队列为空，线程成功完成使命，结束运行。</p><p>综上所述，被创建的线程除了执行被提交的任务之外，还会被阻塞执行队列中的任务，而核心线程和非核心线程在空闲时又会存在处理方式的差异。</p><p>值得一提的是，在上面的<code>newFixedThreadPool()</code>的例子中，线程池提交完任务之后，并没有调用关闭方法，那么线程池能关闭么？</p><p>通过上面的分析，例子中的线程在执行完任务后超时被销毁，此时池中没有线程在运行，队列中也没有任务，<strong>那么就意味着所有的逻辑都已经完成，并没有发生阻塞，线程池中的线程数为0，任务队列为空</strong>，虽然如此，线程池的状态还是<em><strong>RUNNING</strong></em>！线程池并没有终止，其还可以继续提交任务运行，实际上，线程池回到了<em>初始化</em> 时的状态。</p><h2 id=33-如何合理地关闭线程池>3.3 如何合理地关闭线程池
<a class=anchor href=#33-%e5%a6%82%e4%bd%95%e5%90%88%e7%90%86%e5%9c%b0%e5%85%b3%e9%97%ad%e7%ba%bf%e7%a8%8b%e6%b1%a0>#</a></h2><p><code>ThreadPoolExecutor</code>提供了2个关闭线程池的方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shutdown</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ReentrantLock mainLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mainLock</span>;
</span></span><span style=display:flex><span>    mainLock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 检查权限</span>
</span></span><span style=display:flex><span>        checkShutdownAccess();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 修改线程池状态为SHUTDOWN</span>
</span></span><span style=display:flex><span>        advanceRunState(SHUTDOWN);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 中断所有空闲（waiting）的线程</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在condition.await()上阻塞的线程能够响应中断，这就是线程池能够关闭而不阻塞的原因</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞的线程被中断唤醒后继续在getTask()上继续执行，在线程池状态判断时return null而结束</span>
</span></span><span style=display:flex><span>        interruptIdleWorkers();
</span></span><span style=display:flex><span>        onShutdown(); <span style=color:#75715e>// hook for ScheduledThreadPoolExecutor</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        mainLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 执行terminated()（空）方法，将线程状态设置为TERMINATED</span>
</span></span><span style=display:flex><span>    tryTerminate();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>shutdownNow</span>() {
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> tasks;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ReentrantLock mainLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mainLock</span>;
</span></span><span style=display:flex><span>    mainLock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 权限检查</span>
</span></span><span style=display:flex><span>        checkShutdownAccess();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 修改线程池状态为STOP</span>
</span></span><span style=display:flex><span>        advanceRunState(STOP);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 中断所有线程</span>
</span></span><span style=display:flex><span>        interruptWorkers();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 队列中未执行的任务</span>
</span></span><span style=display:flex><span>        tasks <span style=color:#f92672>=</span> drainQueue();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        mainLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    tryTerminate();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> tasks;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>tryTerminate</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*直接返回的条件：
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 1. 线程池状态为RUNNING
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 2. 线程池状态为 TIDYING 或 TERMINATED
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 3. 线程状态为 SHUTDOWN， 且队列不为空
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (isRunning(c) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>            runStateAtLeast(c, TIDYING) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>            (runStateOf(c) <span style=color:#f92672>==</span> SHUTDOWN <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span> workQueue.<span style=color:#a6e22e>isEmpty</span>()))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 若工作线程数 &gt; 0 , 中断一个空闲线程并返回</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (workerCountOf(c) <span style=color:#f92672>!=</span> 0) { <span style=color:#75715e>// Eligible to terminate</span>
</span></span><span style=display:flex><span>            interruptIdleWorkers(ONLY_ONE);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> ReentrantLock mainLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mainLock</span>;
</span></span><span style=display:flex><span>        mainLock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 设置线程池状态为TIDYING</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (ctl.<span style=color:#a6e22e>compareAndSet</span>(c, ctlOf(TIDYING, 0))) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 运行terminated()方法</span>
</span></span><span style=display:flex><span>                    terminated();
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 设置线程状态为TERMINATED</span>
</span></span><span style=display:flex><span>                    ctl.<span style=color:#a6e22e>set</span>(ctlOf(TERMINATED, 0));
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 唤醒awaitTermination方法</span>
</span></span><span style=display:flex><span>                    termination.<span style=color:#a6e22e>signalAll</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            mainLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// else retry on failed CAS</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从上面的分析，我们可以清晰地看到<code>shutdown()</code>和<code>shutdownNow()</code>的区别，前者只中断了空闲线程，后者中断了所有线程；结合前文<code>getTask()</code>方法的表述，前者未被中断的线程还可继续执行并从任务队列中获取任务执行，而后者已经无法从队列中获取任务执行了，这与本节开头对线程池的
<a href=/zh/#3-1-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e8%bf%90%e8%a1%8c%e7%8a%b6%e6%80%81>运行状态</a>的描述一致。</p><p><code>shutdown()</code>和<code>shutdownNow()</code>方法都不能中断正在执行的任务，不过后者对正在执行的任务发送了中断命令，如果任务能够响应中断，即可以作出相应操作。如果想在<code>shutdown()</code>或<code>shutdownNow()</code>执行之后继续获取任务的返回值，只能使用<code>awaitTermination()</code>方法愚蠢地等待。<code>awaitTermination()</code>方法阻塞当前调用该方法的线程，直到任务执行完毕、超时、调用线程被中断3者任一条件发生。</p><p>需要说明的是，如果<code>awaitTermination()</code>阻塞过程中线程池的状态变为<em><strong>TERNMINATD</strong></em>，说明任务执行完毕，返回true；否则返回false或抛出中断异常。</p><p>下面的示例代码演示了<code>shutdown()</code>和<code>shutdownNow()</code>方法的区别：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ExecutorShutdown</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> pointer <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 容量为1的线程池，其能保证提交的任务都是序列化执行的 */</span>
</span></span><span style=display:flex><span>    ThreadPoolExecutor service <span style=color:#f92672>=</span> (ThreadPoolExecutor) Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        ExecutorShutdown es <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ExecutorShutdown();
</span></span><span style=display:flex><span>        es.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>//        es.awaitTermination(1, TimeUnit.SECONDS);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shutdown</span>() {
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> ComplexTask());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对于newFixedThreadPool(1),EasyTask在任务队列中</span>
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> EasyTask());
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// shutdown之后，任务并没有执行完成，pointer的值还是0</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;pointer:&#34;</span> <span style=color:#f92672>+</span> pointer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取待任务队列</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;workQueue: &#34;</span> <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>getQueue</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 判断该执行器是否被关闭</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;is executor shutdown? &#34;</span> <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>isShutdown</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行器关闭之后所有任务是否都完成</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果没有调用shutdown()或shutdownNow()就直接调用isTerminated()，该方法必返回false</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;is executor terminated? &#34;</span> <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>isTerminated</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;pointer:&#34;</span> <span style=color:#f92672>+</span> pointer);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>awaitTermination</span>(<span style=color:#66d9ef>int</span> timeout, TimeUnit unit) {
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> ComplexTask());
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> EasyTask());
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> tasks;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (service.<span style=color:#a6e22e>awaitTermination</span>(timeout, unit)) {
</span></span><span style=display:flex><span>                service.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>(tasks <span style=color:#f92672>=</span> service.<span style=color:#a6e22e>shutdownNow</span>()).<span style=color:#a6e22e>isEmpty</span>()){
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;丢弃任务&#34;</span> <span style=color:#f92672>+</span> tasks);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;workQueue: &#34;</span> <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>getQueue</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;is executor shutdown? &#34;</span> <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>isShutdown</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;is executor terminated? &#34;</span> <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>isTerminated</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Task</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> getClass().<span style=color:#a6e22e>getSimpleName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;@&#34;</span> <span style=color:#f92672>+</span> Integer.<span style=color:#a6e22e>toHexString</span>(hashCode());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ComplexTask</span> <span style=color:#66d9ef>extends</span> Task <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 响应中断，调用shutdownNow()可以结束任务</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;@&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]，开始执行&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// never finish unless interrupted</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (; ; ) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Thread.<span style=color:#a6e22e>interrupted</span>()) {
</span></span><span style=display:flex><span>                    pointer<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;@&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]，被中断&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EasyTask</span> <span style=color:#66d9ef>extends</span> Task <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;@&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]，开始执行&#34;</span>);
</span></span><span style=display:flex><span>            pointer<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;@&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]，执行完成&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* output
</span></span></span><span style=display:flex><span><span style=color:#75715e>调用shutdown：
</span></span></span><span style=display:flex><span><span style=color:#75715e>[Thread[pool-1-thread-1,5,main]@ComplexTask@48d82c9c]，开始执行
</span></span></span><span style=display:flex><span><span style=color:#75715e>pointer:0
</span></span></span><span style=display:flex><span><span style=color:#75715e>workQueue: [EasyTask@14ae5a5]
</span></span></span><span style=display:flex><span><span style=color:#75715e>is executor shutdown? true
</span></span></span><span style=display:flex><span><span style=color:#75715e>is executor terminated? false
</span></span></span><span style=display:flex><span><span style=color:#75715e>pointer:813
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>调用awaitTermination：
</span></span></span><span style=display:flex><span><span style=color:#75715e>[Thread[pool-1-thread-1,5,main]@ComplexTask@7ac59a98]，开始执行
</span></span></span><span style=display:flex><span><span style=color:#75715e>[Thread[pool-1-thread-1,5,main]@ComplexTask@7ac59a98]，被中断
</span></span></span><span style=display:flex><span><span style=color:#75715e>丢弃任务[EasyTask@7f31245a]
</span></span></span><span style=display:flex><span><span style=color:#75715e>workQueue: []
</span></span></span><span style=display:flex><span><span style=color:#75715e>is executor shutdown? true
</span></span></span><span style=display:flex><span><span style=color:#75715e>is executor terminated? true
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span><span style=color:#75715e>//:~</span>
</span></span></code></pre></div><p>上例中我们设计了一个可以正常执行的任务EasyTask和一个无限循环执行的任务ComplexTask，后者响应中断，如果不中断线程，ComplexTask将一直运行下去。我们使用一个固定容量为1的线程池运行任务，并且先提交ComplexTask，ComplexTask无法结束运行，那么EasyTask将会放入队列中。</p><p>从运行的结果上来看，使用<code>shutdown()</code>无法结束线程池的运行，虽然主线程结束，但线程池一直在后台运行，同时EasyTask也还在任务队列中，主线程结束后线程池的还没有终止，程序会一直在后台运行。</p><p>当调用<code>awaitTermination(timeout, unit)</code>时，很明显这个方法将超时并返回false，最终执行<code>shutdownNow()</code>，shutdownNow给ComplexTask任务发送中断命令，其在下一次循环检查到中断，结束执行。同时任务队列中的EasyTask被丢弃，任务队列为空，主线程结束后，线程池也成功终止。</p><p>如果ComplexTask在设计时，没有响应中断，而使用死循环执行任务，那么<code>shutdownNow()</code>方法仍然无法终止线程池，这就是官方文档中关于<code>shutdownNow()</code>方法描述的语义：</p><blockquote><p><em>There are no guarantees beyond best-effort attempts to stop
processing actively executing tasks. This implementation
cancels tasks via {@link Thread#interrupt}, so any task that
fails to respond to interrupts may never terminate.</em></p></blockquote><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>表中没有提及关于构建<code>Fork/Join</code>线程池的方法，这部分内容将在后续补全。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>须调用合适的构造器，实际上所有参数必须提供，不过有些由构造器默认提供。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>本文约定当前工作线程指代线程池中存在的线程（<code>getPoolSize()</code>方法的返回值），其中可能存在部分空闲线程。当工作线程数小于核心线程数时：1）当前线程池中的线程全是核心线程；2）任务队列一定是空的；3）当前某个线程可能是空闲的(执行完任务，在等待队列中的任务（runWorker方法阻塞）)。&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>类似地，存活时间，线程工厂，拒绝策略都可以在线程池初始化之后再进行设置。&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>目前作者还未找到隐式调用<code>finalize()</code>方法导致线程池关闭的例证&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>若corePoolSize=0，这些方法不会创建线程&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//pkendlessriver.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#执行器和线程池>执行器和线程池</a></li><li><a href=#1-executors>1 Executors</a></li><li><a href=#2-executor-框架>2 Executor 框架</a><ul><li><a href=#21-executorservice>2.1 ExecutorService</a></li><li><a href=#22-threadpoolexecutor>2.2 ThreadPoolExecutor</a><ul><li><a href=#221-构造器>2.2.1 构造器</a></li><li><a href=#222-核心概念>2.2.2 核心概念</a><ul><li><a href=#核心线程池与最大线程池><strong>核心线程池与最大线程池</strong></a></li><li><a href=#创建新线程><strong>创建新线程</strong></a></li><li><a href=#存活时间><strong>存活时间</strong></a></li><li><a href=#任务队列><strong>任务队列</strong></a></li><li><a href=#拒绝策略><strong>拒绝策略</strong></a></li></ul></li><li><a href=#223-工厂方法构建的实例>2.2.3 工厂方法构建的实例</a></li></ul></li><li><a href=#24-completionservice>2.4 CompletionService</a></li></ul></li><li><a href=#3-线程池>3 线程池</a><ul><li><a href=#31-线程池的运行状态>3.1 线程池的运行状态</a></li><li><a href=#32-线程池中任务的执行过程>3.2 线程池中任务的执行过程</a><ul><li><a href=#321-提交任务>3.2.1 提交任务</a></li><li><a href=#322-创建空线程>3.2.2 创建空线程</a></li><li><a href=#323-执行任务>3.2.3 执行任务</a></li></ul></li><li><a href=#33-如何合理地关闭线程池>3.3 如何合理地关闭线程池</a></li></ul></li></ul></nav></div></aside></main></body></html>