<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  前文说过，ThreadPoolExecutor实例代表了Java线程池，前面我们介绍了ThreadPoolExecutor的构造器和几个核心概念，在本节中，我们着重介绍线程池的执行过程以及线程池的关闭。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://wangy325.github.io/zh/docs/java/concurrency/7_3_ThreadPoolExecutor2/"><meta property="og:site_name" content="Endless River"><meta property="og:title" content="ThreadPoolExecutor-2"><meta property="og:description" content=" 前文说过，ThreadPoolExecutor实例代表了Java线程池，前面我们介绍了ThreadPoolExecutor的构造器和几个核心概念，在本节中，我们着重介绍线程池的执行过程以及线程池的关闭。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2020-11-03T00:00:00+00:00"><meta property="article:modified_time" content="2024-08-07T16:20:46+08:00"><meta property="article:tag" content="并发"><title>ThreadPoolExecutor-2 | Endless River</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://wangy325.github.io/zh/docs/java/concurrency/7_3_ThreadPoolExecutor2/><link rel=stylesheet href=/book.min.e7654cdd04a0103d5766f90259ce1a8382d778a3aad8c66ddcb97827f5859aff.css integrity="sha256-52VM3QSgED1XZvkCWc4ag4LXeKOq2MZt3Ll4J/WFmv8=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.a7252d8a975fbe35c7092be2a012aa5eba38007825312b1b041eb19213492815.js integrity="sha256-pyUtipdfvjXHCSvioBKqXro4AHglMSsbBB6xkhNJKBU=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-HHNKR5H8KN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-HHNKR5H8KN")}</script></head><body dir=ltr data-bs-spy=scroll data-bs-target=#TableOfContents><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>Endless River</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><a href=/zh/docs/java/>Java</a><ul><li><input type=checkbox id=section-287084f81620420b7ed7e40a42c44d2f class=toggle>
<label for=section-287084f81620420b7ed7e40a42c44d2f class="flex justify-between"><a role=button>Obj-Oriented</a></label><ul><li><a href=/zh/docs/java/basic/1_%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/>访问权限修饰符</a></li><li><a href=/zh/docs/java/basic/2_static%E5%85%B3%E9%94%AE%E5%AD%97/>static关键字</a></li><li><a href=/zh/docs/java/basic/3_%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/>传值还是传引用</a></li><li><a href=/zh/docs/java/basic/4_final%E5%85%B3%E9%94%AE%E5%AD%97/>final关键字</a></li><li><a href=/zh/docs/java/basic/5_Object%E8%B6%85%E7%B1%BB/>Object超类</a></li><li><a href=/zh/docs/java/basic/5_%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A/>动态绑定与静态绑定</a></li><li><a href=/zh/docs/java/basic/6_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/>抽象类与接口</a></li><li><a href=/zh/docs/java/basic/7_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/>Lambda与函数式接口</a></li><li><a href=/zh/docs/java/basic/8_%E5%86%85%E9%83%A8%E7%B1%BB/>内部类</a></li><li><a href=/zh/docs/java/basic/11_java-new-time-api/>Java8日期和时间API</a></li></ul></li><li><input type=checkbox id=section-3d2f820e49b3d97a7a712be90f9fd6ad class=toggle>
<label for=section-3d2f820e49b3d97a7a712be90f9fd6ad class="flex justify-between"><a href=/zh/docs/java/collections/>Collections</a></label><ul><li><a href=/zh/docs/java/collections/1_List_arraylist/>ArrayList</a></li><li><a href=/zh/docs/java/collections/1_List_linkedlist/>LinkedList</a></li><li><a href=/zh/docs/java/collections/2_Queue/>Queue</a></li><li><a href=/zh/docs/java/collections/3_Set/>Set</a></li><li><a href=/zh/docs/java/collections/4_Map_hash_tree_map/>HashMap和TreeMap</a></li><li><a href=/zh/docs/java/collections/4_Map_linkedhashmap/>LinkedHashMap</a></li><li><a href=/zh/docs/java/collections/5_HashMap%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>HashMap的源码分析</a></li><li><a href=/zh/docs/java/collections/6_Collections/>Collections工具类</a></li></ul></li><li><input type=checkbox id=section-6d6d0626deeb0ce0f9826f9dabe58c16 class=toggle checked>
<label for=section-6d6d0626deeb0ce0f9826f9dabe58c16 class="flex justify-between"><a href=/zh/docs/java/concurrency/>Concurrency</a></label><ul><li><a href=/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_1/>线程与任务(一)</a></li><li><a href=/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/>线程与任务(二)</a></li><li><a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_1/>资源访问受限--引论</a></li><li><a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_2_%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6/>锁和条件</a></li><li><a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_3_synchronized/>synchronized关键字</a></li><li><a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_4_%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB/>原子性和可见性</a></li><li><a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_5_%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/>线程本地存储</a></li><li><a href=/zh/docs/java/concurrency/3%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/>获取任务的返回值</a></li><li><a href=/zh/docs/java/concurrency/4%E6%AD%BB%E9%94%81/>死锁问题2例</a></li><li><a href=/zh/docs/java/concurrency/5%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1/>终结任务</a></li><li><a href=/zh/docs/java/concurrency/6%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/>生产者-消费者与阻塞队列</a></li><li><a href=/zh/docs/java/concurrency/6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A82%E4%BE%8B/>阻塞队列的使用2例</a></li><li><a href=/zh/docs/java/concurrency/7_1_Executors_and_ExecutorService/>Executors与Executor框架</a></li><li><a href=/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/>ThreadPoolExecutor-1</a></li><li><a href=/zh/docs/java/concurrency/7_3_ThreadPoolExecutor2/ class=active>ThreadPoolExecutor-2</a></li><li><a href=/zh/docs/java/concurrency/7_4_CompletionService/>CompletionService</a></li><li><a href=/zh/docs/java/concurrency/8_1_ScheduledExecutorService1/>ScheduledExecutorService-1</a></li><li><a href=/zh/docs/java/concurrency/8_2_ScheduledExecutorService2/>ScheduledExecutorService-2</a></li><li><a href=/zh/docs/java/concurrency/9_1_countdownlatch/>并发组件-CountDownLatch</a></li><li><a href=/zh/docs/java/concurrency/9_2_cyclicbarrier/>并发组件-CyclicBarrier</a></li><li><a href=/zh/docs/java/concurrency/9_3_semaphore/>并发组件-Semaphore</a></li><li><a href=/zh/docs/java/concurrency/9_4_exchanger/>并发组件-Exchanger</a></li><li><a href=/zh/docs/java/concurrency/9_5_priorityblockqueue_delayqueue/>并发组件-PBQ/DQ</a></li><li><a href=/zh/docs/java/concurrency/10_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/>JMM与volatile关键字(转)</a></li></ul></li><li><input type=checkbox id=section-1fe137527ef46393c946fbc7cb576209 class=toggle>
<label for=section-1fe137527ef46393c946fbc7cb576209 class="flex justify-between"><a role=button>JVM</a></label><ul><li><a href=/zh/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/>Java内存区域详解(转)</a></li><li><a href=/zh/docs/java/jvm/java-gc/>JVM垃圾回收概要(转)</a></li></ul></li><li><input type=checkbox id=section-162997d8460d3e3e2ce056aadf759dc7 class=toggle>
<label for=section-162997d8460d3e3e2ce056aadf759dc7 class="flex justify-between"><a role=button>Spring</a></label><ul><li><a href=/zh/docs/java/spring/SpringBoot-aop-demo/>SpringBoot使用AOP的简单示例</a></li><li><a href=/zh/docs/java/spring/%E5%9C%A8SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8MockMvc%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/>在SpringBoot项目中使用MockMvc进行接口测试</a></li><li><a href=/zh/docs/java/spring/spring-transaction-propagation/>Spring声明式事务的使用</a></li></ul></li></ul></li><li class=book-section-flat><span>Craft</span><ul><li><input type=checkbox id=section-634f81f2121a26b2cd3998d002677fd7 class=toggle>
<label for=section-634f81f2121a26b2cd3998d002677fd7 class="flex justify-between"><a role=button>Databases</a></label><ul><li><input type=checkbox id=section-a97291ad29c3a3b4bd7c61ffd8d5c44c class=toggle>
<label for=section-a97291ad29c3a3b4bd7c61ffd8d5c44c class="flex justify-between"><a role=button>mysql</a></label><ul><li><a href=/zh/docs/craft/db/sql/1_%E5%9C%A8centOS%E4%B8%8A%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmysql%E6%95%B0%E6%8D%AE%E5%BA%93/>CentOS安装并配置MySQL</a></li><li><a href=/zh/docs/craft/db/sql/2_MySQL%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/>MySQL字符串处理函数</a></li><li><a href=/zh/docs/craft/db/sql/4_MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/>事务隔离级别与MVCC</a></li><li><a href=/zh/docs/craft/db/sql/5_%E4%BD%BF%E7%94%A8mysql%E7%9A%84%E8%A1%8C%E9%94%81/>MySQL显式锁简单介绍</a></li><li><a href=/zh/docs/craft/db/sql/6_mysql%E6%AD%BB%E9%94%81/>MySQL死锁</a></li></ul></li><li><input type=checkbox id=section-bc4b2446005fdca660bd4c972e249165 class=toggle>
<label for=section-bc4b2446005fdca660bd4c972e249165 class="flex justify-between"><a role=button>redis</a></label><ul><li><a href=/zh/docs/craft/db/redis/redis-all/>redis必知必会(转)</a></li><li><a href=/zh/docs/craft/db/redis/build-redis-sentinel/>Redis Sentinel高可用实现</a></li><li><a href=/zh/docs/craft/db/redis/deploy-redis-cluster-with-docker/>使用docker镜像快速搭建redis集群开发环境</a></li><li><a href=/zh/docs/craft/db/redis/bloom-filter/>布隆过滤器(转)</a></li></ul></li></ul></li><li><input type=checkbox id=section-6f60371e3df5bd386999aceaa1852abe class=toggle>
<label for=section-6f60371e3df5bd386999aceaa1852abe class="flex justify-between"><a href=/zh/docs/craft/algo/>Algorithms</a></label><ul><li><a href=/zh/docs/craft/algo/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/>同余定理与二进制补码</a></li><li><a href=/zh/docs/craft/algo/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/>移位运算</a></li><li><a href=/zh/docs/craft/algo/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/>异或运算</a></li><li><a href=/zh/docs/craft/algo/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/>位运算的小技巧</a></li><li><a href=/zh/docs/craft/algo/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/>背包问题2例</a></li></ul></li><li><input type=checkbox id=section-30cbf81626e3b7f7e6edb89d12c78023 class=toggle>
<label for=section-30cbf81626e3b7f7e6edb89d12c78023 class="flex justify-between"><a role=button>Design Patterns</a></label><ul><li><input type=checkbox id=section-42f50c16d27783d3bedd607a7e837d36 class=toggle>
<label for=section-42f50c16d27783d3bedd607a7e837d36 class="flex justify-between"><a role=button>Creation</a></label><ul><li><a href=/zh/docs/craft/design_pattern/creation/1_singleton/>单例模式</a></li><li><a href=/zh/docs/craft/design_pattern/creation/2_factory/>工厂模式</a></li><li><a href=/zh/docs/craft/design_pattern/creation/3_abstract_factory/>抽象工厂模式</a></li><li><a href=/zh/docs/craft/design_pattern/creation/4_builder/>建造者模式</a></li></ul></li><li><input type=checkbox id=section-cb39206110b74ebd45f80b2f90510acc class=toggle>
<label for=section-cb39206110b74ebd45f80b2f90510acc class="flex justify-between"><a role=button>Behaviour</a></label><ul><li><a href=/zh/docs/craft/design_pattern/behaviour/1_command/>命令模式</a></li><li><a href=/zh/docs/craft/design_pattern/behaviour/2_observer/>观察者模式</a></li><li><a href=/zh/docs/craft/design_pattern/behaviour/3_strategy/>策略模式</a></li><li><a href=/zh/docs/craft/design_pattern/behaviour/4_template_method/>模板方法模式</a></li></ul></li><li><input type=checkbox id=section-7db5831683340fa833c951dc3e200088 class=toggle>
<label for=section-7db5831683340fa833c951dc3e200088 class="flex justify-between"><a role=button>Structural</a></label><ul><li><a href=/zh/docs/craft/design_pattern/structure/3_decorator/>装饰者模式</a></li><li><a href=/zh/docs/craft/design_pattern/structure/2_adaptor/>适配器模式</a></li><li><a href=/zh/docs/craft/design_pattern/structure/4_%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/>外观模式</a></li><li><a href=/zh/docs/craft/design_pattern/structure/proxy/>代理模式</a></li></ul></li></ul></li></ul></li><li class=book-section-flat><span>Note</span><ul><li><input type=checkbox id=section-e1b333d5984dfdf0a240ff1b0a6c2115 class=toggle>
<label for=section-e1b333d5984dfdf0a240ff1b0a6c2115 class="flex justify-between"><a href=/zh/docs/note/course/>Courses</a></label><ul><li><input type=checkbox id=section-f0595ab9881a31f8c4cb8d57ad211189 class=toggle>
<label for=section-f0595ab9881a31f8c4cb8d57ad211189 class="flex justify-between"><a href=/zh/docs/note/course/operating_system_peking/>操作系统原理</a></label><ul><li><a href=/zh/docs/note/course/operating_system_peking/1_intro/>引论</a></li><li><a href=/zh/docs/note/course/operating_system_peking/2_env_and_logic/>操作系统运行环境与机制</a></li><li><a href=/zh/docs/note/course/operating_system_peking/3_processes_and_threads/>进程和线程模型</a></li></ul></li><li><input type=checkbox id=section-aaef4b28e93ddde0053a8bd35b72d3fe class=toggle>
<label for=section-aaef4b28e93ddde0053a8bd35b72d3fe class="flex justify-between"><a href=/zh/docs/note/course/algorithms_part1/>算法-第一部分</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-e799e08a1a55553117545d5d0f207e3e class=toggle>
<label for=section-e799e08a1a55553117545d5d0f207e3e class="flex justify-between"><a role=button>Python</a></label><ul><li><input type=checkbox id=section-26a199d4fe1db5db29fee30b4f791172 class=toggle>
<label for=section-26a199d4fe1db5db29fee30b4f791172 class="flex justify-between"><a role=button>Snippets</a></label><ul><li><a href=/zh/docs/note/pys/snippets/1_flow_control/>流程控制语句</a></li><li><a href=/zh/docs/note/pys/snippets/2_data_list/>列表（list）</a></li><li><a href=/zh/docs/note/pys/snippets/3_data_str/>字符串，元组和字典</a></li><li><a href=/zh/docs/note/pys/snippets/4_func/>函数式编程</a></li><li><a href=/zh/docs/note/pys/snippets/4_important_funcs/>4个重要的内置函数</a></li><li><a href=/zh/docs/note/pys/snippets/5_file_io/>格式化输出与文件I/O</a></li><li><a href=/zh/docs/note/pys/snippets/6_try_excep/>异常处理</a></li><li><a href=/zh/docs/note/pys/snippets/7_scope/>命名空间与作用域</a></li><li><a href=/zh/docs/note/pys/snippets/8_class_type/>类与对象</a></li><li><a href=/zh/docs/note/pys/snippets/9_decoration/>闭包与装饰器</a></li><li><a href=/zh/docs/note/pys/snippets/10_decoration_2/>装饰器2</a></li><li><a href=/zh/docs/note/pys/snippets/11_threading/>线程模型</a></li><li><a href=/zh/docs/note/pys/snippets/12_threading_lock/>线程-锁</a></li><li><a href=/zh/docs/note/pys/snippets/13_threading_condition/>线程-条件</a></li><li><a href=/zh/docs/note/pys/snippets/14_threading_semaphore/>线程-信号量</a></li><li><a href=/zh/docs/note/pys/snippets/15_threading_event/>线程-事件</a></li></ul></li></ul></li><li><input type=checkbox id=section-a55bc121ab1723b9dedc870a0f128ac7 class=toggle>
<label for=section-a55bc121ab1723b9dedc870a0f128ac7 class="flex justify-between"><a role=button>Translations</a></label><ul><li><a href=/zh/docs/note/translations/use-springboot-messagesource/>在SpringBoot中使用MessageSource</a></li><li><a href=/zh/docs/note/translations/guide-to-logback-cn/>使用Logback记录日志</a></li><li><a href=/zh/docs/note/translations/how2use-printf/>使用printf格式化输出</a></li></ul></li></ul></li></ul><ul><li><a href=/zh/posts/>Blog</a></li><li><a href=/zh/about/>About</a></li><li><a href=/zh/friend/>Links</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>ThreadPoolExecutor-2</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><div id=toc-new><ul class=nav><li class=nav-item><a id=t线程池的运行状态 href=#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e8%bf%90%e8%a1%8c%e7%8a%b6%e6%80%81>线程池的运行状态</a></li><li class=nav-item><a id=t线程池中任务的执行过程 href=#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e4%b8%ad%e4%bb%bb%e5%8a%a1%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b>线程池中任务的执行过程</a><ul class=nav><li class=nav-item><a id=t提交任务 href=#%e6%8f%90%e4%ba%a4%e4%bb%bb%e5%8a%a1>提交任务</a></li><li class=nav-item><a id=t创建空线程 href=#%e5%88%9b%e5%bb%ba%e7%a9%ba%e7%ba%bf%e7%a8%8b>创建空线程</a></li><li class=nav-item><a id=t执行任务 href=#%e6%89%a7%e8%a1%8c%e4%bb%bb%e5%8a%a1>执行任务</a></li></ul></li><li class=nav-item><a id=t如何合理地关闭线程池 href=#%e5%a6%82%e4%bd%95%e5%90%88%e7%90%86%e5%9c%b0%e5%85%b3%e9%97%ad%e7%ba%bf%e7%a8%8b%e6%b1%a0>如何合理地关闭线程池</a></li></ul></div></aside></header><article class="markdown book-article"><h1><a href=/zh/docs/java/concurrency/7_3_ThreadPoolExecutor2/>ThreadPoolExecutor-2</a></h1><div style=font-size:.9rem><div class="flex align-cneter" style=font-size:.9rem><div class="flex align-cneter" style=margin-right:1rem><img style=width:1rem;margin-inline-end:.5rem src=/svg/edit.svg class=book-icon alt>
<a class=xxx title='创建者 wangy325'>十一月 3, 2020</a></div><div class="flex align-center" style=margin-right:1rem><img style=height:1rem;width:1rem;margin-inline-end:.5rem src=/svg/cates.svg class=book-icon alt>
<a class=xxx href=/zh/categories/java/ style=margin-right:.5rem>Java</a></div><div class="flex align-center" style=margin-right:1rem><img style=height:1rem;width:1rem;margin-inline-end:.5rem src=/svg/tag-alt.svg class=book-icon alt>
<a class=xxx href=/zh/tags/%E5%B9%B6%E5%8F%91/ style=margin-right:.5rem>并发</a></div></div></div><p><a href=/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/#threadpoolexecutor>前文</a>说过，<code>ThreadPoolExecutor</code>实例代表了Java线程池，前面我们介绍了<code>ThreadPoolExecutor</code>的构造器和几个核心概念，在本节中，我们着重介绍线程池的执行过程以及线程池的关闭。</p><h2 id=线程池的运行状态>线程池的运行状态
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e8%bf%90%e8%a1%8c%e7%8a%b6%e6%80%81>#</a></h2><p>线程池的运行状态表示了线程池的生命周期，在代码实现中它们使用用一个整数表示：</p><table><thead><tr><th style=text-align:center>状态</th><th style=text-align:center>描述</th></tr></thead><tbody><tr><td style=text-align:center><em><strong>RUNNING</strong></em></td><td style=text-align:center>接受新任务的提交，执行队列中的任务</td></tr><tr><td style=text-align:center><em><strong>SHUTDOWN</strong></em></td><td style=text-align:center>不接受新任务的提交，执行队列中的任务</td></tr><tr><td style=text-align:center><em><strong>STOP</strong></em></td><td style=text-align:center>不接受新任务的提交，不执行队列中的任务，中断正在执行的任务</td></tr><tr><td style=text-align:center><em><strong>TIDYING</strong></em></td><td style=text-align:center>所有任务终止，workerCount = 0 ，执行terminated()方法</td></tr><tr><td style=text-align:center><em><strong>TERMINATED</strong></em></td><td style=text-align:center>terminated()方法执行完毕</td></tr></tbody></table><p>为了方便地判断线程池的运行状态，给上述线程池状态约定了单调的演化关系：</p><table><thead><tr><th style=text-align:center>状态变化</th><th style=text-align:center>条件</th></tr></thead><tbody><tr><td style=text-align:center><em><strong>RUNNING</strong></em> -> <em><strong>SHUTDOWN</strong></em></td><td style=text-align:center>调用<code>shutdown()</code>方法，或者隐式调用了<code>finalize()</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></td></tr><tr><td style=text-align:center>(<em><strong>RUNNING</strong></em>或<em><strong>SHUTDOWN</strong></em>) -> <em><strong>STOP</strong></em></td><td style=text-align:center>调用<code>shutdownNow()</code>方法</td></tr><tr><td style=text-align:center><em><strong>SHUTDOWN</strong></em> -> <em><strong>TIDYING</strong></em></td><td style=text-align:center>当线程池和任务队列都为空时</td></tr><tr><td style=text-align:center><em><strong>STOP</strong></em> -> <em><strong>TIDYING</strong></em></td><td style=text-align:center>线程池为空</td></tr><tr><td style=text-align:center><em><strong>TIDYING</strong></em> -> <em><strong>TERMINATED</strong></em></td><td style=text-align:center>当<code>terminated()</code>方法执行完成</td></tr></tbody></table><p>可以看到，线程池的状态是单调演化的，除了RUNNING状态可以接受任务并执行外，其他的状态都将导致线程池资源关闭。<code>ThreadPoolExecutor</code>类中有几个获取线程池状态的方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** 若线程池的状态不是RUNNING，那么该方法就返回true*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isShutdown</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span> isRunning(ctl.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** 若线程池的状态不是RUNNING，并且状态没有还没有切换到TERMINATED，该方法就返回true
</span></span></span><span style=display:flex><span><span style=color:#75715e>这个方法返回true说明线程池正处于terminae的过程中*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isTerminating</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span> isRunning(c) <span style=color:#f92672>&amp;&amp;</span> runStateLessThan(c, TERMINATED);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** 若线程的状态为TERMINATED，该方法返回true*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isTerminated</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> runStateAtLeast(ctl.<span style=color:#a6e22e>get</span>(), TERMINATED);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=线程池中任务的执行过程>线程池中任务的执行过程
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e4%b8%ad%e4%bb%bb%e5%8a%a1%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b>#</a></h2><p>了解了线程池的工作状态，接下来我们尝试去深入任务是如何在线程池中被执行的，以及线程池中核心线程，任务队列以及非核心线程之间是如何协同工作的。</p><p>在
<a href=/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/#%e4%bb%bb%e5%8a%a1%e9%98%9f%e5%88%97>任务队列</a>中，我们阐述了任务队列与线程池之间存在交互关系，这种交互关系体现了线程池执行任务的重要过程。</p><center style=font-size:.8rem;font-style:italic;color:grey><img src=/img/juc/executor_flow.svg alt=线程池执行流程图 width=600px position=center><p>线程池执行流程图</center>上面的流程图展示了任务提交到线程池到执行或被拒绝的过程，和在任务队列中的描述相当，接下来我们从源码的角度阐述这一过程。<h3 id=提交任务>提交任务
<a class=anchor href=#%e6%8f%90%e4%ba%a4%e4%bb%bb%e5%8a%a1>#</a></h3><p>在介绍
<a href=/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/#executorservice%e6%8e%a5%e5%8f%a3>ExecutorService</a>时我们提到了<code>AbstractExecutorService</code>基类，它有两个重要的作用：</p><ol><li>将所有的任务提交转变为执行一个<code>FutureTask</code></li><li>实现了<code>invokeAny/invokeAll</code>方法</li></ol><p>了解到这一点之后，我们将线程池的任务执行重心放在<code>ThreadPoolExecutor</code>的<code>execute(Runnable)</code>方法上：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>execute</span>(Runnable command) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (command <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> NullPointerException();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 当前工作线程数 &lt; corePoolSize</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (workerCountOf(c) <span style=color:#f92672>&lt;</span> corePoolSize) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 直接添加新的工作线程执行之</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (addWorker(command, <span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 若新建失败，则表示rs &gt;= shutdown，任务将会被拒绝</span>
</span></span><span style=display:flex><span>        c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 否则将任务放入队列</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (isRunning(c) <span style=color:#f92672>&amp;&amp;</span> workQueue.<span style=color:#a6e22e>offer</span>(command)) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 线程状态RUNNING，任务已放入队列</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// double check</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> recheck <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这里double-check的原因是：</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span> isRunning(recheck) <span style=color:#f92672>&amp;&amp;</span> remove(command))
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 1. 线程池可能被shutdown了，这时候直接从队列移除任务并拒绝之</span>
</span></span><span style=display:flex><span>            reject(command);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (workerCountOf(recheck) <span style=color:#f92672>==</span> 0)
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 2. 若corePoolSize = 0，而非核心线程都完成了任务</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 空闲线程超时被销毁之后，就可能出现workerCount = 0 的情况</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 此时添加一个非核心线程去执行队列中的任务</span>
</span></span><span style=display:flex><span>            addWorker(<span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 队列满了，则尝试新建一个非核心线程执行任务，否则拒绝之</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>addWorker(command, <span style=color:#66d9ef>false</span>))
</span></span><span style=display:flex><span>        reject(command);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**使用Worker包装线程来执行任务*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>addWorker</span>(Runnable firstTask, <span style=color:#66d9ef>boolean</span> core) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 循环判断，直到满足新建Worker的条件为止</span>
</span></span><span style=display:flex><span>    retry:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> rs <span style=color:#f92672>=</span> runStateOf(c);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check if queue empty only if necessary.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 解释一下这个return false的逻辑</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>/* 1. 若rs = runnning，继续添加worker
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 2. 若rs &gt;= shutdown
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *      2.1 rs &gt;= stop 不新建worker(return false)
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *      2.2 rs = shutdown，firstTask != null，
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *              不新建worker (shutdown之后不接受新任务提交)
</span></span></span><span style=display:flex><span><span style=color:#75715e>         *      2.3 rs = shutdown，firstTask = null，workQueue为空，不新建worker
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (rs <span style=color:#f92672>&gt;=</span> SHUTDOWN <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>!</span> (rs <span style=color:#f92672>==</span> SHUTDOWN <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>               firstTask <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>               <span style=color:#f92672>!</span> workQueue.<span style=color:#a6e22e>isEmpty</span>()))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> wc <span style=color:#f92672>=</span> workerCountOf(c);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (wc <span style=color:#f92672>&gt;=</span> CAPACITY <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                wc <span style=color:#f92672>&gt;=</span> (core <span style=color:#f92672>?</span> corePoolSize : maximumPoolSize))
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 线程数量超限</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (compareAndIncrementWorkerCount(c))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span> retry;
</span></span><span style=display:flex><span>            c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();  <span style=color:#75715e>// Re-read ctl</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (runStateOf(c) <span style=color:#f92672>!=</span> rs)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span> retry;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// else CAS failed due to workerCount change; retry inner loop</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> workerStarted <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> workerAdded <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    Worker w <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        w <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Worker(firstTask);
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>        Worker(Runnable firstTask) {
</span></span></span><span style=display:flex><span><span style=color:#75715e>            setState(-1); // inhibit interrupts until runWorker
</span></span></span><span style=display:flex><span><span style=color:#75715e>            this.firstTask = firstTask;
</span></span></span><span style=display:flex><span><span style=color:#75715e>            this.thread = getThreadFactory().newThread(this);
</span></span></span><span style=display:flex><span><span style=color:#75715e>        }
</span></span></span><span style=display:flex><span><span style=color:#75715e>        */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> Thread t <span style=color:#f92672>=</span> w.<span style=color:#a6e22e>thread</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (t <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>final</span> ReentrantLock mainLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mainLock</span>;
</span></span><span style=display:flex><span>            mainLock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Recheck while holding lock.</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Back out on ThreadFactory failure or if</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// shut down before lock acquired.</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> rs <span style=color:#f92672>=</span> runStateOf(ctl.<span style=color:#a6e22e>get</span>());
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 状态为RUNNING时可以新建Worker执行任务</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 状态为SHUTDOWN时，任务必须为空(不可提交任务)</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (rs <span style=color:#f92672>&lt;</span> SHUTDOWN <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                    (rs <span style=color:#f92672>==</span> SHUTDOWN <span style=color:#f92672>&amp;&amp;</span> firstTask <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>)) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (t.<span style=color:#a6e22e>isAlive</span>()) <span style=color:#75715e>// precheck that t is startable</span>
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalThreadStateException();
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 调整字段值</span>
</span></span><span style=display:flex><span>                    workers.<span style=color:#a6e22e>add</span>(w);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>int</span> s <span style=color:#f92672>=</span> workers.<span style=color:#a6e22e>size</span>();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>&gt;</span> largestPoolSize)
</span></span><span style=display:flex><span>                        largestPoolSize <span style=color:#f92672>=</span> s;
</span></span><span style=display:flex><span>                    workerAdded <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                mainLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 运行任务</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (workerAdded) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 从Worker的构造器来看，线程t的构造器参数是Worker</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 因此start()实际上执行的是Worker的run()方法</span>
</span></span><span style=display:flex><span>                t.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>                workerStarted <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 线程池创建线程失败，清理资源</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span> workerStarted)
</span></span><span style=display:flex><span>            addWorkerFailed(w);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 返回true表示线程已创建并启动</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 根据调用参数的不同，启动的线程可能直接执行任务</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 也可能从队列中获取任务执行</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> workerStarted;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><center style=font-size:.8rem;font-style:italic;color:grey><img src=/img/juc/thread_pool_add_worker.jpg alt=线程池添加worker的流程 width=600px position=center><p>线程池添加worker的流程</center><h3 id=创建空线程>创建空线程
<a class=anchor href=#%e5%88%9b%e5%bb%ba%e7%a9%ba%e7%ba%bf%e7%a8%8b>#</a></h3><p>前面介绍
<a href=/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/#%e6%a0%b8%e5%bf%83%e7%ba%bf%e7%a8%8b%e6%b1%a0%e4%b8%8e%e6%9c%80%e5%a4%a7%e7%ba%bf%e7%a8%8b%e6%b1%a0>核心概念</a>的时候说到，线程池初始化成功之后，池中是没有活动线程的，不过线程池具有很好的灵活性，可以进行动态配置。使用<code>prestartCoreThread()</code>和<code>prestartAllCoreThreads()</code>方法可以向线程池中添加<strong>核心</strong>线程，这些线程并没有使用任务初始化，不过其会尝试去队列中获取任务执行，若队列为空，这些线程就会挂起(waiting)<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/** 创建一个核心线程*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>prestartCoreThread</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> workerCountOf(ctl.<span style=color:#a6e22e>get</span>()) <span style=color:#f92672>&lt;</span> corePoolSize <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>        addWorker(<span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/** 创建所有核心线程*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>prestartAllCoreThreads</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (addWorker(<span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>        <span style=color:#f92672>++</span>n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> n;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=执行任务>执行任务
<a class=anchor href=#%e6%89%a7%e8%a1%8c%e4%bb%bb%e5%8a%a1>#</a></h3><p>线程池创建线程是为了执行任务，<code>addWorker()</code>方法成功时会启动线程，线程则会调用Worker的<code>run()</code>方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>    runWorker(<span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**该方法会循环进行，并且在getTask()方法处阻塞*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>runWorker</span>(Worker w) {
</span></span><span style=display:flex><span>    Thread wt <span style=color:#f92672>=</span> Thread.<span style=color:#a6e22e>currentThread</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 任务即为创建Worker的入参</span>
</span></span><span style=display:flex><span>    Runnable task <span style=color:#f92672>=</span> w.<span style=color:#a6e22e>firstTask</span>;
</span></span><span style=display:flex><span>    w.<span style=color:#a6e22e>firstTask</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    w.<span style=color:#a6e22e>unlock</span>(); <span style=color:#75715e>// allow interrupts</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> completedAbruptly <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 只要有任务提交或队列不为空，则一直执行</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (task <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>||</span> (task <span style=color:#f92672>=</span> getTask()) <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>            w.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// If pool is stopping, ensure thread is interrupted;</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// if not, ensure thread is not interrupted.  This</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// requires a recheck in second case to deal with</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// shutdownNow race while clearing interrupt</span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 如果线程池状态为STOP（调用shutdownNow()），则中断线程</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ((runStateAtLeast(ctl.<span style=color:#a6e22e>get</span>(), STOP) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>                 (Thread.<span style=color:#a6e22e>interrupted</span>() <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                  runStateAtLeast(ctl.<span style=color:#a6e22e>get</span>(), STOP))) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>                <span style=color:#f92672>!</span>wt.<span style=color:#a6e22e>isInterrupted</span>())
</span></span><span style=display:flex><span>                wt.<span style=color:#a6e22e>interrupt</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 可扩展方法</span>
</span></span><span style=display:flex><span>                beforeExecute(wt, task);
</span></span><span style=display:flex><span>                Throwable thrown <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    task.<span style=color:#a6e22e>run</span>();
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (RuntimeException x) {
</span></span><span style=display:flex><span>                    thrown <span style=color:#f92672>=</span> x; <span style=color:#66d9ef>throw</span> x;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (Error x) {
</span></span><span style=display:flex><span>                    thrown <span style=color:#f92672>=</span> x; <span style=color:#66d9ef>throw</span> x;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (Throwable x) {
</span></span><span style=display:flex><span>                    thrown <span style=color:#f92672>=</span> x; <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(x);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 可扩展方法</span>
</span></span><span style=display:flex><span>                    afterExecute(task, thrown);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                task <span style=color:#f92672>=</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>                w.<span style=color:#a6e22e>completedTasks</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                w.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        completedAbruptly <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// while循环结束后的动作</span>
</span></span><span style=display:flex><span>        processWorkerExit(w, completedAbruptly);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>/** 该方法从队列中获取任务，方法会被阻塞(核心线程)或超时阻塞（非核心线程）*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> Runnable <span style=color:#a6e22e>getTask</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>boolean</span> timedOut <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>; <span style=color:#75715e>// Did the last poll() time out?</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> rs <span style=color:#f92672>=</span> runStateOf(c);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Check if queue empty only if necessary.</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果状态为SHUTDOWN，但队列不为空，仍从队列中执行任务</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果状态为STOP，则直接return null</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (rs <span style=color:#f92672>&gt;=</span> SHUTDOWN <span style=color:#f92672>&amp;&amp;</span> (rs <span style=color:#f92672>&gt;=</span> STOP <span style=color:#f92672>||</span> workQueue.<span style=color:#a6e22e>isEmpty</span>())) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// workerCount - 1</span>
</span></span><span style=display:flex><span>            decrementWorkerCount();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> wc <span style=color:#f92672>=</span> workerCountOf(c);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Are workers subject to culling?</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 当allowCoreThreadTimeOut被设置时，核心线程超时阻塞</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>boolean</span> timed <span style=color:#f92672>=</span> allowCoreThreadTimeOut <span style=color:#f92672>||</span> wc <span style=color:#f92672>&gt;</span> corePoolSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((wc <span style=color:#f92672>&gt;</span> maximumPoolSize <span style=color:#f92672>||</span> (timed <span style=color:#f92672>&amp;&amp;</span> timedOut))
</span></span><span style=display:flex><span>            <span style=color:#f92672>&amp;&amp;</span> (wc <span style=color:#f92672>&gt;</span> 1 <span style=color:#f92672>||</span> workQueue.<span style=color:#a6e22e>isEmpty</span>())) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (compareAndDecrementWorkerCount(c))
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 阻塞队列获取队头任务</span>
</span></span><span style=display:flex><span>            Runnable r <span style=color:#f92672>=</span> timed <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                workQueue.<span style=color:#a6e22e>poll</span>(keepAliveTime, TimeUnit.<span style=color:#a6e22e>NANOSECONDS</span>) :
</span></span><span style=display:flex><span>                workQueue.<span style=color:#a6e22e>take</span>();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (r <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 超时未获取到任务 --&gt; line 79 --&gt; return null</span>
</span></span><span style=display:flex><span>            timedOut <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (InterruptedException retry) {
</span></span><span style=display:flex><span>            timedOut <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><center style=font-size:.8rem;font-style:italic;color:grey><img src=/img/juc/thread_pool_run_task.jpg alt=线程池执行任务的流程 width=600px position=center><p>线程池执行任务的流程</center><p>可以看到，线程池中的线程初始化之后，其执行任务的过程是阻塞的，也就是说，线程池中的线程一直处于“stand by”状态，除此之外，我们还可以得到以下信息：</p><ul><li>如果没有设置<code>allowCoreThreadTimeOut</code>，核心线程执行任务的过程将一直进行</li><li>非核心线程的执行任务的过程将在超时之后，方法不返回，循环再次进行，将在try块之前的if语句块中返回null</li><li>当线程池状态为SHUTDOWN时，若队列不为空，仍会去队列中获取任务执行；若状态为STOP，将不会从队列中获取任务</li></ul><p>当出现下列任一情况时，<code>getTask()</code>会返回null结束线程运行：</p><ol><li>workerCount > maximumPoolSize，一般在动配置maximumPoolSize之后出现</li><li>线程池状态为STOP</li><li>线程池状态为SHUTDOWN，且队列为空</li><li>当线程获取队列中的任务超时，且该线程不是队列中的唯一线程或队列为空</li></ol><p>前面3点都比较好理解，第4点有点难以理解，我们使用一个corePoolSize=0的线程池特例加以说明：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cachedPool</span>(){
</span></span><span style=display:flex><span>    ThreadPoolExecutor service <span style=color:#f92672>=</span> 
</span></span><span style=display:flex><span>        (ThreadPoolExecutor) Executors.<span style=color:#a6e22e>newCachedThreadPool</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// service 5秒之后即关闭</span>
</span></span><span style=display:flex><span>    service.<span style=color:#a6e22e>setKeepAliveTime</span>(5,TimeUnit.<span style=color:#a6e22e>SECONDS</span>);
</span></span><span style=display:flex><span>    service.<span style=color:#a6e22e>submit</span>(()<span style=color:#f92672>-&gt;</span>{
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;task done&#34;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们知道，<code>newCachedThreadPool</code>构建一个corePoolSize=0的线程池，因此池中所有的任务在空闲超时都会被超时销毁，我们不妨来看看这一过程是如何发生的；我们将<code>keepAliveTime</code>重新设置为5s，并且向线程池中提交一个任务。</p><blockquote><p>线程池首先会新建一个线程执行任务，调用的是addWorker(firstTask, false)方法；</p><p>在runWorker的第二次循环时，由于firstTask已经被执行，将调用<code>getTask()</code>方法去队列中获取任务。我们知道队列中没有任务，超时时间为5s，5s之后getTask()方法将<code>timeout</code>置为true后进入第二次循环；</p><p>注意此次循环：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>if</span> ((wc <span style=color:#f92672>&gt;</span> maximumPoolSize <span style=color:#f92672>||</span> (timed <span style=color:#f92672>&amp;&amp;</span> timedOut))
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;&amp;</span> (wc <span style=color:#f92672>&gt;</span> 1 <span style=color:#f92672>||</span> workQueue.<span style=color:#a6e22e>isEmpty</span>())) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (compareAndDecrementWorkerCount(c))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不难看出来，第一次wc =1 并且timeout=false，显然是不满足if的条件；第二次则不同，timeout此时为true，workQueue.isEmpty为true，if条件满足；</p><p>此时将 wc-1，并且返回null</p></blockquote><p>返回null之后，runWorker()方法的while循环也会结束，接下来会执行<code>processWorkerExit(w, completedAbruptly)</code>方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**while循环正常结束，completedAbruptly为false*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>processWorkerExit</span>(Worker w, <span style=color:#66d9ef>boolean</span> completedAbruptly) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (completedAbruptly) <span style=color:#75715e>// If abrupt, then workerCount wasn&#39;t adjusted</span>
</span></span><span style=display:flex><span>        decrementWorkerCount();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ReentrantLock mainLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mainLock</span>;
</span></span><span style=display:flex><span>    mainLock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 统计已经完成的任务数</span>
</span></span><span style=display:flex><span>        completedTaskCount <span style=color:#f92672>+=</span> w.<span style=color:#a6e22e>completedTasks</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 将Worker从HashSet中移除</span>
</span></span><span style=display:flex><span>        workers.<span style=color:#a6e22e>remove</span>(w);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        mainLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 正如其名，「尝试」终止线程池</span>
</span></span><span style=display:flex><span>    tryTerminate();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 若线程池状态为RUNNING or SHUTDOWN</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (runStateLessThan(c, STOP)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>completedAbruptly) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 线程池中的最小线程数</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> min <span style=color:#f92672>=</span> allowCoreThreadTimeOut <span style=color:#f92672>?</span> 0 : corePoolSize;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (min <span style=color:#f92672>==</span> 0 <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span> workQueue.<span style=color:#a6e22e>isEmpty</span>())
</span></span><span style=display:flex><span>                <span style=color:#75715e>//队列非空时，要保证池中有线程运行任务</span>
</span></span><span style=display:flex><span>                min <span style=color:#f92672>=</span> 1;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (workerCountOf(c) <span style=color:#f92672>&gt;=</span> min)
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 池中还有线程，可以安心返回</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>; <span style=color:#75715e>// replacement not needed</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 否则，向池中加入一个线程</span>
</span></span><span style=display:flex><span>        addWorker(<span style=color:#66d9ef>null</span>, <span style=color:#66d9ef>false</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在上面方法的最后if条件中，<code>wc=min=0</code>，池中没有线程并且任务队列为空，线程成功完成使命，结束运行。</p><p>综上所述，被创建的线程除了执行被提交的任务之外，还会被阻塞执行队列中的任务，而核心线程和非核心线程在空闲时又会存在处理方式的差异。</p><p>值得一提的是，在上面的<code>newFixedThreadPool()</code>的例子中，线程池提交完任务之后，并没有调用关闭方法，那么线程池能关闭么？</p><p>通过上面的分析，例子中的线程在执行完任务后超时被销毁，此时池中没有线程在运行，队列中也没有任务，<strong>那么就意味着所有的逻辑都已经完成，并没有发生阻塞，线程池中的线程数为0，任务队列为空</strong>，虽然如此，线程池的状态还是<em><strong>RUNNING</strong></em>！线程池并没有终止，其还可以继续提交任务运行，实际上，线程池回到了<em>初始化</em> 时的状态。</p><h2 id=如何合理地关闭线程池>如何合理地关闭线程池
<a class=anchor href=#%e5%a6%82%e4%bd%95%e5%90%88%e7%90%86%e5%9c%b0%e5%85%b3%e9%97%ad%e7%ba%bf%e7%a8%8b%e6%b1%a0>#</a></h2><p><code>ThreadPoolExecutor</code>提供了2个关闭线程池的方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shutdown</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ReentrantLock mainLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mainLock</span>;
</span></span><span style=display:flex><span>    mainLock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 检查权限</span>
</span></span><span style=display:flex><span>        checkShutdownAccess();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 修改线程池状态为SHUTDOWN</span>
</span></span><span style=display:flex><span>        advanceRunState(SHUTDOWN);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 中断所有空闲（waiting）的线程</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在condition.await()上阻塞的线程能够响应中断，</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 这就是线程池能够关闭而不阻塞的原因</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 阻塞的线程被中断唤醒后继续在getTask()上继续执行，</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 在线程池状态判断时return null而结束</span>
</span></span><span style=display:flex><span>        interruptIdleWorkers();
</span></span><span style=display:flex><span>        onShutdown(); <span style=color:#75715e>// hook for ScheduledThreadPoolExecutor</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        mainLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 执行terminated()（空）方法，将线程状态设置为TERMINATED</span>
</span></span><span style=display:flex><span>    tryTerminate();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> List<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>shutdownNow</span>() {
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> tasks;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> ReentrantLock mainLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mainLock</span>;
</span></span><span style=display:flex><span>    mainLock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 权限检查</span>
</span></span><span style=display:flex><span>        checkShutdownAccess();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 修改线程池状态为STOP</span>
</span></span><span style=display:flex><span>        advanceRunState(STOP);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 中断所有线程</span>
</span></span><span style=display:flex><span>        interruptWorkers();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 队列中未执行的任务</span>
</span></span><span style=display:flex><span>        tasks <span style=color:#f92672>=</span> drainQueue();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>        mainLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    tryTerminate();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> tasks;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>tryTerminate</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> ctl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>/*直接返回的条件：
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 1. 线程池状态为RUNNING
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 2. 线程池状态为 TIDYING 或 TERMINATED
</span></span></span><span style=display:flex><span><span style=color:#75715e>         * 3. 线程状态为 SHUTDOWN， 且队列不为空
</span></span></span><span style=display:flex><span><span style=color:#75715e>         */</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (isRunning(c) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>            runStateAtLeast(c, TIDYING) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>            (runStateOf(c) <span style=color:#f92672>==</span> SHUTDOWN <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span> workQueue.<span style=color:#a6e22e>isEmpty</span>()))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 若工作线程数 &gt; 0 , 中断一个空闲线程并返回</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (workerCountOf(c) <span style=color:#f92672>!=</span> 0) { <span style=color:#75715e>// Eligible to terminate</span>
</span></span><span style=display:flex><span>            interruptIdleWorkers(ONLY_ONE);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> ReentrantLock mainLock <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>mainLock</span>;
</span></span><span style=display:flex><span>        mainLock.<span style=color:#a6e22e>lock</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 设置线程池状态为TIDYING</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (ctl.<span style=color:#a6e22e>compareAndSet</span>(c, ctlOf(TIDYING, 0))) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 运行terminated()方法</span>
</span></span><span style=display:flex><span>                    terminated();
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 设置线程状态为TERMINATED</span>
</span></span><span style=display:flex><span>                    ctl.<span style=color:#a6e22e>set</span>(ctlOf(TERMINATED, 0));
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 唤醒awaitTermination方法</span>
</span></span><span style=display:flex><span>                    termination.<span style=color:#a6e22e>signalAll</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>            mainLock.<span style=color:#a6e22e>unlock</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// else retry on failed CAS</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从上面的分析，我们可以清晰地看到<code>shutdown()</code>和<code>shutdownNow()</code>的区别，前者只中断了空闲线程，后者中断了所有线程；结合前文<code>getTask()</code>方法的表述，前者未被中断的线程还可继续执行并从任务队列中获取任务执行，而后者已经无法从队列中获取任务执行了，这与本节开头对线程池的
<a href=/zh/#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e8%bf%90%e8%a1%8c%e7%8a%b6%e6%80%81>运行状态</a>的描述一致。</p><p><code>shutdown()</code>和<code>shutdownNow()</code>方法都不能中断正在执行的任务，不过后者对正在执行的任务发送了中断命令，如果任务能够响应中断，即可以作出相应操作。如果想在<code>shutdown()</code>或<code>shutdownNow()</code>执行之后继续获取任务的返回值，只能使用<code>awaitTermination()</code>方法愚蠢地等待。<code>awaitTermination()</code>方法阻塞当前调用该方法的线程，直到任务执行完毕、超时、调用线程被中断3者任一条件发生。</p><p>需要说明的是，如果<code>awaitTermination()</code>阻塞过程中线程池的状态变为<em><strong>TERNMINATD</strong></em>，说明任务执行完毕，返回true；否则返回false或抛出中断异常。</p><p>下面的示例代码演示了<code>shutdown()</code>和<code>shutdownNow()</code>方法的区别：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ExecutorShutdown</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> pointer <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** 容量为1的线程池，其能保证提交的任务都是序列化执行的 */</span>
</span></span><span style=display:flex><span>    ThreadPoolExecutor service
</span></span><span style=display:flex><span>        <span style=color:#f92672>=</span> (ThreadPoolExecutor) Executors.<span style=color:#a6e22e>newFixedThreadPool</span>(1);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@SneakyThrows</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        ExecutorShutdown es <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ExecutorShutdown();
</span></span><span style=display:flex><span>        es.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>//        es.awaitTermination(1, TimeUnit.SECONDS);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>shutdown</span>() {
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> ComplexTask());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 对于newFixedThreadPool(1),EasyTask在任务队列中</span>
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> EasyTask());
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>// shutdown之后，任务并没有执行完成，pointer的值还是0</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;pointer:&#34;</span> <span style=color:#f92672>+</span> pointer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取待任务队列</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;workQueue: &#34;</span> <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>getQueue</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 判断该执行器是否被关闭</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;is executor shutdown? &#34;</span> <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>isShutdown</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 执行器关闭之后所有任务是否都完成</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 如果没有调用shutdown()或shutdownNow()就直接调用isTerminated()，该方法必返回false</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;is executor terminated? &#34;</span> <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>isTerminated</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;pointer:&#34;</span> <span style=color:#f92672>+</span> pointer);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>awaitTermination</span>(<span style=color:#66d9ef>int</span> timeout, TimeUnit unit) {
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> ComplexTask());
</span></span><span style=display:flex><span>        service.<span style=color:#a6e22e>execute</span>(<span style=color:#66d9ef>new</span> EasyTask());
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>Runnable<span style=color:#f92672>&gt;</span> tasks;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (service.<span style=color:#a6e22e>awaitTermination</span>(timeout, unit)) {
</span></span><span style=display:flex><span>                service.<span style=color:#a6e22e>shutdown</span>();
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>(tasks <span style=color:#f92672>=</span> service.<span style=color:#a6e22e>shutdownNow</span>()).<span style=color:#a6e22e>isEmpty</span>()){
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;丢弃任务&#34;</span> <span style=color:#f92672>+</span> tasks);
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;workQueue: &#34;</span> <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>getQueue</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;is executor shutdown? &#34;</span> <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>isShutdown</span>());
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;is executor terminated? &#34;</span> <span style=color:#f92672>+</span> service.<span style=color:#a6e22e>isTerminated</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Task</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span>() {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> getClass().<span style=color:#a6e22e>getSimpleName</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;@&#34;</span> <span style=color:#f92672>+</span> Integer.<span style=color:#a6e22e>toHexString</span>(hashCode());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ComplexTask</span> <span style=color:#66d9ef>extends</span> Task <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 响应中断，调用shutdownNow()可以结束任务</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>() 
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;@&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]，开始执行&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// never finish unless interrupted</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (; ; ) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>Thread.<span style=color:#a6e22e>interrupted</span>()) {
</span></span><span style=display:flex><span>                    pointer<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>() 
</span></span><span style=display:flex><span>                        <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;@&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]，被中断&#34;</span>);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EasyTask</span> <span style=color:#66d9ef>extends</span> Task <span style=color:#66d9ef>implements</span> Runnable {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>() {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>()
</span></span><span style=display:flex><span>                 <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;@&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]，开始执行&#34;</span>);
</span></span><span style=display:flex><span>            pointer<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;[&#34;</span> <span style=color:#f92672>+</span> Thread.<span style=color:#a6e22e>currentThread</span>() 
</span></span><span style=display:flex><span>                <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;@&#34;</span> <span style=color:#f92672>+</span> <span style=color:#66d9ef>this</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]，执行完成&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>/* output
</span></span></span><span style=display:flex><span><span style=color:#75715e>调用shutdown：
</span></span></span><span style=display:flex><span><span style=color:#75715e>[Thread[pool-1-thread-1,5,main]@ComplexTask@48d82c9c]，开始执行
</span></span></span><span style=display:flex><span><span style=color:#75715e>pointer:0
</span></span></span><span style=display:flex><span><span style=color:#75715e>workQueue: [EasyTask@14ae5a5]
</span></span></span><span style=display:flex><span><span style=color:#75715e>is executor shutdown? true
</span></span></span><span style=display:flex><span><span style=color:#75715e>is executor terminated? false
</span></span></span><span style=display:flex><span><span style=color:#75715e>pointer:813
</span></span></span><span style=display:flex><span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>调用awaitTermination：
</span></span></span><span style=display:flex><span><span style=color:#75715e>[Thread[pool-1-thread-1,5,main]@ComplexTask@7ac59a98]，开始执行
</span></span></span><span style=display:flex><span><span style=color:#75715e>[Thread[pool-1-thread-1,5,main]@ComplexTask@7ac59a98]，被中断
</span></span></span><span style=display:flex><span><span style=color:#75715e>丢弃任务[EasyTask@7f31245a]
</span></span></span><span style=display:flex><span><span style=color:#75715e>workQueue: []
</span></span></span><span style=display:flex><span><span style=color:#75715e>is executor shutdown? true
</span></span></span><span style=display:flex><span><span style=color:#75715e>is executor terminated? true
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span><span style=color:#75715e>//:~</span>
</span></span></code></pre></div><p>上例中我们设计了一个可以正常执行的任务EasyTask和一个无限循环执行的任务ComplexTask，后者响应中断，如果不中断线程，ComplexTask将一直运行下去。我们使用一个固定容量为1的线程池运行任务，并且先提交ComplexTask，ComplexTask无法结束运行，那么EasyTask将会放入队列中。</p><p>从运行的结果上来看，使用<code>shutdown()</code>无法结束线程池的运行，虽然主线程结束，但线程池一直在后台运行，同时EasyTask也还在任务队列中，主线程结束后线程池的还没有终止，程序会一直在后台运行。</p><p>当调用<code>awaitTermination(timeout, unit)</code>时，很明显这个方法将超时并返回false，最终执行<code>shutdownNow()</code>，shutdownNow给ComplexTask任务发送中断命令，其在下一次循环检查到中断，结束执行。同时任务队列中的EasyTask被丢弃，任务队列为空，主线程结束后，线程池也成功终止。</p><p>如果ComplexTask在设计时，没有响应中断，而使用死循环执行任务，那么<code>shutdownNow()</code>方法仍然无法终止线程池，这就是官方文档中关于<code>shutdownNow()</code>方法描述的语义：</p><blockquote><p><em>There are no guarantees beyond best-effort attempts to stop
processing actively executing tasks. This implementation
cancels tasks via {@link Thread#interrupt}, so any task that
fails to respond to interrupts may never terminate.</em></p></blockquote><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>目前笔者还未找到隐式调用<code>finalize()</code>方法导致线程池关闭的例证&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>若corePoolSize=0，这些方法不会创建线程&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/wangy325/endlessriver/commit/fba135b7b5e87a5587fc627e422dea5eef0665bf title='最后修改者 wangy325 | 八月 7, 2024' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>八月 7, 2024</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><div class=giscus-thread></div><script src=https://giscus.app/client.js data-repo=wangy325/wangy325.github.io data-repo-id=R_kgDOHhhDZg data-category=Announcements data-category-id=DIC_kwDOHhhDZs4ChbMn data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=noborder_light data-lang=zh-CN crossorigin=anonymous async></script></div><div style=text-align:center;font-size:.8rem;color:gray><p>Notes and Memos by wangy325
<a href=https://creativecommons.org/licenses/by/4.0/deed.en title="Creative Commons Attribution" style=color:gray>&copy; CC BY 4.0</a></p><p><a href="https://github.com/alex-shpak/hugo-book?tab=readme-ov-file#features" style=color:gray>2019-2024. Powered by Hugo Book</a>
Presented by Github.</p></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><div id=toc-new><ul class=nav><li class=nav-item><a id=t线程池的运行状态 href=#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%9a%84%e8%bf%90%e8%a1%8c%e7%8a%b6%e6%80%81>线程池的运行状态</a></li><li class=nav-item><a id=t线程池中任务的执行过程 href=#%e7%ba%bf%e7%a8%8b%e6%b1%a0%e4%b8%ad%e4%bb%bb%e5%8a%a1%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b>线程池中任务的执行过程</a><ul class=nav><li class=nav-item><a id=t提交任务 href=#%e6%8f%90%e4%ba%a4%e4%bb%bb%e5%8a%a1>提交任务</a></li><li class=nav-item><a id=t创建空线程 href=#%e5%88%9b%e5%bb%ba%e7%a9%ba%e7%ba%bf%e7%a8%8b>创建空线程</a></li><li class=nav-item><a id=t执行任务 href=#%e6%89%a7%e8%a1%8c%e4%bb%bb%e5%8a%a1>执行任务</a></li></ul></li><li class=nav-item><a id=t如何合理地关闭线程池 href=#%e5%a6%82%e4%bd%95%e5%90%88%e7%90%86%e5%9c%b0%e5%85%b3%e9%97%ad%e7%ba%bf%e7%a8%8b%e6%b1%a0>如何合理地关闭线程池</a></li></ul></div></div></aside></main><div class=back-to-top><div id=back-to-top><img src=/svg/chevrons-up.svg srcset="/svg/chevrons-up.svg 500w" onclick=topFunction() class=black>
<img title=回到顶部 src=/svg/chevrons-up-blue.svg srcset="/svg/chevrons-up-blue.svg 500w" onclick=topFunction() class=blue></div><script>let mybutton=document.getElementById("back-to-top");window.onscroll=function(){scrollFunction()};function scrollFunction(){document.body.scrollTop>500||document.documentElement.scrollTop>500?mybutton.style.display="block":mybutton.style.display="none"}function topFunction(){document.body.scrollTop=0,document.documentElement.scrollTop=0}</script></div><script src=/js/scroll-listening.js></script></body></html>