<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="自Java 1.0开始，每一个对象都有一个隐式内部锁（ intrinsic lock ），在Java API Specification中通常被称为监视器（ monitor ）。这个内部锁由synchronized关键字提供支持。synchronized关键字的语义就是“同步的”，这意味着使用这个关键字可以处理共享资源的冲突。
当访问被synchronized关键字保护的方法或代码块时，它将检查锁能否获得——这个锁可以是当前类对象的锁，也可以是一个临时锁( ad-hoc lock )，取决你如何使用，任务执行完成之后会释放锁。
和ReentrantLock一样，synchronized关键字获取的锁也是独占锁，并且也是“可重入”的，某个任务可以多次获得对象的锁，并由计数器维护获得锁的次数，当退出一个方法时，计数器-1，完全退出时，才释放锁，这和可重入锁的机制是一样的。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_3_synchronized/"><meta property="og:site_name" content="Endless River"><meta property="og:title" content="synchronized关键字"><meta property="og:description" content="自Java 1.0开始，每一个对象都有一个隐式内部锁（ intrinsic lock ），在Java API Specification中通常被称为监视器（ monitor ）。这个内部锁由synchronized关键字提供支持。synchronized关键字的语义就是“同步的”，这意味着使用这个关键字可以处理共享资源的冲突。
当访问被synchronized关键字保护的方法或代码块时，它将检查锁能否获得——这个锁可以是当前类对象的锁，也可以是一个临时锁( ad-hoc lock )，取决你如何使用，任务执行完成之后会释放锁。
和ReentrantLock一样，synchronized关键字获取的锁也是独占锁，并且也是“可重入”的，某个任务可以多次获得对象的锁，并由计数器维护获得锁的次数，当退出一个方法时，计数器-1，完全退出时，才释放锁，这和可重入锁的机制是一样的。"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2020-05-20T00:00:00+00:00"><meta property="article:modified_time" content="2020-05-20T00:00:00+00:00"><meta property="article:tag" content="Concurrency"><title>synchronized关键字 | Endless River</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://wangy325.github.io/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_3_synchronized/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.9f527fc4551dd63a27a6050a0758c4038a62eefbcbbe440e94e327b24c511ee1.js integrity="sha256-n1J/xFUd1jonpgUKB1jEA4pi7vvLvkQOlOMnskxRHuE=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-HHNKR5H8KN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-HHNKR5H8KN")}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>Endless River</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><a href=/zh/docs/java/>Java核心</a><ul><li><input type=checkbox id=section-287084f81620420b7ed7e40a42c44d2f class=toggle>
<label for=section-287084f81620420b7ed7e40a42c44d2f class="flex justify-between"><a role=button>面向对象</a></label><ul><li><a href=/zh/docs/java/basic/1_%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/>访问权限修饰符</a></li><li><a href=/zh/docs/java/basic/2_static%E5%85%B3%E9%94%AE%E5%AD%97/>static关键字</a></li><li><a href=/zh/docs/java/basic/3_%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/>传值还是传引用</a></li><li><a href=/zh/docs/java/basic/4_final%E5%85%B3%E9%94%AE%E5%AD%97/>final关键字</a></li><li><a href=/zh/docs/java/basic/5_Object%E8%B6%85%E7%B1%BB/>Object超类</a></li><li><a href=/zh/docs/java/basic/5_%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A/>动态绑定与静态绑定</a></li><li><a href=/zh/docs/java/basic/6_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/>抽象类与接口</a></li><li><a href=/zh/docs/java/basic/7_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/>Lambda与函数式接口</a></li><li><a href=/zh/docs/java/basic/8_%E5%86%85%E9%83%A8%E7%B1%BB/>内部类</a></li><li><a href=/zh/docs/java/basic/11_java-new-time-api/>Java8日期和时间API</a></li></ul></li><li><input type=checkbox id=section-3d2f820e49b3d97a7a712be90f9fd6ad class=toggle>
<label for=section-3d2f820e49b3d97a7a712be90f9fd6ad class="flex justify-between"><a href=/zh/docs/java/collections/>集合框架</a></label><ul><li><a href=/zh/docs/java/collections/1_List_arraylist/>ArrayList</a></li><li><a href=/zh/docs/java/collections/1_List_linkedlist/>LinkedList</a></li><li><a href=/zh/docs/java/collections/2_Queue/>Queue</a></li><li><a href=/zh/docs/java/collections/3_Set/>Set</a></li><li><a href=/zh/docs/java/collections/4_Map_hash_tree_map/>HashMap和TreeMap</a></li><li><a href=/zh/docs/java/collections/4_Map_linkedhashmap/>LinkedHashMap</a></li><li><a href=/zh/docs/java/collections/5_HashMap%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>HashMap的源码分析</a></li><li><a href=/zh/docs/java/collections/6_Collections/>Collections工具类</a></li></ul></li><li><input type=checkbox id=section-6d6d0626deeb0ce0f9826f9dabe58c16 class=toggle checked>
<label for=section-6d6d0626deeb0ce0f9826f9dabe58c16 class="flex justify-between"><a href=/zh/docs/java/concurrency/>并发编程</a></label><ul><li><a href=/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_1/>线程与任务(一)</a></li><li><a href=/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1_2/>线程与任务(二)</a></li><li><a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_1/>资源访问受限--引论</a></li><li><a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_2_%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6/>锁和条件</a></li><li><a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_3_synchronized/ class=active>synchronized关键字</a></li><li><a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_4_%E5%8E%9F%E5%AD%90%E6%80%A7%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB/>原子性和可见性</a></li><li><a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_5_%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/>线程本地存储</a></li><li><a href=/zh/docs/java/concurrency/3%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/>获取任务的返回值</a></li><li><a href=/zh/docs/java/concurrency/4%E6%AD%BB%E9%94%81/>死锁问题2例</a></li><li><a href=/zh/docs/java/concurrency/5%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1/>终结任务</a></li><li><a href=/zh/docs/java/concurrency/6%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/>生产者-消费者与阻塞队列</a></li><li><a href=/zh/docs/java/concurrency/6%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A82%E4%BE%8B/>阻塞队列的使用2例</a></li><li><a href=/zh/docs/java/concurrency/7_1_Executors_and_ExecutorService/>Executors与Executor框架</a></li><li><a href=/zh/docs/java/concurrency/7_2_ThreadPoolExecutor1/>ThreadPoolExecutor-1</a></li><li><a href=/zh/docs/java/concurrency/7_3_ThreadPoolExecutor2/>ThreadPoolExecutor-2</a></li><li><a href=/zh/docs/java/concurrency/7_4_CompletionService/>CompletionService</a></li><li><a href=/zh/docs/java/concurrency/8_1_ScheduledExecutorService1/>ScheduledExecutorService-1</a></li><li><a href=/zh/docs/java/concurrency/8_2_ScheduledExecutorService2/>ScheduledExecutorService-2</a></li><li><a href=/zh/docs/java/concurrency/9_1_countdownlatch/>并发组件-CountDownLatch</a></li><li><a href=/zh/docs/java/concurrency/9_2_cyclicbarrier/>并发组件-CyclicBarrier</a></li><li><a href=/zh/docs/java/concurrency/9_3_semaphore/>并发组件-Semaphore</a></li><li><a href=/zh/docs/java/concurrency/9_4_exchanger/>并发组件-Exchanger</a></li><li><a href=/zh/docs/java/concurrency/9_5_priorityblockqueue_delayqueue/>并发组件-PBQ/DQ</a></li><li><a href=/zh/docs/java/concurrency/10_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/>JMM与volatile关键字(转)</a></li></ul></li><li><input type=checkbox id=section-1fe137527ef46393c946fbc7cb576209 class=toggle>
<label for=section-1fe137527ef46393c946fbc7cb576209 class="flex justify-between"><a role=button>JVM</a></label><ul><li><a href=/zh/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/>Java内存区域详解(转)</a></li><li><a href=/zh/docs/java/jvm/java-gc/>JVM垃圾回收概要(转)</a></li></ul></li><li><input type=checkbox id=section-162997d8460d3e3e2ce056aadf759dc7 class=toggle>
<label for=section-162997d8460d3e3e2ce056aadf759dc7 class="flex justify-between"><a role=button>Spring</a></label><ul><li><a href=/zh/docs/java/spring/SpringBoot-aop-demo/>SpringBoot使用AOP的简单示例</a></li><li><a href=/zh/docs/java/spring/%E5%9C%A8SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8MockMvc%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/>在SpringBoot项目中使用MockMvc进行接口测试</a></li><li><a href=/zh/docs/java/spring/spring-transaction-propagation/>spring声明式事务的使用</a></li></ul></li></ul></li><li class=book-section-flat><span>所谓开发</span><ul><li><input type=checkbox id=section-94c876711ff851f5a564bef513938730 class=toggle>
<label for=section-94c876711ff851f5a564bef513938730 class="flex justify-between"><a role=button>存储数据</a></label><ul><li><input type=checkbox id=section-95d6c3eb8d9a1cf6b58bd1aaaeba338b class=toggle>
<label for=section-95d6c3eb8d9a1cf6b58bd1aaaeba338b class="flex justify-between"><a role=button>mysql</a></label><ul><li><a href=/zh/docs/utility/db/sql/1_%E5%9C%A8centOS%E4%B8%8A%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmysql%E6%95%B0%E6%8D%AE%E5%BA%93/>CentOS安装并配置MySQL</a></li><li><a href=/zh/docs/utility/db/sql/2_MySQL%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/>MySQL字符串处理函数</a></li><li><a href=/zh/docs/utility/db/sql/4_MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/>事务隔离级别与MVCC</a></li><li><a href=/zh/docs/utility/db/sql/5_%E4%BD%BF%E7%94%A8mysql%E7%9A%84%E8%A1%8C%E9%94%81/>MySQL显式锁简单介绍</a></li><li><a href=/zh/docs/utility/db/sql/6_mysql%E6%AD%BB%E9%94%81/>MySQL死锁</a></li></ul></li><li><input type=checkbox id=section-63fe101f19994c0885fcb00347eb6cc3 class=toggle>
<label for=section-63fe101f19994c0885fcb00347eb6cc3 class="flex justify-between"><a role=button>redis</a></label><ul><li><a href=/zh/docs/utility/db/redis/redis-all/>redis必知必会(转)</a></li><li><a href=/zh/docs/utility/db/redis/build-redis-sentinel/>Redis Sentinel高可用实现</a></li><li><a href=/zh/docs/utility/db/redis/deploy-redis-cluster-with-docker/>使用docker镜像快速搭建redis集群开发环境</a></li><li><a href=/zh/docs/utility/db/redis/bloom-filter/>布隆过滤器(转)</a></li></ul></li></ul></li><li><input type=checkbox id=section-6b3913c766697bc2d56c09ab1e4448be class=toggle>
<label for=section-6b3913c766697bc2d56c09ab1e4448be class="flex justify-between"><a href=/zh/docs/utility/algo/>算法讨论</a></label><ul><li><a href=/zh/docs/utility/algo/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/>同余定理与二进制补码</a></li><li><a href=/zh/docs/utility/algo/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/>移位运算</a></li><li><a href=/zh/docs/utility/algo/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/>异或运算</a></li><li><a href=/zh/docs/utility/algo/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/>位运算的小技巧</a></li><li><a href=/zh/docs/utility/algo/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/>背包问题2例</a></li></ul></li><li><input type=checkbox id=section-a0746926d02d10d842b9d0d7599deab2 class=toggle>
<label for=section-a0746926d02d10d842b9d0d7599deab2 class="flex justify-between"><a role=button>设计模式</a></label><ul><li><input type=checkbox id=section-7081c8a81314efcce430f0f34c6571eb class=toggle>
<label for=section-7081c8a81314efcce430f0f34c6571eb class="flex justify-between"><a role=button>创建型</a></label><ul><li><a href=/zh/docs/utility/design_pattern/creation/1_singleton/>单例模式</a></li><li><a href=/zh/docs/utility/design_pattern/creation/2_factory/>工厂模式</a></li><li><a href=/zh/docs/utility/design_pattern/creation/3_abstract_factory/>抽象工厂模式</a></li><li><a href=/zh/docs/utility/design_pattern/creation/4_builder/>建造者模式</a></li></ul></li><li><input type=checkbox id=section-1adf78989f86ee1fe83f52eacf19986b class=toggle>
<label for=section-1adf78989f86ee1fe83f52eacf19986b class="flex justify-between"><a role=button>行为型</a></label><ul><li><a href=/zh/docs/utility/design_pattern/behaviour/1_command/>命令模式</a></li><li><a href=/zh/docs/utility/design_pattern/behaviour/2_observer/>观察者模式</a></li><li><a href=/zh/docs/utility/design_pattern/behaviour/3_strategy/>策略模式</a></li><li><a href=/zh/docs/utility/design_pattern/behaviour/4_template_method/>模板方法模式</a></li></ul></li><li><input type=checkbox id=section-33da1b959d076efbdb019217cc6e3f10 class=toggle>
<label for=section-33da1b959d076efbdb019217cc6e3f10 class="flex justify-between"><a role=button>结构型</a></label><ul><li><a href=/zh/docs/utility/design_pattern/structure/3_decorator/>装饰者模式</a></li><li><a href=/zh/docs/utility/design_pattern/structure/2_adaptor/>适配器模式</a></li><li><a href=/zh/docs/utility/design_pattern/structure/4_%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/>外观模式</a></li><li><a href=/zh/docs/utility/design_pattern/structure/proxy/>代理模式</a></li></ul></li></ul></li></ul></li><li class=book-section-flat><span>它山之石</span><ul><li><input type=checkbox id=section-0aac8377e80b027920c9aeb4f4ee3fdd class=toggle>
<label for=section-0aac8377e80b027920c9aeb4f4ee3fdd class="flex justify-between"><a href=/zh/docs/misc/course/>课程笔记</a></label><ul><li><input type=checkbox id=section-f1b8b9cc5c4f9d3f2a41f96bc1847842 class=toggle>
<label for=section-f1b8b9cc5c4f9d3f2a41f96bc1847842 class="flex justify-between"><a href=/zh/docs/misc/course/operating_system_peking/>操作系统原理</a></label><ul><li><a href=/zh/docs/misc/course/operating_system_peking/1_intro/>引论</a></li><li><a href=/zh/docs/misc/course/operating_system_peking/2_env_and_logic/>操作系统运行环境与机制</a></li><li><a href=/zh/docs/misc/course/operating_system_peking/3_processes_and_threads/>进程和线程模型</a></li></ul></li><li><input type=checkbox id=section-18868d3df14ca5fcdbf6487ffa58a30f class=toggle>
<label for=section-18868d3df14ca5fcdbf6487ffa58a30f class="flex justify-between"><a href=/zh/docs/misc/course/algorithms_part1/>算法-第一部分</a></label><ul></ul></li></ul></li><li><input type=checkbox id=section-6012f93991460519b9fd382fabc67c2d class=toggle>
<label for=section-6012f93991460519b9fd382fabc67c2d class="flex justify-between"><a role=button>Python</a></label><ul><li><a href=/zh/docs/misc/pys/1_flow_control/>流程控制语句</a></li><li><a href=/zh/docs/misc/pys/2_data_list/>列表（list）</a></li><li><a href=/zh/docs/misc/pys/3_data_str/>字符串，元组和字典</a></li><li><a href=/zh/docs/misc/pys/4_func/>函数式编程</a></li><li><a href=/zh/docs/misc/pys/4_important_funcs/>4个重要的内置函数</a></li><li><a href=/zh/docs/misc/pys/5_file_io/>格式化输出与文件I/O</a></li><li><a href=/zh/docs/misc/pys/6_try_excep/>异常处理</a></li><li><a href=/zh/docs/misc/pys/7_scope/>命名空间与作用域</a></li><li><a href=/zh/docs/misc/pys/8_class_type/>类与对象</a></li><li><a href=/zh/docs/misc/pys/9_decoration/>闭包与装饰器</a></li><li><a href=/zh/docs/misc/pys/10_decoration_2/>装饰器2</a></li></ul></li><li><input type=checkbox id=section-2310d269d19e5e48d57d2c9fd6bf08f5 class=toggle>
<label for=section-2310d269d19e5e48d57d2c9fd6bf08f5 class="flex justify-between"><a role=button>翻译文章</a></label><ul><li><a href=/zh/docs/misc/translations/use-springboot-messagesource/>在SpringBoot中使用MessageSource</a></li><li><a href=/zh/docs/misc/translations/guide-to-logback-cn/>使用Logback记录日志</a></li><li><a href=/zh/docs/misc/translations/how2use-printf/>使用printf格式化输出</a></li></ul></li></ul></li></ul><ul><li><a href=/zh/posts/>Blog</a></li><li><a href=/zh/friend/>Links</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>synchronized关键字</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#同步方法>同步方法</a></li><li><a href=#同步代码块>同步代码块</a></li><li><a href=#如何使用同步>如何使用同步</a><ul><li><a href=#在资源上同步>在资源上同步</a></li><li><a href=#在任务上同步>在任务上同步</a></li><li><a href=#建议>建议</a></li></ul></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><p>自Java 1.0开始，每一个对象都有一个隐式<strong>内部锁</strong>（ <em>intrinsic lock</em> ），在Java API Specification中通常被称为<strong>监视器</strong>（ <em>monitor</em> ）。这个内部锁由<code>synchronized</code>关键字提供支持。<code>synchronized</code>关键字的语义就是“同步的”，这意味着使用这个关键字可以处理共享资源的冲突。</p><p>当访问被<code>synchronized</code>关键字保护的方法或代码块时，它将检查锁能否获得——<strong>这个锁可以是当前类对象的锁，也可以是一个临时锁</strong>( <em>ad-hoc lock</em> )，取决你如何使用，任务执行完成之后会释放锁。</p><p>和<code>ReentrantLock</code>一样，<code>synchronized</code>关键字获取的锁也是<strong>独占锁</strong>，并且也是“可重入”的，某个任务可以多次获得对象的锁，并由计数器维护获得锁的次数，当退出一个方法时，计数器-1，完全退出时，才释放锁，这和可重入锁的机制是一样的。</p><p>类对象也持有一个锁，也就是说<code>synchronized</code>关键字<strong>可作用于静态方法</strong>。</p><p>关于什么时候该使用同步，
<a href=https://inside.java/u/BrianGoetz/><em>Brian Goetz</em></a> 提出过<strong>同步规则</strong>：</p><blockquote><p><em>若向一个变量写入值，它可能接下来被另一个线程读取，或者正在读取一个上一次由另一个线程写过的值，那么必须使用同步，并且读写线程都必须使用<strong>相同的监视器</strong>同步</em>。</p></blockquote><p><strong>监视器</strong>是由 <em>Per Brinch Hansen</em> 和 <em>Tony Hoare</em> 提出的一种<strong>无锁机制</strong>，最初的监视器具有如下特性：</p><ol><li>监视器是只包含私有域的类</li><li>每个监视器的类对象有一个相关的锁</li><li>使用该锁对所有相关的方法加锁</li><li>该锁可以有任意多个相关条件</li></ol><p>Java不完全地采用了监视器的设计概念，这就是<code>synchronized</code>关键字。</p><blockquote><p>在<strong>使用synchronized关键字时，将共享域设为私有是非常重要的</strong>。由于域只能通过方法访问，而<code>synchronized</code>保证方法执行的有序性；</p><p>若域不是私有的，其他任务可以直接操作域，这就可能产生冲突。</p></blockquote><h3 id=同步方法>同步方法
<a class=anchor href=#%e5%90%8c%e6%ad%a5%e6%96%b9%e6%b3%95>#</a></h3><p>当<code>synchronized</code>关键字作用于方法时，表示这个方法是同步的，执行方法时，首先会尝试获取当前对象的锁——这个对象一般是类的实例对象（ <em>this</em> ），若是静态方法，便是类对象。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>transfer</span>(<span style=color:#66d9ef>int</span> from, <span style=color:#66d9ef>int</span> to, <span style=color:#66d9ef>double</span> amount) 
</span></span><span style=display:flex><span><span style=color:#66d9ef>throws</span> InterruptedException {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (accounts<span style=color:#f92672>[</span>from<span style=color:#f92672>]</span> <span style=color:#f92672>&lt;</span> amount) wait();  <span style=color:#75715e>// can be interrupted</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (from <span style=color:#f92672>==</span> to) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// transfer</span>
</span></span><span style=display:flex><span>  accounts<span style=color:#f92672>[</span>from<span style=color:#f92672>]</span> <span style=color:#f92672>-=</span> amount;
</span></span><span style=display:flex><span>  System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; move away&#34;</span>);
</span></span><span style=display:flex><span>  accounts<span style=color:#f92672>[</span>to<span style=color:#f92672>]</span> <span style=color:#f92672>+=</span> amount;
</span></span><span style=display:flex><span>  System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s: %10.2f from %d to %d, Total Balance: %10.2f%n&#34;</span>,
</span></span><span style=display:flex><span>                    Thread.<span style=color:#a6e22e>currentThread</span>(),
</span></span><span style=display:flex><span>                    amount,
</span></span><span style=display:flex><span>                    from,
</span></span><span style=display:flex><span>                    to,
</span></span><span style=display:flex><span>                    totalBalance());
</span></span><span style=display:flex><span>  notifyAll();  <span style=color:#75715e>// wake up all threads waiting on this monitor</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>考虑转账的任务，<strong>只需要将transfer()方法加上synchronized关键字即可保证安全</strong>，运行此方法时，线程会先去获取Bank实例的内部锁，并将其他线程阻塞，此线程完成之后会释放这个对象锁，其他线程方可继续运行。</p><p>继续思考之前的问题，对于使用<code>synchronized</code>关键字的<code>transfer()</code>方法，里面调用了<code>totalBalance()</code>方法，那<code>totalBalance()</code>方法是否需要同步呢？前面说过「是否加锁应该以
<a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_2_%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6/#%e6%9d%a1%e4%bb%b6>资源是否共享为参照</a>」，这其实和“同步法则“是的表述是一致的。如果有多个线程访问<code>transfer()</code>方法，正好此方法是<strong>串行访问</strong>（有序访问）的，那么<code>totalBalance()</code>方法无需同步；若还有其他线程对访问<code>totalBalance()</code>方法的资源，那么必须使用同步。</p><h3 id=同步代码块>同步代码块
<a class=anchor href=#%e5%90%8c%e6%ad%a5%e4%bb%a3%e7%a0%81%e5%9d%97>#</a></h3><p><code>synchronized</code>关键字也可以用于同步代码块（同步阻塞）。</p><p>在用于同步方法时，相当于<code>synchronized(this)</code>，而同步代码块则多了一点灵活性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>synchronized</span> (obj){ <span style=color:#75715e>// synchronized block</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// critical section</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>示例中的<code>obj</code>可以是 <em>this</em> ，也可以是其他对象。</p><p>考虑
<a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90_1/#evenGenerator>资源访问受限引论中的EvenGenerator</a>类，在<code>next()</code>方法中可以使用同步代码块加锁可保证安全性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EvenGenerator</span> <span style=color:#66d9ef>extends</span> AbstractIntGenerator {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> Integer even <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> Object lock <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Object();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>next</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// equals to using</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// synchronized (this){</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (lock) {
</span></span><span style=display:flex><span>      <span style=color:#f92672>++</span>even;
</span></span><span style=display:flex><span>      Thread.<span style=color:#a6e22e>yield</span>();
</span></span><span style=display:flex><span>      <span style=color:#f92672>++</span>even;
</span></span><span style=display:flex><span>      <span style=color:#75715e>// return语句必须包含在同步代码块里</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> even;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上例中，<code>synchronized</code>关键字使用了“其他对象”作为“监视器”，注意，<code>synchronized</code>代码块必须包括所有读写域的代码，<strong>包括return语句</strong>。</p><blockquote><p><del>从
<a href=/zh/#byteCode>字节码</a>来看，return语句也不是原子性的——它要先加载并获取变量域even的值，然后再返回</del></p><p>Java语言规范规定对变量的读写都是原子的（long和double）除外，因此return语句是原子的。但是<strong>单一语句的原子性并不能保证多线程的安全性</strong>，如果锁在return之前被释放，那么return可能获取到其他线程修改后的值。</p></blockquote><p>可以看到，使用<code>synchronized</code>关键字比使用显式锁代码更加简洁。</p><p>需要注意的是，尽管synchronized代码块中的锁可以是任意对象的，但是尽量不要把这种任意性视为绝对安全的。<strong>一般在同步代码块中使用this或某“不可变”域（上例中）的锁</strong>。</p><p>考虑如下示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Bank</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Vector<span style=color:#f92672>&lt;</span>Double<span style=color:#f92672>&gt;</span> accounts;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Bank</span>(<span style=color:#66d9ef>int</span> accountCount, <span style=color:#66d9ef>double</span> money) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// initialize bank account</span>
</span></span><span style=display:flex><span>    accounts <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Vector<span style=color:#f92672>&lt;&gt;</span>(accountCount);
</span></span><span style=display:flex><span>    List<span style=color:#f92672>&lt;</span>Double<span style=color:#f92672>&gt;</span> doubles <span style=color:#f92672>=</span> Collections.<span style=color:#a6e22e>nCopies</span>(accountCount, money);
</span></span><span style=display:flex><span>    accounts.<span style=color:#a6e22e>addAll</span>(doubles);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>transfer</span>(<span style=color:#66d9ef>int</span> from, <span style=color:#66d9ef>int</span> to, <span style=color:#66d9ef>double</span> amount) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span> (accounts) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (accounts.<span style=color:#a6e22e>get</span>(from) <span style=color:#f92672>&lt;</span> amount) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (from <span style=color:#f92672>==</span> to) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>      <span style=color:#75715e>// transfer</span>
</span></span><span style=display:flex><span>      accounts.<span style=color:#a6e22e>set</span>(from, accounts.<span style=color:#a6e22e>get</span>(from) <span style=color:#f92672>-</span> amount);
</span></span><span style=display:flex><span>      System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(Thread.<span style=color:#a6e22e>currentThread</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; move away&#34;</span>);
</span></span><span style=display:flex><span>      accounts.<span style=color:#a6e22e>set</span>(to, accounts.<span style=color:#a6e22e>get</span>(to) <span style=color:#f92672>+</span> amount);
</span></span><span style=display:flex><span>      System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%s: %10.2f from %d to %d, Total Balance: %10.2f%n&#34;</span>,
</span></span><span style=display:flex><span>                        Thread.<span style=color:#a6e22e>currentThread</span>(),
</span></span><span style=display:flex><span>                        amount,
</span></span><span style=display:flex><span>                        from,
</span></span><span style=display:flex><span>                        to,
</span></span><span style=display:flex><span>                        totalBalance());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上例中使用Vector作为账户的容器，Vector是线程安全的实现，是否可以不加锁呢？</p><p>不是的，Vector只能保证其实现方法是线程安全的，并不能保证transfer方法是同步的。换言之，accounts.set()方法是同步的，其完成之后该线程可能被剥夺运行权。</p><p>作为改进，在<code>transfer()</code>方法中截获了accounts的锁，尝试使其同步，它是可行的。但是这是否意味着可以任意使用其他对象的锁呢？Java核心卷I给出一段晦涩的评论<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>：</p><p><del>如果冒昧地使用某个其他域（<strong>客户端锁定</strong>）的锁，可能不能保证安全性</del></p><blockquote class="book-hint warning"><blockquote><p><em>This approach works, but it is entirely dependent on the fact that the Vector class uses the intrinsic lock for all of its mutator methods. However, is this really a fact? The documentation of the Vector class makes no such promise. You have to carefully study the source code and hope that future versions do not introduce unsynchronized mutators. As you can see, client-side locking is very fragile and not generally recommended.</em></p></blockquote></blockquote><p>其晦涩之处在于，<code>synchronized</code>使用accounts的内部锁保证同步，和Vector方法使用的锁是不是accounts的内部锁有什么联系？</p><h3 id=如何使用同步>如何使用同步
<a class=anchor href=#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e5%90%8c%e6%ad%a5>#</a></h3><p>从之前的阐述我们知道，如果多个线程同时对共享资源进行访问，并且至少有一个线程对资源进行了写操作，那就需要同步。</p><p>在编写同步代码的时候，我常常困惑，应该在哪里使用同步呢？究竟是在线程上同步还是应该在资源方法上同步，还是所有位置都需要同步？</p><p>接下来我们从两个维度去剖析“在哪里同步”这个问题。</p><h4 id=在资源上同步>在资源上同步
<a class=anchor href=#%e5%9c%a8%e8%b5%84%e6%ba%90%e4%b8%8a%e5%90%8c%e6%ad%a5>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 资源</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>synchronized</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>next</span>(){
</span></span><span style=display:flex><span>    x<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 任务1</span>
</span></span><span style=display:flex><span>run(){
</span></span><span style=display:flex><span>    next();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 任务2</span>
</span></span><span style=display:flex><span>run(){
</span></span><span style=display:flex><span>    next();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是常见的模式。当在资源上同步时，使用多线程执行任务1和任务2，都不会出现线程安全的问题。因为每一个对x进行操作的线程都会被同步阻塞。这就是资源的序列化访问。</p><h4 id=在任务上同步>在任务上同步
<a class=anchor href=#%e5%9c%a8%e4%bb%bb%e5%8a%a1%e4%b8%8a%e5%90%8c%e6%ad%a5>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>final</span> Lock lock ;
</span></span><span style=display:flex><span><span style=color:#75715e>// 资源</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>next</span>(){
</span></span><span style=display:flex><span>    x<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 任务1</span>
</span></span><span style=display:flex><span>run(){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>synchronized</span>(lock){
</span></span><span style=display:flex><span>        next();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 任务2</span>
</span></span><span style=display:flex><span>run(){
</span></span><span style=display:flex><span>    next();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如上代码示例所示，我们在任务1的<code>run()</code>方法上使用同步，当多个线程实例执行任务1时，x是线程安全的。</p><p>需要提出的是，<code>run()</code>方法中的<code>synchronized</code>使用的锁<strong>不能是this</strong>，如果是<code>this</code>，那么同步块将毫无作用。</p><blockquote class="book-hint warning"><blockquote><p>因为<code>synchronized</code>是对持有对象的可重入锁，而<em>this</em>并不是指代的某个实例，而是所有构造的实例。</p><p>可以使用<code>ClassName.class</code>来持有类对象的锁来代替。</p></blockquote></blockquote><p>但是若此时有线程执行任务2，那么此代码的安全隐患就出现了：任务2的操作和任务1的操作就会互相干扰!</p><p>若想保证线程安全，那么任务2的next方法也要和任务1一样使用同步，并且<strong>使用相同的对象锁</strong>。</p><p>这样的条件下，同时运行任务1和任务2，那么线程会在<code>lock</code>对象上获取锁而进入同步阻塞，从而保证安全性，和在资源上同步的效果是等同的。</p><h4 id=建议>建议
<a class=anchor href=#%e5%bb%ba%e8%ae%ae>#</a></h4><p>从代码的简洁性，可读性与可复用性上来讲，在资源上使用同步显得更加优雅，两种实现方式的代码可以进行比较直观的对比：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// 在任务上同步</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> TV <span style=color:#a6e22e>call</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>synchronized</span> (tick) {
</span></span><span style=display:flex><span>            TV tv <span style=color:#f92672>=</span> tl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>            tv.<span style=color:#a6e22e>setT</span>(Thread.<span style=color:#a6e22e>currentThread</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (tick.<span style=color:#a6e22e>getTick</span>()) {
</span></span><span style=display:flex><span>                tv.<span style=color:#a6e22e>setV</span>((tv.<span style=color:#a6e22e>getV</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> 0 : tv.<span style=color:#a6e22e>getV</span>()) <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>                tl.<span style=color:#a6e22e>set</span>(tv);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>// 给其他线程机会</span>
</span></span><span style=display:flex><span>                    tick.<span style=color:#a6e22e>wait</span>(10);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>catch</span> (InterruptedException e) {
</span></span><span style=display:flex><span>                    e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>tick.<span style=color:#a6e22e>isTickSupply</span>) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> tl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 在资源上使用同步</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> TV <span style=color:#a6e22e>call</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>        TV tv <span style=color:#f92672>=</span> tl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>        tv.<span style=color:#a6e22e>setT</span>(Thread.<span style=color:#a6e22e>currentThread</span>());
</span></span><span style=display:flex><span>        <span style=color:#75715e>// getTick()方法同步</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (tick.<span style=color:#a6e22e>getTick</span>()) {
</span></span><span style=display:flex><span>            tv.<span style=color:#a6e22e>setV</span>((tv.<span style=color:#a6e22e>getV</span>() <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span> <span style=color:#f92672>?</span> 0 : tv.<span style=color:#a6e22e>getV</span>()) <span style=color:#f92672>+</span> 1);
</span></span><span style=display:flex><span>            tl.<span style=color:#a6e22e>set</span>(tv);
</span></span><span style=display:flex><span>            TimeUnit.<span style=color:#a6e22e>MILLISECONDS</span>.<span style=color:#a6e22e>sleep</span>(1);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>tick.<span style=color:#a6e22e>isTickSupply</span>) <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> tl.<span style=color:#a6e22e>get</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述代码的作用是一样的，可以看到，在资源上使用同步比在任务上使用同步的代码更加易读，简洁。</p><p>正如之前所说的，在资源上使用同步还可以避免新建任务时又重新设计同步逻辑。</p><p>因此，在资源上使用同步是建议的方式。</p><p>扩展阅读:
<a href=https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html>https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html</a></p><hr><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Java核心技术卷1 第14章并发第14.5.6节同步阻塞&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//pkendlessriver.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><div style=text-align:center;font-size:.8rem;color:gray><p>wangy325.
<a href=https://creativecommons.org/licenses/by/4.0/deed.en title="Creative Commons Attribution" style=color:gray>&copy; 2019-2024 </a><a href="https://github.com/alex-shpak/hugo-book?tab=readme-ov-file#features" style=color:gray>Powered by Hugo Book</a></p></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><ul><li><a href=#同步方法>同步方法</a></li><li><a href=#同步代码块>同步代码块</a></li><li><a href=#如何使用同步>如何使用同步</a><ul><li><a href=#在资源上同步>在资源上同步</a></li><li><a href=#在任务上同步>在任务上同步</a></li><li><a href=#建议>建议</a></li></ul></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>