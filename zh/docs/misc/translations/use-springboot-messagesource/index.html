<!doctype html><html lang=zh dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='
几个说明：

properties配置文件中，spring.messages.basename必须要加classpath前缀。如 spring.messages.basename=classpath:i18n/messages；
必须要手动配置MessageSource，springboot不会自动配置之；
如果使用MessageSource.getMessage()方法，第一个参数的引用形式为"code"，而不是"{code}"或者"${code}"。如messageSource.getMessage(&ldquo;test.msg&rdquo;, null, Locale.getDefault())；
在配置LocalValidatorFactoryBean之后，才可以在javax.validation.constraints包下的注解（@Size，@NotNull&mldr;）下的message属性中使用"{code}"的形式声明校验提示信息。如
@NotNull(message = "{leftTime.not.null}")；
springMVC的locale配置和JVM的locale配置不一样，在application.properties中配置的spring.mvc.locale=zh_CN实际上配置的是WebMvcProperties，在获取消息时，locale信息应该使用webMvcProperties.getLocale()1获取而不是使用Locale.getDefault()获取。



MessageSource is a powerful feature available in Spring applications. This helps application developers handle various complex scenarios with writing much extra code, such as environment-specific configuration, internationalization or configurable values.
One more scenario could be modifying the default validation messages to more user-friendly/custom messages.
In this tutorial, we&rsquo;ll see how to configure and manage custom validation MessageSource in the application using Spring Boot.'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://wangy325.github.io/zh/docs/misc/translations/use-springboot-messagesource/"><meta property="og:site_name" content="Endless River"><meta property="og:title" content="在SpringBoot中使用MessageSource"><meta property="og:description" content=' 几个说明：
properties配置文件中，spring.messages.basename必须要加classpath前缀。如 spring.messages.basename=classpath:i18n/messages； 必须要手动配置MessageSource，springboot不会自动配置之； 如果使用MessageSource.getMessage()方法，第一个参数的引用形式为"code"，而不是"{code}"或者"${code}"。如messageSource.getMessage(“test.msg”, null, Locale.getDefault())； 在配置LocalValidatorFactoryBean之后，才可以在javax.validation.constraints包下的注解（@Size，@NotNull…）下的message属性中使用"{code}"的形式声明校验提示信息。如 @NotNull(message = "{leftTime.not.null}")； springMVC的locale配置和JVM的locale配置不一样，在application.properties中配置的spring.mvc.locale=zh_CN实际上配置的是WebMvcProperties，在获取消息时，locale信息应该使用webMvcProperties.getLocale()1获取而不是使用Locale.getDefault()获取。 MessageSource is a powerful feature available in Spring applications. This helps application developers handle various complex scenarios with writing much extra code, such as environment-specific configuration, internationalization or configurable values.
One more scenario could be modifying the default validation messages to more user-friendly/custom messages.
In this tutorial, we’ll see how to configure and manage custom validation MessageSource in the application using Spring Boot.'><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2021-02-20T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-19T21:14:32+08:00"><meta property="article:tag" content="Translation"><title>在SpringBoot中使用MessageSource | Endless River</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://wangy325.github.io/zh/docs/misc/translations/use-springboot-messagesource/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/zh.search.min.2d78e2d410e66cd9935b6d57ed5a67482828e0dd33b99fd1bda8ffd0df8c83b0.js integrity="sha256-LXji1BDmbNmTW21X7VpnSCgo4N0zuZ/Rvaj/0N+Mg7A=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-HHNKR5H8KN"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-HHNKR5H8KN")}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/zh/><span>Endless River</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=搜索 aria-label=搜索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li class=book-section-flat><a href=/zh/docs/java/>Java核心</a><ul><li><input type=checkbox id=section-287084f81620420b7ed7e40a42c44d2f class=toggle>
<label for=section-287084f81620420b7ed7e40a42c44d2f class="flex justify-between"><a role=button>必知必会</a></label><ul><li><a href=/zh/docs/java/basic/1_%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/>访问权限修饰符</a></li><li><a href=/zh/docs/java/basic/2_static%E5%85%B3%E9%94%AE%E5%AD%97/>static关键字</a></li><li><a href=/zh/docs/java/basic/3_%E4%BC%A0%E5%80%BC%E8%BF%98%E6%98%AF%E4%BC%A0%E5%BC%95%E7%94%A8/>传值还是传引用</a></li><li><a href=/zh/docs/java/basic/4_final%E5%85%B3%E9%94%AE%E5%AD%97/>final关键字</a></li><li><a href=/zh/docs/java/basic/5_Object%E8%B6%85%E7%B1%BB/>Object超类</a></li><li><a href=/zh/docs/java/basic/5_%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A/>动态绑定与静态绑定</a></li><li><a href=/zh/docs/java/basic/6_%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/>抽象类与接口</a></li><li><a href=/zh/docs/java/basic/7_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/>lambda表达式</a></li><li><a href=/zh/docs/java/basic/8_%E5%86%85%E9%83%A8%E7%B1%BB/>内部类</a></li><li><a href=/zh/docs/java/basic/11_java-new-time-api/>Java8日期和时间API</a></li><li><a href=/zh/docs/java/basic/Java%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83/>Java接口回调</a></li></ul></li><li><input type=checkbox id=section-3d2f820e49b3d97a7a712be90f9fd6ad class=toggle>
<label for=section-3d2f820e49b3d97a7a712be90f9fd6ad class="flex justify-between"><a role=button>集合框架</a></label><ul><li><a href=/zh/docs/java/collections/1_List/>List列表</a></li><li><a href=/zh/docs/java/collections/2_Queue/>Queue</a></li><li><a href=/zh/docs/java/collections/3_Set/>Set</a></li><li><a href=/zh/docs/java/collections/4_Map/>Java集合框架之Map</a></li><li><a href=/zh/docs/java/collections/5_Collections/>Collections工具类</a></li><li><a href=/zh/docs/java/collections/6_HashMap%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/>HashMap的源码分析</a></li></ul></li><li><input type=checkbox id=section-6d6d0626deeb0ce0f9826f9dabe58c16 class=toggle>
<label for=section-6d6d0626deeb0ce0f9826f9dabe58c16 class="flex justify-between"><a role=button>并发</a></label><ul><li><a href=/zh/docs/java/concurrency/1%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BB%BB%E5%8A%A1/>线程与任务</a></li><li><a href=/zh/docs/java/concurrency/2%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%8F%97%E9%99%90/>资源访问受限</a></li><li><a href=/zh/docs/java/concurrency/3%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/>获取任务的返回值</a></li><li><a href=/zh/docs/java/concurrency/4%E6%AD%BB%E9%94%81/>死锁</a></li><li><a href=/zh/docs/java/concurrency/5%E7%BB%88%E7%BB%93%E4%BB%BB%E5%8A%A1/>终结任务</a></li><li><a href=/zh/docs/java/concurrency/6%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/>生产者-消费者与阻塞队列</a></li><li><a href=/zh/docs/java/concurrency/7%E6%89%A7%E8%A1%8C%E5%99%A8%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0/>执行器与线程池</a></li><li><a href=/zh/docs/java/concurrency/8%E8%AE%A1%E5%88%92%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1/>计划执行任务</a></li><li><a href=/zh/docs/java/concurrency/9%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BB%84%E4%BB%B6/>一些重要的并发组件</a></li><li><a href=/zh/docs/java/concurrency/10_Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8Evolatile%E5%85%B3%E9%94%AE%E5%AD%97/>Java内存模型与volatile关键字(转)</a></li></ul></li><li><input type=checkbox id=section-1fe137527ef46393c946fbc7cb576209 class=toggle>
<label for=section-1fe137527ef46393c946fbc7cb576209 class="flex justify-between"><a role=button>JVM</a></label><ul><li><a href=/zh/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3/>Java内存区域详解(转)</a></li><li><a href=/zh/docs/java/jvm/java-gc/>JVM垃圾回收概要(转)</a></li></ul></li></ul></li><li class=book-section-flat><span>所谓开发</span><ul><li><input type=checkbox id=section-e45ae315fd63ae771fd5cd0bb732cd6a class=toggle>
<label for=section-e45ae315fd63ae771fd5cd0bb732cd6a class="flex justify-between"><a role=button>Spring</a></label><ul><li><a href=/zh/docs/utility/spring/SpringBoot-aop-demo/>SpringBoot使用AOP的简单示例</a></li><li><a href=/zh/docs/utility/spring/%E5%9C%A8SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8MockMvc%E8%BF%9B%E8%A1%8C%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/>在SpringBoot项目中使用MockMvc进行接口测试</a></li><li><a href=/zh/docs/utility/spring/spring-transaction-propagation/>spring声明式事务的使用</a></li></ul></li><li><input type=checkbox id=section-94c876711ff851f5a564bef513938730 class=toggle>
<label for=section-94c876711ff851f5a564bef513938730 class="flex justify-between"><a role=button>数据库</a></label><ul><li><input type=checkbox id=section-95d6c3eb8d9a1cf6b58bd1aaaeba338b class=toggle>
<label for=section-95d6c3eb8d9a1cf6b58bd1aaaeba338b class="flex justify-between"><a role=button>mysql</a></label><ul><li><a href=/zh/docs/utility/db/sql/1_%E5%9C%A8centOS%E4%B8%8A%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AEmysql%E6%95%B0%E6%8D%AE%E5%BA%93/>在centOS上安装并配置mysql数据库</a></li><li><a href=/zh/docs/utility/db/sql/2_MySQL%E7%9A%84%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/>MySQL中的几个字符串处理函数</a></li><li><a href=/zh/docs/utility/db/sql/4_MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/>MySQL事务与隔离级别</a></li><li><a href=/zh/docs/utility/db/sql/5_%E4%BD%BF%E7%94%A8mysql%E7%9A%84%E8%A1%8C%E9%94%81/>MySQL锁的简单使用</a></li></ul></li><li><input type=checkbox id=section-63fe101f19994c0885fcb00347eb6cc3 class=toggle>
<label for=section-63fe101f19994c0885fcb00347eb6cc3 class="flex justify-between"><a role=button>redis</a></label><ul><li><a href=/zh/docs/utility/db/redis/redis-all/>redis必知必会(转)</a></li><li><a href=/zh/docs/utility/db/redis/build-redis-sentinel/>Redis Sentinel高可用实现</a></li><li><a href=/zh/docs/utility/db/redis/deploy-redis-cluster-with-docker/>使用docker镜像快速搭建redis集群开发环境</a></li><li><a href=/zh/docs/utility/db/redis/bloom-filter/>布隆过滤器(转)</a></li></ul></li></ul></li><li><input type=checkbox id=section-6b3913c766697bc2d56c09ab1e4448be class=toggle>
<label for=section-6b3913c766697bc2d56c09ab1e4448be class="flex justify-between"><a href=/zh/docs/utility/algo/>算法讨论</a></label><ul><li><a href=/zh/docs/utility/algo/%E5%90%8C%E4%BD%99%E5%AE%9A%E7%90%86%E4%B8%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/>同余定理与二进制补码</a></li><li><a href=/zh/docs/utility/algo/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97/>移位运算</a></li><li><a href=/zh/docs/utility/algo/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97/>异或运算</a></li><li><a href=/zh/docs/utility/algo/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/>位运算的小技巧</a></li><li><a href=/zh/docs/utility/algo/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/>背包问题2例</a></li></ul></li><li><input type=checkbox id=section-a0746926d02d10d842b9d0d7599deab2 class=toggle>
<label for=section-a0746926d02d10d842b9d0d7599deab2 class="flex justify-between"><a role=button>设计模式</a></label><ul><li><input type=checkbox id=section-7081c8a81314efcce430f0f34c6571eb class=toggle>
<label for=section-7081c8a81314efcce430f0f34c6571eb class="flex justify-between"><a role=button>创建型</a></label><ul><li><a href=/zh/docs/utility/design_pattern/creation/1_singleton/>单例模式</a></li><li><a href=/zh/docs/utility/design_pattern/creation/2_factory/>工厂模式</a></li><li><a href=/zh/docs/utility/design_pattern/creation/3_abstract_factory/>抽象工厂模式</a></li><li><a href=/zh/docs/utility/design_pattern/creation/4_builder/>建造者模式</a></li></ul></li><li><input type=checkbox id=section-1adf78989f86ee1fe83f52eacf19986b class=toggle>
<label for=section-1adf78989f86ee1fe83f52eacf19986b class="flex justify-between"><a role=button>行为型</a></label><ul><li><a href=/zh/docs/utility/design_pattern/behaviour/1_command/>命令模式</a></li><li><a href=/zh/docs/utility/design_pattern/behaviour/2_observer/>观察者模式</a></li><li><a href=/zh/docs/utility/design_pattern/behaviour/3_strategy/>策略模式</a></li><li><a href=/zh/docs/utility/design_pattern/behaviour/4_template_method/>模板方法模式</a></li></ul></li><li><input type=checkbox id=section-33da1b959d076efbdb019217cc6e3f10 class=toggle>
<label for=section-33da1b959d076efbdb019217cc6e3f10 class="flex justify-between"><a role=button>结构型</a></label><ul><li><a href=/zh/docs/utility/design_pattern/structure/3_decorator/>装饰者模式</a></li><li><a href=/zh/docs/utility/design_pattern/structure/2_adaptor/>适配器模式</a></li><li><a href=/zh/docs/utility/design_pattern/structure/4_%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/>外观模式</a></li><li><a href=/zh/docs/utility/design_pattern/structure/proxy/>代理模式</a></li></ul></li></ul></li></ul></li><li class=book-section-flat><span>实用主义</span><ul><li><input type=checkbox id=section-e0ec0d59ffd2b577bbabd60a51de9e11 class=toggle>
<label for=section-e0ec0d59ffd2b577bbabd60a51de9e11 class="flex justify-between"><a role=button>定时任务</a></label><ul><li><a href=/zh/docs/misc/job/xxl-sharding-job/>在xxl-job中使用分片任务</a></li><li><a href=/zh/docs/misc/job/%E5%B8%B8%E8%A7%81cron%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%A4%BA%E4%BE%8B/>cron表达式速查</a></li></ul></li><li><input type=checkbox id=section-064c88e55046be49abd31400cc335650 class=toggle>
<label for=section-064c88e55046be49abd31400cc335650 class="flex justify-between"><a role=button>版本控制</a></label><ul><li><a href=/zh/docs/misc/vc/Git%E5%85%A5%E9%97%A82/>Git入门2</a></li><li><a href=/zh/docs/misc/vc/Git%E5%85%A5%E9%97%A81/>Git入门1</a></li></ul></li><li><input type=checkbox id=section-2310d269d19e5e48d57d2c9fd6bf08f5 class=toggle checked>
<label for=section-2310d269d19e5e48d57d2c9fd6bf08f5 class="flex justify-between"><a role=button>翻译文章</a></label><ul><li><a href=/zh/docs/misc/translations/use-springboot-messagesource/ class=active>在SpringBoot中使用MessageSource</a></li><li><a href=/zh/docs/misc/translations/guide-to-logback-cn/>使用Logback记录日志</a></li><li><a href=/zh/docs/misc/translations/how2use-printf/>使用printf格式化输出</a></li></ul></li></ul></li></ul><ul><li><a href=/zh/posts/>Blog</a></li><li><a href=/zh/friend/>Links</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>在SpringBoot中使用MessageSource</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><ul><li><a href=#2-引入maven依赖>2 引入Maven依赖</a></li><li><a href=#3-自定义校验信息示例>3 自定义校验信息示例</a></li><li><a href=#4-配置messagesource>4 配置MessageSource</a><ul><li><a href=#41-关于messagesource的自动配置>4.1 关于MessageSource的自动配置</a></li><li><a href=#42-rbms和rrbms>4.2 RBMS和RRBMS</a></li></ul></li><li><a href=#5-配置localvalidatorfactorybean>5 配置LocalValidatorFactoryBean</a></li><li><a href=#6-国际化properties文件>6 国际化properties文件</a><ul><li><a href=#61-messagesproperties>6.1 messages.properties</a></li><li><a href=#62-messages_frproperties>6.2 messages_fr.properties</a></li></ul></li><li><a href=#7-结论>7 结论</a></li><li><a href=#8-使用并解析message>8 使用并解析message</a><ul><li><a href=#81-localecontextholder和accept-language>8.1 LocaleContextHolder和Accept-Language</a></li><li><a href=#82-locale-resolver>8.2 Locale Resolver</a></li><li><a href=#83-通过localechangeinterceptor实现国际化>8.3 通过LocaleChangeInterceptor实现国际化</a></li></ul></li><li><a href=#9-参考>9 参考</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><blockquote><p><span id=hook>几个说明</span>：</p><ol><li><del>properties配置文件中，<code>spring.messages.basename</code><strong>必须</strong>要加classpath前缀。如 <code>spring.messages.basename=classpath:i18n/messages</code></del>；</li><li><del>必须要手动配置<code>MessageSource</code>，springboot不会自动配置之</del>；</li><li>如果使用<code>MessageSource.getMessage()</code>方法，第一个参数的引用形式为<code>"code"</code>，而不是<code>"{code}"</code>或者<code>"${code}"</code>。如messageSource.getMessage(&ldquo;test.msg&rdquo;, null, <del>Locale.getDefault()</del>)；</li><li>在配置<code>LocalValidatorFactoryBean</code>之后，才可以在<code>javax.validation.constraints</code>包下的注解（<code>@Size</code>，<code>@NotNull</code>&mldr;）下的<em><strong>message</strong></em>属性中使用<code>"{code}"</code>的形式声明校验提示信息。如
<code>@NotNull(message = "{leftTime.not.null}")</code>；</li><li>springMVC的locale配置和JVM的locale配置不一样，在application.properties中配置的<code>spring.mvc.locale=zh_CN</code>实际上配置的是<code>WebMvcProperties</code>，在获取消息时，locale信息应该使用<code>webMvcProperties.getLocale()</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>获取<strong>而不是</strong>使用<code>Locale.getDefault()</code>获取。</li></ol></blockquote><hr><p>MessageSource is a powerful feature available in Spring applications. This helps application developers handle various complex scenarios with writing much extra code, such as environment-specific configuration, internationalization or configurable values.</p><p>One more scenario could be modifying the default validation messages to more user-friendly/custom messages.</p><p>In this tutorial, we&rsquo;ll see how to configure and manage custom validation MessageSource in the application using Spring Boot.</p><h2 id=2-引入maven依赖>2 引入Maven依赖
<a class=anchor href=#2-%e5%bc%95%e5%85%a5maven%e4%be%9d%e8%b5%96>#</a></h2><p>Let&rsquo;s start with adding the necessary Maven dependencies:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-starter-web<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;groupId&gt;</span>org.springframework.boot<span style=color:#f92672>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;artifactId&gt;</span>spring-boot-starter-validation<span style=color:#f92672>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>You can find the latest versions of these libraries over on Maven Central.</p><h2 id=3-自定义校验信息示例>3 自定义校验信息示例
<a class=anchor href=#3-%e8%87%aa%e5%ae%9a%e4%b9%89%e6%a0%a1%e9%aa%8c%e4%bf%a1%e6%81%af%e7%a4%ba%e4%be%8b>#</a></h2><p>Let&rsquo;s consider a scenario where we have to develop an application that supports multiple languages. If the user doesn&rsquo;t provide the correct details as input, we&rsquo;d like to show error messages according to the user&rsquo;s locale.</p><p>Let&rsquo;s take an example of a Login form bean:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoginForm</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 注意此处的语法，为&#34;{}&#34;形式，在spring项目中，是无法通过ctrl+鼠标左键定位到配置文件的</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 若去除大括号，则可以通过ctrl+鼠标左键定位到配置的值</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@NotEmpty</span>(message <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;{email.notempty}&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Email</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String email;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@NotNull</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String password;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// standard getter and setters</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we&rsquo;ve added validation constraints that verify if an email is not provided at all, or provided, but not following the standard email address style.</p><p>To show custom and locale-specific message, we can provide a placeholder as mentioned for the <code>@NotEmpty</code> annotation.</p><p>The <code>email.notempty</code>property <strong>will be resolved from a properties files by the MessageSource configuration</strong>.</p><h2 id=4-配置messagesource>4 配置MessageSource
<a class=anchor href=#4-%e9%85%8d%e7%bd%aemessagesource>#</a></h2><p>An application context delegates the message resolution to a bean with the exact name messageSource.</p><p><strong>ReloadableResourceBundleMessageSource</strong> is the most common MessageSource implementation that resolves messages from resource bundles for different locales:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> MessageSource <span style=color:#a6e22e>messageSource</span>() {
</span></span><span style=display:flex><span>    ReloadableResourceBundleMessageSource messageSource
</span></span><span style=display:flex><span>      <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ReloadableResourceBundleMessageSource();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果使用ReloadableResourceBundleMessageSource，classpath前缀必不可少</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// classpath前缀告诉ReloadableResourceBundleMessageSource从classpath中获取配置</span>
</span></span><span style=display:flex><span>    messageSource.<span style=color:#a6e22e>setBasename</span>(<span style=color:#e6db74>&#34;classpath:messages&#34;</span>);
</span></span><span style=display:flex><span>    messageSource.<span style=color:#a6e22e>setDefaultEncoding</span>(<span style=color:#e6db74>&#34;UTF-8&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> messageSource;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here, it&rsquo;s <strong>important to provide the basename</strong> as locale-specific file names will be resolved based on the name provided.</p><h3 id=41-关于messagesource的自动配置>4.1 关于MessageSource的自动配置
<a class=anchor href=#41-%e5%85%b3%e4%ba%8emessagesource%e7%9a%84%e8%87%aa%e5%8a%a8%e9%85%8d%e7%bd%ae>#</a></h3><p>实际上，Spring Boot可以自动配置MessageSourece，不过，想要成功配置，有2个条件：</p><ol><li>Spring Boot自动配置实际上使用的是<strong>ResourceBundleMessageSourece</strong>，不同于<strong>ReloadableResourceBundleMessageSource</strong></li><li>你无需再配置别名为"messageSource"的Bean，也就是说上述的配置必须忽略掉</li></ol><p>不妨看看MessageSource自动配置相关的类，具体内容在<code>org.springframework.boot.autoconfig.context.MessageSourceAutoConfiguration.java</code>类中：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Configuration</span>(proxyBeanMethods <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@ConditionalOnMissingBean</span>(name <span style=color:#f92672>=</span> AbstractApplicationContext.<span style=color:#a6e22e>MESSAGE_SOURCE_BEAN_NAME</span>, search <span style=color:#f92672>=</span> SearchStrategy.<span style=color:#a6e22e>CURRENT</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@AutoConfigureOrder</span>(Ordered.<span style=color:#a6e22e>HIGHEST_PRECEDENCE</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Conditional</span>(ResourceBundleCondition.<span style=color:#a6e22e>class</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>@EnableConfigurationProperties</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MessageSourceAutoConfiguration</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意该自动配置类上的2个注解：</p><ul><li><p><code>@ConditionalOnMissingBean(name = AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME, search = SearchStrategy.CURRENT)</code></p><p>这个注解说明的就是，如果你没有配置messageSource，那么SpringBoot（可能）会自动为你配置</p></li><li><p><code>@Conditional(ResourceBundleCondition.class)</code></p><p>这是一个条件化注入，条件在<code>ResourceBundleCondition.class</code>中定义。通过名字就知道，Spring Boot自动配置使用的是<strong>ResourceBundleMessageSourece</strong></p></li></ul><p><code>ResourceBundleCondition.class</code>是<code>MessageSourceAutoConfiguration.class</code>的内部类，以下是其内容：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> ConditionOutcome <span style=color:#a6e22e>getMatchOutcome</span>(ConditionContext context, AnnotatedTypeMetadata metadata) {
</span></span><span style=display:flex><span>	String basename <span style=color:#f92672>=</span> context.<span style=color:#a6e22e>getEnvironment</span>().<span style=color:#a6e22e>getProperty</span>(<span style=color:#e6db74>&#34;spring.messages.basename&#34;</span>, <span style=color:#e6db74>&#34;messages&#34;</span>);
</span></span><span style=display:flex><span>	ConditionOutcome outcome <span style=color:#f92672>=</span> cache.<span style=color:#a6e22e>get</span>(basename);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (outcome <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>		outcome <span style=color:#f92672>=</span> getMatchOutcomeForBasename(context, basename);
</span></span><span style=display:flex><span>		cache.<span style=color:#a6e22e>put</span>(basename, outcome);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> outcome;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> ConditionOutcome <span style=color:#a6e22e>getMatchOutcomeForBasename</span>(ConditionContext context, String basename) {
</span></span><span style=display:flex><span>	ConditionMessage.<span style=color:#a6e22e>Builder</span> message <span style=color:#f92672>=</span> ConditionMessage.<span style=color:#a6e22e>forCondition</span>(<span style=color:#e6db74>&#34;ResourceBundle&#34;</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> (String name : StringUtils.<span style=color:#a6e22e>commaDelimitedListToStringArray</span>(StringUtils.<span style=color:#a6e22e>trimAllWhitespace</span>(basename))) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>for</span> (Resource resource : getResources(context.<span style=color:#a6e22e>getClassLoader</span>(), name)) {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> (resource.<span style=color:#a6e22e>exists</span>()) {
</span></span><span style=display:flex><span>				<span style=color:#66d9ef>return</span> ConditionOutcome.<span style=color:#a6e22e>match</span>(message.<span style=color:#a6e22e>found</span>(<span style=color:#e6db74>&#34;bundle&#34;</span>).<span style=color:#a6e22e>items</span>(resource));
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> ConditionOutcome.<span style=color:#a6e22e>noMatch</span>(message.<span style=color:#a6e22e>didNotFind</span>(<span style=color:#e6db74>&#34;bundle with basename &#34;</span> <span style=color:#f92672>+</span> basename).<span style=color:#a6e22e>atAll</span>());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// basename不需要classpath前缀，它总是从classpath中获取资源</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> Resource<span style=color:#f92672>[]</span> <span style=color:#a6e22e>getResources</span>(ClassLoader classLoader, String name) {
</span></span><span style=display:flex><span>	String target <span style=color:#f92672>=</span> name.<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>&#39;.&#39;</span>, <span style=color:#e6db74>&#39;/&#39;</span>);
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> PathMatchingResourcePatternResolver(classLoader)
</span></span><span style=display:flex><span>				.<span style=color:#a6e22e>getResources</span>(<span style=color:#e6db74>&#34;classpath*:&#34;</span> <span style=color:#f92672>+</span> target <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;.properties&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>catch</span> (Exception ex) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> NO_RESOURCES;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们只需要关注<code>getResources</code>方法，可以看到，其自动补全了<code>classpath</code>前缀，因此，<code>ResourceBundleMessageSourece</code>总是从classpath中获取资源的。</p><p>如果这两个条件都满足，那么SpringBoot会自动使用<strong>ResourceBundleMessageSourece</strong>配置MessageSource。</p><h3 id=42-rbms和rrbms>4.2 RBMS和RRBMS
<a class=anchor href=#42-rbms%e5%92%8crrbms>#</a></h3><ul><li>RBMS: <strong>R</strong>esource<strong>B</strong>undle<strong>M</strong>essage<strong>S</strong>ource</li><li>RRBMS: <strong>R</strong>eloadable<strong>R</strong>esource<strong>B</strong>undle<strong>M</strong>essage<strong>S</strong>ource</li></ul><p>在本文的
<a href=/zh/#hook>文首</a>，标注了几个实践时需要注意的点，现在看来，前2点都是<strong>错误的表述</strong>，因为当时实践时使用的是<code>ReloadableResourceBundleMessageSourece</code>，并且没有搞清楚Spring Boot自动配置MessageSource的条件。</p><p>关于这2个“MessageSource”的区别，github上有一个经典的
<a href=https://github.com/spring-projects/spring-framework/issues/12050>issue</a>，描述的问题是如果不使用classpath前缀，前者可以读取消息，后者不能读取消息。spring开发人员的回复一针见血：</p><blockquote><p>I assume your resource bundle files live in the classpath? There is an <strong>important difference</strong> between ResourceBundleMessageSource and ReloadableResourceBundleMessageSource: The former <strong>always loads resource bundles from the classpath</strong> (since that is all that standard java.util.ResourceBundle is capable of), whereas the latter <strong>loads resource bundle files through the ApplicationContext&rsquo;s ResourceLoader</strong>. If your context is a ClassPathXmlApplicationContext, you won&rsquo;t notice a difference - but if it is a WebApplicationContext, it will try to find the files in the WAR directory structure when not using a prefix. So it would simply not find your files because it is looking in the wrong location.</p><p>If my assumption is correct, the following quick fix will allow your messages to be found in their existing location when switching to ReloadableResourceBundleMessageSource:</p><p><code>&lt;property name="basename" value="classpath:messages"></code></p><p>However, since classpath resources will be cached by the ClassLoader, ReloadableResourceBundleMessageSource&rsquo;s refreshing is likely to not actually work in that case. So I&rsquo;d rather recommend specifying something like the following, operating against an expanded WAR directory structure where WEB-INF resources can be refreshed from the file system:</p><p><code>&lt;property name="basename" value="WEB-INF/messages"/></code></p></blockquote><p>回复指出了ResourceBundleMessageSourece和ReloadableResourceBundleMessageSourece最重要的区别：</p><ul><li>ResourceBundleMessageSourece<strong>总是</strong>从classpath中加载资源</li><li>ReloadableResourceBundleMessageSourece 则从<strong>ApplicationContext&rsquo;s ResourceLoader</strong>中加载资源</li></ul><p>除此之外，二者还有一些其他的区别：</p><ul><li>ResourceBundleMessageSourece只能读取properties配置文件，而ReloadableResourceBundleMessageSourece还可以读取xml配置文件</li><li>ReloadableResourceBundleMessageSourece可以从任意位置<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>读取配置文件</li><li>从名字来看，Reloadable是可以动态加载配置文件的，事实上也确实如此，它有一个属性<code>cacheSeconds</code>，用来设置缓存配置文件的时间间隔：<ul><li>默认值是 -1，意味着不动态加载配置文件</li><li>如果配置值为0，那么每次获取消息时就会检查配置文件的改动，<strong>这个配置值要慎用</strong></li><li>如果配置为其他正整数，则会在固定间隔后检查配置文件改动</li></ul></li></ul><h2 id=5-配置localvalidatorfactorybean>5 配置LocalValidatorFactoryBean
<a class=anchor href=#5-%e9%85%8d%e7%bd%aelocalvalidatorfactorybean>#</a></h2><blockquote><p>为了在<code>javax.validation.constraints</code>包下注解（<code>@NotEmpty</code>、<code>@NotNull</code>等）的校验中使用messageResource，还需要配置<code>LocalValidatorFactoryBean</code></p></blockquote><p>To use custom name messages in a properties file like we need to define a <strong>LocalValidatorFactoryBean</strong> and register the messageSource:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> LocalValidatorFactoryBean <span style=color:#a6e22e>getValidator</span>() {
</span></span><span style=display:flex><span>    LocalValidatorFactoryBean bean <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> LocalValidatorFactoryBean();
</span></span><span style=display:flex><span>    bean.<span style=color:#a6e22e>setValidationMessageSource</span>(messageSource());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bean;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, note that if we had already <strong>extended the WebMvcConfigurerAdapter</strong>, to avoid having the custom validator ignored, we&rsquo;d have to set the validator by overriding the getValidator() method from the parent class.</p><p>Now we can define a property message like:</p><pre><code>“email.notempty=&lt;Custom_Message&gt;”
</code></pre><p>instead of</p><pre><code>“javax.validation.constraints.NotEmpty.message=&lt;Custom_message&gt;”
</code></pre><h2 id=6-国际化properties文件>6 国际化properties文件
<a class=anchor href=#6-%e5%9b%bd%e9%99%85%e5%8c%96properties%e6%96%87%e4%bb%b6>#</a></h2><p>The final step is to create a properties file in the src/main/resources directory with the name provided in the basename in step 4:</p><h3 id=61-messagesproperties>6.1 messages.properties
<a class=anchor href=#61-messagesproperties>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#a6e22e>email.notempty</span><span style=color:#f92672>=</span><span style=color:#e6db74>Please provide valid email id.</span>
</span></span></code></pre></div><p>Here we can take advantage of internationalization along with this. Let&rsquo;s say we want to show messages for a French user in their language.</p><p>In this case, we have to add one more property file with the name the <code>messages_fr.properties</code> in the same location (No code changes required at all):</p><h3 id=62-messages_frproperties>6.2 messages_fr.properties
<a class=anchor href=#62-messages_frproperties>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#a6e22e>email.notempty</span><span style=color:#f92672>=</span><span style=color:#e6db74>Veuillez fournir un identifiant de messagerie valide.</span>
</span></span></code></pre></div><h2 id=7-结论>7 结论
<a class=anchor href=#7-%e7%bb%93%e8%ae%ba>#</a></h2><p>In this article, we covered how the default validation messages can be changed without modifying the code if the configuration is done properly beforehand.</p><p>We can also leverage the support of internationalization along with this to make the application more user-friendly.</p><hr><h2 id=8-使用并解析message>8 使用并解析message
<a class=anchor href=#8-%e4%bd%bf%e7%94%a8%e5%b9%b6%e8%a7%a3%e6%9e%90message>#</a></h2><p>前文介绍了如何使用MessageResource进行参数校验时的国际化信息展现，最后补充如何在其他部分展现国际化的信息，最显著的一个使用场景就是错误消息的展现。</p><p>配置好<code>messages.properties</code>文件之后，我们可以定义一个错误信息的枚举类：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-properties data-lang=properties><span style=display:flex><span><span style=color:#75715e>#  messages.properties</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>satisfied.resource.not.found</span><span style=color:#f92672>=</span><span style=color:#e6db74>要处理的资源不存在</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>unknown.error</span><span style=color:#f92672>=</span><span style=color:#e6db74>未知错误</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#  other promote messages</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>no.specific.id.resource</span><span style=color:#f92672>=</span><span style=color:#e6db74>对应id的资源不存在</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Getter</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>enum</span> ReqState {
</span></span><span style=display:flex><span>    RESPONSE_ADVICE_ERROR(500_08, <span style=color:#e6db74>&#34;response.advice.error&#34;</span>),
</span></span><span style=display:flex><span>    SATISFIED_RESOURCE_NOT_FOUND(500_09,<span style=color:#e6db74>&#34;satisfied.resource.not.found&#34;</span>),
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    UNKNOWN_ERROR(600_00, <span style=color:#e6db74>&#34;unknown.error&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> code;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> String message;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ReqState(<span style=color:#66d9ef>int</span> code, String message) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>code</span> <span style=color:#f92672>=</span> code;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>message</span> <span style=color:#f92672>=</span> message;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>和在<code>@NotEmpty</code>注解中使用方式不一样，这里只需要以字符串的形式直接引用即可。当然，这个消息还需要解析（实际上消息是以key-value的形式配置的，以key的形式引用，而要以value的形式呈现，在多语言的环境，可以实现"一次引用，多种呈现”的目的），解析的方式也很简单：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>MessageResource messageSource;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>messageSource.<span style=color:#a6e22e>getMessage</span>(<span style=color:#e6db74>&#34;unknown.error&#34;</span>, <span style=color:#66d9ef>null</span>, LocaleContextHolder.<span style=color:#a6e22e>getLocale</span>()))
</span></span></code></pre></div><blockquote><p>如果此处像文章开头说的那样，使用<code>webMvcProperties.getLocale()</code>的话，在获取HTTP Header设置的Loacle时有些问题。此处使用了<code>LocaleContextHolder.getLocale()</code>，LocaleContextHolder可以灵活地获取每一次Servlet请求的Locale信息。</p></blockquote><p>我们不妨看看WebMvcProperties类的Locale域：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e>* Locale to use. By default, this locale is overridden by the &#34;Accept-Language&#34; header.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> Locale locale;
</span></span></code></pre></div><p>注意到，可以通过设置HTTP请求头的方式来设置Locale信息。</p><p>实际上，测试发现，通过设置<code>Accept-Language</code>请求头，配合使用<code>LocaleContextHolder.getLocale()</code>获取Locale信息，可以实现国际化效果，而使用<code>webMvcProperties.getLocale()</code>无法总是正确获取请求头设置的Locale信息。</p><p>还有一点就是，LocaleContextHolder是通过静态方法获取的Locale信息，相较于webMvcProperties的实例方法，免去了注入<code>WebMvcProperties</code>的麻烦。</p><h3 id=81-localecontextholder和accept-language>8.1 LocaleContextHolder和Accept-Language
<a class=anchor href=#81-localecontextholder%e5%92%8caccept-language>#</a></h3><p>现在我们知道，可以通过<code>LocaleContextHolder</code>和设置<code>Accept-Language</code>头动态获取请求的Locale信息，那么我们可以在控制器中
<a href=https://stackoverflow.com/questions/33049674/elegant-way-to-get-locale-in-spring-controller>这样使用Locale信息</a>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Controller</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WifeController</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Autowired</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> MessageSource msgSrc;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@RequestMapping</span>(value <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/wife/mood&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>readWife</span>(Model model, <span style=color:#a6e22e>@RequestParam</span>(<span style=color:#e6db74>&#34;whatImDoing&#34;</span>) String iAm) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 获取Locale信息</span>
</span></span><span style=display:flex><span>        Locale loc <span style=color:#f92672>=</span> LocaleContextHolder.<span style=color:#a6e22e>getLocale</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(iAm.<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;playingXbox&#34;</span>)) {
</span></span><span style=display:flex><span>            model.<span style=color:#a6e22e>addAttribute</span>( <span style=color:#e6db74>&#34;statusTitle&#34;</span>, msgSrc.<span style=color:#a6e22e>getMessage</span>(<span style=color:#e6db74>&#34;mood.angry&#34;</span>, <span style=color:#66d9ef>null</span>, loc) );
</span></span><span style=display:flex><span>            model.<span style=color:#a6e22e>addAttribute</span>( <span style=color:#e6db74>&#34;statusDetail&#34;</span>, msgSrc.<span style=color:#a6e22e>getMessage</span>(<span style=color:#e6db74>&#34;mood.angry.xboxdiatribe&#34;</span>, <span style=color:#66d9ef>null</span>, loc) );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;moodResult&#34;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不过，在每个控制器里都需要获取一次Loacle信息，这样的方式似乎有点繁琐。那么是否可以简单一点呢？显然是可以的。</p><p><a href=https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-ann-methods>springMvc v3.2.x doc 17.3.3</a>中定义了控制器方法支持的参数：</p><blockquote><p>&mldr;</p><p><code>java.util.Locale</code> for the current request locale, determined by the most specific locale resolver available, in effect, the configured <code>LocaleResolver</code> in a Servlet environment.</p><p>&mldr;</p></blockquote><p>也就是说，Locale可以直接作为参数被HTTP请求传递进来。因此，可以这样改造上述控制器：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@RequestMapping</span>(value <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/wife/mood&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>readWife</span>(Model model, <span style=color:#a6e22e>@RequestParam</span>(<span style=color:#e6db74>&#34;whatImDoing&#34;</span>) String iAm, Locale loc) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(iAm.<span style=color:#a6e22e>equals</span>(<span style=color:#e6db74>&#34;playingXbox&#34;</span>)) {
</span></span><span style=display:flex><span>        model.<span style=color:#a6e22e>addAttribute</span>( <span style=color:#e6db74>&#34;statusTitle&#34;</span>, msgSrc.<span style=color:#a6e22e>getMessage</span>(<span style=color:#e6db74>&#34;mood.angry&#34;</span>, <span style=color:#66d9ef>null</span>, loc) );
</span></span><span style=display:flex><span>        model.<span style=color:#a6e22e>addAttribute</span>( <span style=color:#e6db74>&#34;statusDetail&#34;</span>, msgSrc.<span style=color:#a6e22e>getMessage</span>(<span style=color:#e6db74>&#34;mood.angry.xboxdiatribe&#34;</span>, <span style=color:#66d9ef>null</span>, loc) );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;moodResult&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样简洁多了，SpringMvc简直太聪明了！等等，通过<code>spring.mvc.locale=zh_CN</code>或通过<code>Accept-Language: en;q=0.7,zh-TW;q=0.8,zh-CN;q=0.7</code>这样的形式配置MVC context的Locale信息还是有点麻烦，并且这样的话，前端每次请求都需要手动设置（校验）请求头，麻烦！</p><blockquote><p>默认情况下，浏览器发起请求的<code>Accept-Language</code>是根据用户语言设置的。</p></blockquote><p>文章到此，我们已经可以通过配置<strong>WebMvcProperties</strong>和设置<strong>Accept-Language</strong>请求头来<strong>设置</strong>Spring MVC Context的Locale信息；并且通过<code>LocaleContextHolder.getLocale()</code>方法或者直接在控制器中传递<code>Locale</code>参数的形式<strong>获取</strong>Locale信息。</p><h3 id=82-locale-resolver>8.2 Locale Resolver
<a class=anchor href=#82-locale-resolver>#</a></h3><p>这样看来，国际化的配置还是不够灵活，配置文件的加载以及请求头的设置这两种方法都略显笨重。</p><p>去找找文档看看其他的思路吧：</p><ul><li><a href=https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-localeresolver>(旧版本)springMvc-3.2.x-17.8</a></li><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver>spring webMvc doc</a></li></ul><p>当请求进入到控制器时，<code>DispatcherServlet</code>会寻找locale resolver，并使用其设置Locale。使用<code>RequestContext.getLocale()</code>方法总是可以获取到Locale信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@GetMapping</span>(<span style=color:#e6db74>&#34;/resolver/locale&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> ReqResult<span style=color:#f92672>&lt;?&gt;</span> locale(HttpServletRequest request) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 构建RequestContext</span>
</span></span><span style=display:flex><span>    RequestContext rc <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> RequestContext(request);
</span></span><span style=display:flex><span>    log.<span style=color:#a6e22e>info</span>(<span style=color:#e6db74>&#34;locale: {}&#34;</span>, rc.<span style=color:#a6e22e>getLocale</span>());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ReqResult.<span style=color:#a6e22e>ok</span>(rc.<span style=color:#a6e22e>getMessage</span>(<span style=color:#e6db74>&#34;http.ok&#34;</span>), rc.<span style=color:#a6e22e>getLocale</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这个控制器可能的返回结果为：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;code&#34;</span>: <span style=color:#ae81ff>20000</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;msg&#34;</span>: <span style=color:#e6db74>&#34;success&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;data&#34;</span>: <span style=color:#e6db74>&#34;en&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;code&#34;</span>: <span style=color:#ae81ff>20000</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;msg&#34;</span>: <span style=color:#e6db74>&#34;成功&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;data&#34;</span>: <span style=color:#e6db74>&#34;zh_CN&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p><code>RequestContext</code>可以很方便的获取请求中包含的信息，可能的参数绑定（校验）错误等，还能直接获取Spring Message，很强大。</p><p>注意到，ServletRequest也有一个<code>getLocale()</code>方法，那么，我们直接从Request中获取Locale不是很方便么？就像这样：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span> <span style=color:#a6e22e>@GetMapping</span>(<span style=color:#e6db74>&#34;/request/locale&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> ReqResult<span style=color:#f92672>&lt;?&gt;</span> locale(HttpServletRequest request, HttpServletResponse response){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// TODO why this method always return client default locale?</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ReqResult.<span style=color:#a6e22e>ok</span>(request.<span style=color:#a6e22e>getLocale</span>());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>哈哈。似乎一切都完美。不过，注意看<code>ServletRequest.getLocale()</code>的
<a href=https://docs.oracle.com/javaee/6/api/javax/servlet/ServletRequest.html#getLocale%28%29>文档</a>你就会发现问题:</p><blockquote><p>Returns the <strong>preferred</strong> Locale that the client will accept content in, <em>based on the Accept-Language header</em>. If the client request doesn&rsquo;t provide an Accept-Language header, this method returns the default locale for the server.</p></blockquote><p>也就是说，从request中获取的并不是获取的Spring MVC Context当前使用的Locale信息。这一点在使用了<code>LocaleChangeInterceptor</code>之后，更能够得到
<a href=/zh/#proof>证明</a>。</p></blockquote><p>除了<code>RequestContext</code>的方式之外，还可以通过配置拦截器、通过特定的条件（比如请求参数）来更改Locale。</p><p>文档提到了几种不同的<code>LocaleResolver</code>：</p><ul><li><p>AcceptHeaderLocaleResolver</p><p>这个locale resolver已经在前文讨论过了，通过设置HTTP Header的<code>Accept-Language</code>请求头可以设置SpringMvc Context的Locale信息。这个resolver在前文就已经试验过了。</p></li><li><p>CookieLocaleResolver</p><p>这个locale resolver检查cookie中是否声明了Locale信息，如果有，则使用之。</p></li><li><p>SessionLocaleResolver</p><p>这个locale resolver可以从当前请求的HttpSession中获取Locale和TimeZone信息。由于和Session相关，故在切换Locale时没有cookie灵活，只有session关闭之后Locale配置才能重新设置。</p></li><li><p>LocaleChangeInterceptor</p><p>这是推荐使用的方式，通过拦截器+请求参数实现国际化。</p></li></ul><h3 id=83-通过localechangeinterceptor实现国际化>8.3 通过LocaleChangeInterceptor实现国际化
<a class=anchor href=#83-%e9%80%9a%e8%bf%87localechangeinterceptor%e5%ae%9e%e7%8e%b0%e5%9b%bd%e9%99%85%e5%8c%96>#</a></h3><p>以下两篇文章分别使用xml和java Bean的方式配置了<code>LocaleChangeInterceptor</code>，通过地址栏参数展现国际化信息：</p><ul><li><a href=https://howtodoinjava.com/spring-mvc/spring-mvc-internationalization-i18n-and-localization-i10n-example/#add_localeresolver_support>[基于xml的配置]Spring MVC Internationalization (i18n) and Localization (i10n) Example</a></li><li><a href=https://learningprogramming.net/java/spring-mvc/locale-and-internationalization-in-spring-mvc/>[基于java bean的配置]LOCALE AND INTERNATIONALIZATION IN SPRING MVC</a></li></ul><p>参考配置地址：</p><ul><li><a href=https://github.com/wangy325/mybatis-plus-starter/blob/master/web-security-demo/src/main/java/com/wangy/config/MessageSourceConfig.java>https://github.com/wangy325/mybatis-plus-starter/blob/master/web-security-demo/src/main/java/com/wangy/config/MessageSourceConfig.java</a></li><li><a href=https://github.com/wangy325/mybatis-plus-starter/blob/master/web-security-demo/src/main/java/com/wangy/config/WebConfig.java>https://github.com/wangy325/mybatis-plus-starter/blob/master/web-security-demo/src/main/java/com/wangy/config/WebConfig.java</a></li></ul><p>不妨看看<code>LocaleChangeInterceptor</code>是如何工作的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>preHandle</span>(HttpServletRequest request, HttpServletResponse response, Object handler)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throws</span> ServletException {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 从请求路径中获取Locale参数</span>
</span></span><span style=display:flex><span>    String newLocale <span style=color:#f92672>=</span> request.<span style=color:#a6e22e>getParameter</span>(getParamName());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (newLocale <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (checkHttpMethod(request.<span style=color:#a6e22e>getMethod</span>())) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// locale resovler</span>
</span></span><span style=display:flex><span>            LocaleResolver localeResolver <span style=color:#f92672>=</span> RequestContextUtils.<span style=color:#a6e22e>getLocaleResolver</span>(request);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (localeResolver <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalStateException(
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;No LocaleResolver found: not in a DispatcherServlet request?&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// 设置Locale信息</span>
</span></span><span style=display:flex><span>                localeResolver.<span style=color:#a6e22e>setLocale</span>(request, response, parseLocaleValue(newLocale));
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>catch</span> (IllegalArgumentException ex) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (isIgnoreInvalidLocale()) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (logger.<span style=color:#a6e22e>isDebugEnabled</span>()) {
</span></span><span style=display:flex><span>                        logger.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;Ignoring invalid locale value [&#34;</span> <span style=color:#f92672>+</span> newLocale <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;]: &#34;</span> <span style=color:#f92672>+</span> ex.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>throw</span> ex;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Proceed in any case.</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看到，<code>LocaleChangeInterceptor</code>的工作方式比较简单：</p><ol><li>从<strong>路径参数</strong>中获取Locale参数配置</li><li>获取LocaleResolver</li><li>利用LocaleResolver重新设置步骤1中获取的Locale配置</li></ol><p>这里有一个重点：LocaleResolver。如果不在项目中显示的配置<code>LocaleResolver</code>，那么此拦截器获取到的实例是<code>AcceptHeaderLocaleResolver</code>，这很致命：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#75715e>// AcceptHeaderLocaleResolver.java</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@Override</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setLocale</span>(HttpServletRequest request, <span style=color:#a6e22e>@Nullable</span> HttpServletResponse response, <span style=color:#a6e22e>@Nullable</span> Locale locale) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> UnsupportedOperationException(
</span></span><span style=display:flex><span>				<span style=color:#e6db74>&#34;Cannot change HTTP accept header - use a different locale resolution strategy&#34;</span>);
</span></span><span style=display:flex><span>	}
</span></span></code></pre></div><p>因为<code>AcceptHeaderLocaleResolver</code>的<code>setLocale()</code>方法直接抛出异常，导致Locale信息无法被设置。</p><p>所以，如果使用<code>LocaleChangeInterceptor</code>，那么必须要显式配置一个<code>LocalResolver</code>，可以是<code>SessionLocaleResolver</code>或者<code>CookieLocaleResolver</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#a6e22e>@Bean</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> SessionLocaleResolver <span style=color:#a6e22e>localeResolver</span>() {
</span></span><span style=display:flex><span>    SessionLocaleResolver sessionLocaleResolver <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SessionLocaleResolver();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 配置默认Locale</span>
</span></span><span style=display:flex><span>    sessionLocaleResolver.<span style=color:#a6e22e>setDefaultLocale</span>(locale);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sessionLocaleResolver;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样，保证即使不传递路径国际化参数，也能使用默认的Locale配置。</p><p><span id=proof>现在</span>，我们再回头看看从HttpServletRequest中获取当前MVC Context 的Locale信息失败的原因：</p><ol><li><code>LocaleChangeInterceptor</code>不与<code>AcceptHeaderLocaleResolver</code>兼容</li><li>HttpServletRequest从<code>Accept-Language</code>中获取Locale配置，否则返回服务器默认Locale信息</li></ol><p>这应该比较好理解了，即使设置了<code>Accept-language</code>，这个设置也不能被配置了<code>LocaleChangeInterceptor</code>的mvc容器采纳。</p><h2 id=9-参考>9 参考
<a class=anchor href=#9-%e5%8f%82%e8%80%83>#</a></h2><ul><li>原文地址：
<a href=https://www.baeldung.com/spring-custom-validation-message-source>https://www.baeldung.com/spring-custom-validation-message-source</a></li><li><a href=https://zetcode.com/spring/messagesource/>简单使用MessageSource</a></li><li><a href=https://stackoverflow.com/questions/15065734/spring-framework-no-message-found-under-code-for-locale/39371075>[stackoverflow] MessageSource配置异常</a></li><li><a href=https://stackoverflow.com/questions/39685399/reloadableresourcebundlemessagesource-vs-resourcebundlemessagesource-cache-con>[stackoverflow] 2个MessageSource的区别1</a></li><li><a href=https://github.com/spring-projects/spring-framework/issues/12050>[github issue] 2个MessageSource的区别2</a></li><li><a href=https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Language>如何设置HTTP请求头Accept-Language</a></li><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-functionality-messagesource>官方文档：使用messageSource进行国际化</a></li><li><a href=https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-localeresolver>官方文档：Spring MVC locale resovler</a></li><li><a href=https://stackoverflow.com/questions/46412984/controller-httpservletrequest-locale-does-not-change>HttpServletRequest并不能直接获取spring MVC Context当前的Locale信息</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><code>LocaleContextHolder</code>是它的完美替代。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>从文档和一些其他的资料来看，RRBMS是可以从任意位置读取配置文件的，不过笔者并没有实践这一说法。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/wangy325/endlessriver/commit/fdef4460000d54a11a8a9097f6f4db7f2f7676e2 title='最后修改者 wangy325 | 六月 19, 2024' target=_blank rel=noopener><img src=/svg/calendar.svg class=book-icon alt>
<span>六月 19, 2024</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//pkendlessriver.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><ul><li><a href=#2-引入maven依赖>2 引入Maven依赖</a></li><li><a href=#3-自定义校验信息示例>3 自定义校验信息示例</a></li><li><a href=#4-配置messagesource>4 配置MessageSource</a><ul><li><a href=#41-关于messagesource的自动配置>4.1 关于MessageSource的自动配置</a></li><li><a href=#42-rbms和rrbms>4.2 RBMS和RRBMS</a></li></ul></li><li><a href=#5-配置localvalidatorfactorybean>5 配置LocalValidatorFactoryBean</a></li><li><a href=#6-国际化properties文件>6 国际化properties文件</a><ul><li><a href=#61-messagesproperties>6.1 messages.properties</a></li><li><a href=#62-messages_frproperties>6.2 messages_fr.properties</a></li></ul></li><li><a href=#7-结论>7 结论</a></li><li><a href=#8-使用并解析message>8 使用并解析message</a><ul><li><a href=#81-localecontextholder和accept-language>8.1 LocaleContextHolder和Accept-Language</a></li><li><a href=#82-locale-resolver>8.2 Locale Resolver</a></li><li><a href=#83-通过localechangeinterceptor实现国际化>8.3 通过LocaleChangeInterceptor实现国际化</a></li></ul></li><li><a href=#9-参考>9 参考</a></li></ul></li></ul></nav></div></aside></main></body></html>